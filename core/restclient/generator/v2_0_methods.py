"""
----------------------------------------------------------------
          ***********************************************
          ***  THIS IS GENERATED CODE: DO NOT MODIFY  ***
          ***********************************************

            Copyright (c) 2009-2014 CSC, Incorporated
                     All Rights Reserved
  THIS WORK CONTAINS CONFIDENTIAL PROPPRIETARY INFORMATION AND
  TRADE SECRETS WHICH ARE THE PROPERTY OF CSC.  ALL USE,
  DISCLOSURE AND/OR REPRODUCTION NOT EXPRESSLY AUTHORIZED BY
  CSC IS PROHIBITED.
----------------------------------------------------------------
"""
import os
from core.restclient.responseparser.common import COMPONENT_NAME
from core.restclient.responseparser.common import AbstractProxy
import logging
COMPONENT_NAME = 'agility-client'
from logger import getLogger
logger = getLogger(COMPONENT_NAME)
from ..connection import RESTException
from ..responseparser.decorators import download

class assettype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /assettype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'assettype/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /assettype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addPermissionType(self,
                          assettype_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /assettype/{id}/permissiontype ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/permissiontype"
        path_params = {"id": assettype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addPermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'assettype/%(id)s/permissiontype', 'form_params': [], 'method_name': 'addPermissionType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /assettype/{id}/permissiontype ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAssetType(self,
                     assettype_id=None,
                     beanFields=None,
                     entityType=None,
                     **kwargs):
        """
        [ HTTP: GET /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param beanFields: beanFields
        @type beanFields: str
        @param entityType: entityType
        @type entityType: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"beanFields": beanFields,
                        "entityType": entityType}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAssetType.context = {'query_params': [{'defaultValue': None, 'alias': 'beanFields', 'kind': 'xs:boolean', 'required': False, 'name': 'beanFields'}, {'defaultValue': None, 'alias': 'entityType', 'kind': 'xs:string', 'required': False, 'name': 'entityType'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'assettype/%(id)s', 'form_params': [], 'method_name': 'getAssetType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'beanFields', 'kind': 'xs:boolean', 'required': False, 'name': 'beanFields'}, {'defaultValue': None, 'alias': 'entityType', 'kind': 'xs:string', 'required': False, 'name': 'entityType'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPermissionTypes(self,
                           assettype_id,
                           **kwargs):
        """
        [ HTTP: GET /assettype/{id}/permissiontype ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/permissiontype"
        path_params = {"id": assettype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPermissionTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'assettype/%(id)s/permissiontype', 'form_params': [], 'method_name': 'getPermissionTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/{id}/permissiontype ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAssetType(self,
                        assettype_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAssetType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'assettype/%(id)s', 'form_params': [], 'method_name': 'deleteAssetType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /assettype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAssetType(self,
                        assettype_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAssetType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'assettype/%(id)s', 'form_params': [], 'method_name': 'updateAssetType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /assettype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /assettype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /assettype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAssetTypeXML(self,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /assettype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAssetTypeXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype', 'form_params': [], 'method_name': 'createAssetTypeXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /assettype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     assettype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /assettype/{id}/export ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/export"
        path_params = {"id": assettype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'assettype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAssetTypesXML(self,
                         **kwargs):
        """
        [ HTTP: GET /assettype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAssetTypesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype', 'form_params': [], 'method_name': 'getAssetTypesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /assettype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class networkservice:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /networkservice/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'networkservice/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservice/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkService(self,
                          networkservice_id=None,
                          **kwargs):
        """
        [ HTTP: GET /networkservice/{id: [0-9]+} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id: [0-9]+)s"
        path_params = {"id": networkservice_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservice/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'getNetworkService', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkServicesByType(self,
                                 networkservice_type=None,
                                 **kwargs):
        """
        [ HTTP: GET /networkservice/{type: [^0-9]\w+} ]

        @param networkservice_type: networkservice_type
        @type networkservice_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(type: [^0-9]\w+)s"
        path_params = {"type": networkservice_type}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkServicesByType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'networkservice/%(type: [^0-9]\\w+)s', 'form_params': [], 'method_name': 'getNetworkServicesByType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/{type: [^0-9]\\w+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     networkservice_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /networkservice/{id}/export ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id)s/export"
        path_params = {"id": networkservice_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'networkservice/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /networkservice/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservice/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservice/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateNetworkService(self,
                             networkservice_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /networkservice/{id: [0-9]+} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id: [0-9]+)s"
        path_params = {"id": networkservice_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservice/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'updateNetworkService', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservice/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteNetworkService(self,
                             networkservice_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /networkservice/{id: [0-9]+} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id: [0-9]+)s"
        path_params = {"id": networkservice_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservice/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteNetworkService', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /networkservice/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkServices(self,
                           **kwargs):
        """
        [ HTTP: GET /networkservice ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservice', 'form_params': [], 'method_name': 'getNetworkServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /networkservice/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservice/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class blueprint_workload:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def createWorkload(self,
                       blueprint_bp_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /blueprint/{bp_id}/workload ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload"
        path_params = {"bp_id": blueprint_bp_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createWorkload.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}], 'method_path': 'blueprint/%(bp_id)s/workload', 'form_params': [], 'method_name': 'createWorkload', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{bp_id}/workload ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getWorkload(self,
                    blueprint_bp_id,
                    workload_id=None,
                    **kwargs):
        """
        [ HTTP: GET /blueprint/{bp_id}/workload/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param workload_id: workload_id
        @type workload_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": workload_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getWorkload.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'workload_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(bp_id)s/workload/%(id)s', 'form_params': [], 'method_name': 'getWorkload', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{bp_id}/workload/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'workload_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateWorkload(self,
                       blueprint_bp_id,
                       workload_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /blueprint/{bp_id}/workload/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param workload_id: workload_id
        @type workload_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": workload_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateWorkload.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'workload_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(bp_id)s/workload/%(id)s', 'form_params': [], 'method_name': 'updateWorkload', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /blueprint/{bp_id}/workload/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'workload_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteWorkload(self,
                       blueprint_bp_id,
                       workload_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /blueprint/{bp_id}/workload/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param workload_id: workload_id
        @type workload_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": workload_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteWorkload.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'workload_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(bp_id)s/workload/%(id)s', 'form_params': [], 'method_name': 'deleteWorkload', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /blueprint/{bp_id}/workload/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'workload_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class package:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def removeShutdownScript(self,
                             package_id,
                             shutdown_scriptid=None,
                             **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/shutdown/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param shutdown_scriptid: shutdown_scriptid
        @type shutdown_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/shutdown/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": shutdown_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removeShutdownScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/shutdown/%(scriptid)s', 'form_params': [], 'method_name': 'removeShutdownScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/shutdown/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removeOperationalScript(self,
                                package_id,
                                operational_scriptid=None,
                                **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/operational/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param operational_scriptid: operational_scriptid
        @type operational_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/operational/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": operational_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removeOperationalScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/operational/%(scriptid)s', 'form_params': [], 'method_name': 'removeOperationalScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/operational/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkOut(self,
                 package_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /package/{id}/checkout ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/checkout"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removeStartupScript(self,
                            package_id,
                            startup_scriptid=None,
                            **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/startup/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param startup_scriptid: startup_scriptid
        @type startup_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/startup/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": startup_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removeStartupScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/startup/%(scriptid)s', 'form_params': [], 'method_name': 'removeStartupScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/startup/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachInstallScript(self,
                            package_id,
                            install_scriptid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/install/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param install_scriptid: install_scriptid
        @type install_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/install/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": install_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachInstallScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/install/%(scriptid)s', 'form_params': [], 'method_name': 'attachInstallScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/install/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPackage(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /package ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'package', 'form_params': [], 'method_name': 'createPackage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkIn(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/checkin ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/checkin"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removeInstallScript(self,
                            package_id,
                            install_scriptid=None,
                            **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/install/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param install_scriptid: install_scriptid
        @type install_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/install/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": install_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removeInstallScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/install/%(scriptid)s', 'form_params': [], 'method_name': 'removeInstallScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/install/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPackages(self,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /package ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPackages.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPackageScripts(self,
                          package_id,
                          **kwargs):
        """
        [ HTTP: GET /package/{id}/script ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPackageScripts.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/script', 'form_params': [], 'method_name': 'getPackageScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deletePackage(self,
                      package_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletePackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'package/%(id)s', 'form_params': [], 'method_name': 'deletePackage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachShutdownScript(self,
                             package_id,
                             shutdown_scriptid=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/shutdown/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param shutdown_scriptid: shutdown_scriptid
        @type shutdown_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/shutdown/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": shutdown_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachShutdownScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/shutdown/%(scriptid)s', 'form_params': [], 'method_name': 'attachShutdownScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/shutdown/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachStartupScript(self,
                            package_id,
                            startup_scriptid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/startup/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param startup_scriptid: startup_scriptid
        @type startup_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/startup/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": startup_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachStartupScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/startup/%(scriptid)s', 'form_params': [], 'method_name': 'attachStartupScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/startup/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPackages(self,
                       **kwargs):
        """
        [ HTTP: GET /package/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPackages.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'package/search', 'form_params': [], 'method_name': 'searchPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachOperationalScript(self,
                                package_id,
                                operational_scriptid=None,
                                data=None,
                                **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/operational/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param operational_scriptid: operational_scriptid
        @type operational_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/operational/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": operational_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachOperationalScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/operational/%(scriptid)s', 'form_params': [], 'method_name': 'attachOperationalScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/operational/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAllVersions(self,
                       package_slotId,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /package/{slotId}/version ]

        @param package_slotId: package_slotId
        @type package_slotId: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(slotId)s/version"
        path_params = {"slotId": package_slotId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"includeHead": includeHead}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAllVersions.context = {'query_params': [{'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}], 'method_path': 'package/%(slotId)s/version', 'form_params': [], 'method_name': 'getAllVersions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{slotId}/version ]', 'method_params': [{'defaultValue': None, 'alias': 'package_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}, {'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPackage(self,
                   package_id=None,
                   **kwargs):
        """
        [ HTTP: GET /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'package/%(id)s', 'form_params': [], 'method_name': 'getPackage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               package_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /package/{id}/reject ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/reject"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     package_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /package/{id}/export ]

        @param package_id: package_id
        @type package_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/export"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /package/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'package/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/approve ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/approve"
        path_params = {"id": package_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class image:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getImage(self,
                 image_id=None,
                 **kwargs):
        """
        [ HTTP: GET /image/{id} ]

        @param image_id: image_id
        @type image_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s"
        path_params = {"id": image_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getImage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'image/%(id)s', 'form_params': [], 'method_name': 'getImage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchImages(self,
                     **kwargs):
        """
        [ HTTP: GET /image/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchImages.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'image/search', 'form_params': [], 'method_name': 'searchImages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     image_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /image/{id}/export ]

        @param image_id: image_id
        @type image_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s/export"
        path_params = {"id": image_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'image/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /image/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'image/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteImage(self,
                    image_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /image/{id} ]

        @param image_id: image_id
        @type image_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s"
        path_params = {"id": image_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteImage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'image/%(id)s', 'form_params': [], 'method_name': 'deleteImage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /image/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getImagesXML(self,
                     **kwargs):
        """
        [ HTTP: GET /image ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getImagesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'image', 'form_params': [], 'method_name': 'getImagesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class address:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getAddress(self,
                   address_id=None,
                   **kwargs):
        """
        [ HTTP: GET /address/{id} ]

        @param address_id: address_id
        @type address_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "address/%(id)s"
        path_params = {"id": address_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAddress.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'address_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'address/%(id)s', 'form_params': [], 'method_name': 'getAddress', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /address/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'address_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storerelease:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getReleases(self,
                    **kwargs):
        """
        [ HTTP: GET /storerelease ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storerelease"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getReleases.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storerelease', 'form_params': [], 'method_name': 'getReleases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storerelease ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchReleases(self,
                       **kwargs):
        """
        [ HTTP: GET /storerelease/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storerelease/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchReleases.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storerelease/search', 'form_params': [], 'method_name': 'searchReleases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storerelease/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRelease(self,
                   storerelease_id=None,
                   **kwargs):
        """
        [ HTTP: GET /storerelease/{id} ]

        @param storerelease_id: storerelease_id
        @type storerelease_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storerelease/%(id)s"
        path_params = {"id": storerelease_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRelease.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storerelease_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storerelease/%(id)s', 'form_params': [], 'method_name': 'getRelease', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storerelease/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storerelease_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class deployer:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def searchDeployers(self,
                        **kwargs):
        """
        [ HTTP: GET /deployer/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchDeployers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'deployer/search', 'form_params': [], 'method_name': 'searchDeployers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /deployer/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployers(self,
                     **kwargs):
        """
        [ HTTP: GET /deployer ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'deployer', 'form_params': [], 'method_name': 'getDeployers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /deployer ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateDeployer(self,
                       deployer_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /deployer/{id} ]

        @param deployer_id: deployer_id
        @type deployer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/%(id)s"
        path_params = {"id": deployer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'deployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'deployer/%(id)s', 'form_params': [], 'method_name': 'updateDeployer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /deployer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'deployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDeployer(self,
                       deployer_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /deployer/{id} ]

        @param deployer_id: deployer_id
        @type deployer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/%(id)s"
        path_params = {"id": deployer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'deployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'deployer/%(id)s', 'form_params': [], 'method_name': 'deleteDeployer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /deployer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'deployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifactTypes(self,
                         **kwargs):
        """
        [ HTTP: GET /deployer/artifacttype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/artifacttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifactTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'deployer/artifacttype', 'form_params': [], 'method_name': 'getArtifactTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /deployer/artifacttype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployer(self,
                    deployer_id=None,
                    **kwargs):
        """
        [ HTTP: GET /deployer/{id} ]

        @param deployer_id: deployer_id
        @type deployer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/%(id)s"
        path_params = {"id": deployer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'deployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'deployer/%(id)s', 'form_params': [], 'method_name': 'getDeployer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /deployer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'deployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTemplates(self,
                     locationId=None,
                     **kwargs):
        """
        [ HTTP: GET /deployer/template/location/{locationId} ]

        @param locationId: locationId
        @type locationId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/template/location/%(locationId)s"
        path_params = {"locationId": locationId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}], 'method_path': 'deployer/template/location/%(locationId)s', 'form_params': [], 'method_name': 'getTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /deployer/template/location/{locationId} ]', 'method_params': [{'defaultValue': None, 'alias': 'locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class targetcloud:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getTargetCloud(self,
                       targetcloud_id=None,
                       **kwargs):
        """
        [ HTTP: GET /targetcloud/{id} ]

        @param targetcloud_id: targetcloud_id
        @type targetcloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "targetcloud/%(id)s"
        path_params = {"id": targetcloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTargetCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'targetcloud/%(id)s', 'form_params': [], 'method_name': 'getTargetCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /targetcloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTargetCloudsXML(self,
                           **kwargs):
        """
        [ HTTP: GET /targetcloud ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "targetcloud"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTargetCloudsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'targetcloud', 'form_params': [], 'method_name': 'getTargetCloudsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /targetcloud ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class configuration_repository:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /configuration/repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'configuration/repository/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/repository/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRepositories(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/repository ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRepositories.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/repository', 'form_params': [], 'method_name': 'getRepositories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/repository ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateRepository(self,
                         repository_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /configuration/repository/{id} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/repository/%(id)s', 'form_params': [], 'method_name': 'updateRepository', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/repository/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRepository(self,
                      repository_id=None,
                      **kwargs):
        """
        [ HTTP: GET /configuration/repository/{id} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/repository/%(id)s', 'form_params': [], 'method_name': 'getRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/repository/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def syncRepository(self,
                       repository_id,
                       **kwargs):
        """
        [ HTTP: GET /configuration/repository/{id}/sync ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s/sync"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    syncRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/repository/%(id)s/sync', 'form_params': [], 'method_name': 'syncRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/repository/{id}/sync ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteConfigurationRepository(self,
                                      repository_id=None,
                                      **kwargs):
        """
        [ HTTP: DELETE /configuration/repository/{id} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteConfigurationRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/repository/%(id)s', 'form_params': [], 'method_name': 'deleteConfigurationRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /configuration/repository/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     repository_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/repository/{id}/export ]

        @param repository_id: repository_id
        @type repository_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s/export"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/repository/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/repository/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /configuration/repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/repository/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/repository/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createRepository(self,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /configuration/repository ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/repository', 'form_params': [], 'method_name': 'createRepository', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /configuration/repository ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/repository/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/repository/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/repository/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchRepositories(self,
                           **kwargs):
        """
        [ HTTP: GET /configuration/repository/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchRepositories.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/repository/search', 'form_params': [], 'method_name': 'searchRepositories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/repository/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class repository:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'repository/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def putObject(self,
                  repository_id,
                  path=None,
                  Content_Length=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: PUT /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param Content_Length: Content_Length
        @type Content_Length: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"Content_Length": Content_Length}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/octet-stream'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    putObject.context = {'query_params': [{'defaultValue': None, 'alias': 'Content_Length', 'kind': 'xs:long', 'required': False, 'name': 'Content_Length'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'putObject', 'custom_headers': {'Content-Type': 'application/octet-stream'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': 'Content_Length', 'kind': 'xs:long', 'required': False, 'name': 'Content_Length'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'repository/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteRepository(self,
                         repository_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateRepositoryUsage(self,
                              repository_id=None,
                              usage=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param usage: usage
        @type usage: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"usage": usage}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateRepositoryUsage.context = {'query_params': [{'defaultValue': None, 'alias': 'usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'updateRepositoryUsage', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateRepository(self,
                         repository_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'updateRepository', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRepository(self,
                      repository_id=None,
                      **kwargs):
        """
        [ HTTP: GET /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'getRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getObject(self,
                  repository_id,
                  path=None,
                  **kwargs):
        """
        [ HTTP: GET /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getObject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'getObject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRepositories(self,
                        **kwargs):
        """
        [ HTTP: GET /repository ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRepositories.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'repository', 'form_params': [], 'method_name': 'getRepositories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getListing(self,
                   repository_id,
                   path=None,
                   **kwargs):
        """
        [ HTTP: GET /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getListing.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'getListing', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     repository_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /repository/{id}/export ]

        @param repository_id: repository_id
        @type repository_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/export"
        path_params = {"id": repository_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'repository/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRepositoriesByUsage(self,
                               repository_usage=None,
                               **kwargs):
        """
        [ HTTP: GET /repository/{usage: (templates)|(instances)|(storage)|(attachments)|(backups)} ]

        @param repository_usage: repository_usage
        @type repository_usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(usage: (templates)|(instances)|(storage)|(attachments)|(backups))s"
        path_params = {"usage": repository_usage}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRepositoriesByUsage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}], 'method_path': 'repository/%(usage: (templates)|(instances)|(storage)|(attachments)|(backups))s', 'form_params': [], 'method_name': 'getRepositoriesByUsage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{usage: (templates)|(instances)|(storage)|(attachments)|(backups)} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteObject(self,
                     repository_id,
                     path=None,
                     **kwargs):
        """
        [ HTTP: DELETE /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteObject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'deleteObject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /repository/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'repository/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class blueprint:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getBlueprint(self,
                     blueprint_id=None,
                     validate=None,
                     **kwargs):
        """
        [ HTTP: GET /blueprint/{id} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param validate: validate
        @type validate: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"validate": validate}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getBlueprint.context = {'query_params': [{'defaultValue': None, 'alias': 'validate', 'kind': 'xs:boolean', 'required': False, 'name': 'validate'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(id)s', 'form_params': [], 'method_name': 'getBlueprint', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'validate', 'kind': 'xs:boolean', 'required': False, 'name': 'validate'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def validateDeploymentPlan(self,
                               blueprint_id,
                               deploymentplan_containerId=None,
                               policyIds=None,
                               logLevel=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deploymentplan/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploymentplan/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploymentplan_containerId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    validateDeploymentPlan.context = {'query_params': [{'defaultValue': None, 'alias': 'policyIds', 'kind': 'xs:string', 'required': False, 'name': 'policyIds'}, {'defaultValue': None, 'alias': 'logLevel', 'kind': 'xs:int', 'required': False, 'name': 'logLevel'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploymentplan_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}], 'method_path': 'blueprint/%(id)s/deploymentplan/%(containerId)s', 'form_params': [], 'method_name': 'validateDeploymentPlan', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/deploymentplan/{containerId} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploymentplan_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}, {'defaultValue': None, 'alias': 'policyIds', 'kind': 'xs:string', 'required': False, 'name': 'policyIds'}, {'defaultValue': None, 'alias': 'logLevel', 'kind': 'xs:int', 'required': False, 'name': 'logLevel'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deployRequest(self,
                      blueprint_id,
                      deployrequest_containerId=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deployrequest/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deployrequest_containerId: deployrequest_containerId
        @type deployrequest_containerId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deployrequest/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deployrequest_containerId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deployRequest.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deployrequest_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}], 'method_path': 'blueprint/%(id)s/deployrequest/%(containerId)s', 'form_params': [], 'method_name': 'deployRequest', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/deployrequest/{containerId} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deployrequest_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateBlueprint(self,
                        blueprint_id=None,
                        force=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /blueprint/{id} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param force: force
        @type force: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"force": force}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateBlueprint.context = {'query_params': [{'defaultValue': None, 'alias': 'force', 'kind': 'xs:boolean', 'required': False, 'name': 'force'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(id)s', 'form_params': [], 'method_name': 'updateBlueprint', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /blueprint/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'force', 'kind': 'xs:boolean', 'required': False, 'name': 'force'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteBlueprint(self,
                        blueprint_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /blueprint/{id} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteBlueprint.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(id)s', 'form_params': [], 'method_name': 'deleteBlueprint', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /blueprint/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSlot(self,
                   blueprint_slotId,
                   **kwargs):
        """
        [ HTTP: DELETE /blueprint/{slotId}/slot ]

        @param blueprint_slotId: blueprint_slotId
        @type blueprint_slotId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(slotId)s/slot"
        path_params = {"slotId": blueprint_slotId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSlot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}], 'method_path': 'blueprint/%(slotId)s/slot', 'form_params': [], 'method_name': 'deleteSlot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /blueprint/{slotId}/slot ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     blueprint_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /blueprint/{id}/export ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/export"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getBlueprints(self,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /blueprint ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getBlueprints.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'blueprint', 'form_params': [], 'method_name': 'getBlueprints', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkOut(self,
                 blueprint_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/checkout ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/checkout"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def validateBlueprint(self,
                          randomize=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /blueprint/validate ]

        @param randomize: randomize
        @type randomize: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/validate"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"randomize": randomize}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    validateBlueprint.context = {'query_params': [{'defaultValue': None, 'alias': 'randomize', 'kind': 'xs:boolean', 'required': False, 'name': 'randomize'}], 'hasFiles': False, 'path_params': [], 'method_path': 'blueprint/validate', 'form_params': [], 'method_name': 'validateBlueprint', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/validate ]', 'method_params': [{'defaultValue': None, 'alias': 'randomize', 'kind': 'xs:boolean', 'required': False, 'name': 'randomize'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkIn(self,
                blueprint_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/checkin ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/checkin"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAllVersions(self,
                       blueprint_slotId,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /blueprint/{slotId}/version ]

        @param blueprint_slotId: blueprint_slotId
        @type blueprint_slotId: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(slotId)s/version"
        path_params = {"slotId": blueprint_slotId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"includeHead": includeHead}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAllVersions.context = {'query_params': [{'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}], 'method_path': 'blueprint/%(slotId)s/version', 'form_params': [], 'method_name': 'getAllVersions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{slotId}/version ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}, {'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deploy2(self,
                blueprint_id,
                deploy_containerId=None,
                policyIds=None,
                logLevel=None,
                **kwargs):
        """
        [ HTTP: GET /blueprint/{id}/deploy/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploy_containerId: deploy_containerId
        @type deploy_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploy/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploy_containerId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deploy2.context = {'query_params': [{'defaultValue': None, 'alias': 'policyIds', 'kind': 'xs:string', 'required': False, 'name': 'policyIds'}, {'defaultValue': None, 'alias': 'logLevel', 'kind': 'xs:int', 'required': False, 'name': 'logLevel'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploy_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}], 'method_path': 'blueprint/%(id)s/deploy/%(containerId)s', 'form_params': [], 'method_name': 'deploy2', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{id}/deploy/{containerId} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploy_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}, {'defaultValue': None, 'alias': 'policyIds', 'kind': 'xs:string', 'required': False, 'name': 'policyIds'}, {'defaultValue': None, 'alias': 'logLevel', 'kind': 'xs:int', 'required': False, 'name': 'logLevel'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               blueprint_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/reject ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/reject"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /blueprint/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'blueprint/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkInByLocation(self,
                          blueprint_id,
                          checkin_locationId=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/checkin/{locationId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param checkin_locationId: checkin_locationId
        @type checkin_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/checkin/%(locationId)s"
        path_params = {"id": blueprint_id,
                       "locationId": checkin_locationId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkInByLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'checkin_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}], 'method_path': 'blueprint/%(id)s/checkin/%(locationId)s', 'form_params': [], 'method_name': 'checkInByLocation', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/checkin/{locationId} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'checkin_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deploy(self,
               blueprint_id,
               deploy_containerId=None,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deploy/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploy_containerId: deploy_containerId
        @type deploy_containerId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploy/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploy_containerId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deploy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploy_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}], 'method_path': 'blueprint/%(id)s/deploy/%(containerId)s', 'form_params': [], 'method_name': 'deploy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/deploy/{containerId} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploy_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def clone(self,
              blueprint_id,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/clone ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/clone"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    clone.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/clone', 'form_params': [], 'method_name': 'clone', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createDeployer(self,
                       blueprint_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deployer ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deployer"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/deployer', 'form_params': [], 'method_name': 'createDeployer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/deployer ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchBlueprints(self,
                         **kwargs):
        """
        [ HTTP: GET /blueprint/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchBlueprints.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'blueprint/search', 'form_params': [], 'method_name': 'searchBlueprints', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeploymentPlan(self,
                          blueprint_id,
                          deploymentplan_containerId=None,
                          policyIds=None,
                          logLevel=None,
                          **kwargs):
        """
        [ HTTP: GET /blueprint/{id}/deploymentplan/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploymentplan/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploymentplan_containerId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeploymentPlan.context = {'query_params': [{'defaultValue': None, 'alias': 'policyIds', 'kind': 'xs:string', 'required': False, 'name': 'policyIds'}, {'defaultValue': None, 'alias': 'logLevel', 'kind': 'xs:int', 'required': False, 'name': 'logLevel'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploymentplan_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}], 'method_path': 'blueprint/%(id)s/deploymentplan/%(containerId)s', 'form_params': [], 'method_name': 'getDeploymentPlan', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{id}/deploymentplan/{containerId} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploymentplan_containerId', 'kind': 'xs:int', 'required': False, 'name': 'containerId'}, {'defaultValue': None, 'alias': 'policyIds', 'kind': 'xs:string', 'required': False, 'name': 'policyIds'}, {'defaultValue': None, 'alias': 'logLevel', 'kind': 'xs:int', 'required': False, 'name': 'logLevel'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                blueprint_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/approve ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/approve"
        path_params = {"id": blueprint_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'blueprint/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class security:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getEffectiveRights(self,
                           security_type,
                           id=None,
                           **kwargs):
        """
        [ HTTP: GET /security/{type}/{id} ]

        @param security_type: security_type
        @type security_type: str
        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/%(type)s/%(id)s"
        path_params = {"type": security_type,
                       "id": id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEffectiveRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'security/%(type)s/%(id)s', 'form_params': [], 'method_name': 'getEffectiveRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/{type}/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkRight(self,
                   security_type,
                   id,
                   rightid=None,
                   **kwargs):
        """
        [ HTTP: GET /security/{type}/{id}/right/{rightid} ]

        @param security_type: security_type
        @type security_type: str
        @param id: id
        @type id: str
        @param rightid: rightid
        @type rightid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/%(type)s/%(id)s/right/%(rightid)s"
        path_params = {"type": security_type,
                       "id": id,
                       "rightid": rightid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}], 'method_path': 'security/%(type)s/%(id)s/right/%(rightid)s', 'form_params': [], 'method_name': 'checkRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/{type}/{id}/right/{rightid} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def clearCache(self,
                   **kwargs):
        """
        [ HTTP: DELETE /security/cache ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/cache"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    clearCache.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'security/cache', 'form_params': [], 'method_name': 'clearCache', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /security/cache ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkGlobalRight(self,
                         rightid=None,
                         **kwargs):
        """
        [ HTTP: GET /security/global/right/{rightid} ]

        @param rightid: rightid
        @type rightid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/global/right/%(rightid)s"
        path_params = {"rightid": rightid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkGlobalRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}], 'method_path': 'security/global/right/%(rightid)s', 'form_params': [], 'method_name': 'checkGlobalRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/global/right/{rightid} ]', 'method_params': [{'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEffectiveGlobalRights(self,
                                 **kwargs):
        """
        [ HTTP: GET /security/global ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/global"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEffectiveGlobalRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'security/global', 'form_params': [], 'method_name': 'getEffectiveGlobalRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/global ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPermittedTree(self,
                         tree_type,
                         action=None,
                         startContainerId=None,
                         format=None,
                         **kwargs):
        """
        [ HTTP: GET /security/tree/{type}/{action} ]

        @param tree_type: tree_type
        @type tree_type: str
        @param action: action
        @type action: str
        @param startContainerId: startContainerId
        @type startContainerId: str
        @param format: format
        @type format: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/tree/%(type)s/%(action)s"
        path_params = {"type": tree_type,
                       "action": action}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"startContainerId": startContainerId,
                        "format": format}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPermittedTree.context = {'query_params': [{'defaultValue': None, 'alias': 'startContainerId', 'kind': 'xs:int', 'required': False, 'name': 'startContainerId'}, {'defaultValue': None, 'alias': 'format', 'kind': 'xs:string', 'required': False, 'name': 'format'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'tree_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'action', 'kind': 'xs:string', 'required': False, 'name': 'action'}], 'method_path': 'security/tree/%(type)s/%(action)s', 'form_params': [], 'method_name': 'getPermittedTree', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/tree/{type}/{action} ]', 'method_params': [{'defaultValue': None, 'alias': 'tree_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'action', 'kind': 'xs:string', 'required': False, 'name': 'action'}, {'defaultValue': None, 'alias': 'startContainerId', 'kind': 'xs:int', 'required': False, 'name': 'startContainerId'}, {'defaultValue': None, 'alias': 'format', 'kind': 'xs:string', 'required': False, 'name': 'format'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class propertygroup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deletePropertyDefinitionGroup(self,
                                      propertygroup_id=None,
                                      **kwargs):
        """
        [ HTTP: DELETE /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletePropertyDefinitionGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s', 'form_params': [], 'method_name': 'deletePropertyDefinitionGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /propertygroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /propertygroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'propertygroup/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertygroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPropertyDefinitionGroup(self,
                                   propertygroup_id=None,
                                   **kwargs):
        """
        [ HTTP: GET /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPropertyDefinitionGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s', 'form_params': [], 'method_name': 'getPropertyDefinitionGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPropertyDefinitionGroupsXML(self,
                                       **kwargs):
        """
        [ HTTP: GET /propertygroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPropertyDefinitionGroupsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup', 'form_params': [], 'method_name': 'getPropertyDefinitionGroupsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     propertygroup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /propertygroup/{id}/export ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s/export"
        path_params = {"id": propertygroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /propertygroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertygroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPropertyDefinitionGroupXML(self,
                                         data=None,
                                         **kwargs):
        """
        [ HTTP: POST /propertygroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPropertyDefinitionGroupXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup', 'form_params': [], 'method_name': 'createPropertyDefinitionGroupXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /propertygroup ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updatePropertyDefinitionGroup(self,
                                      propertygroup_id=None,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: PUT /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updatePropertyDefinitionGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s', 'form_params': [], 'method_name': 'updatePropertyDefinitionGroup', 'custom_headers': {'Content-Type': 'application/x-www-form-urlencoded'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertygroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /propertygroup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class reports:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def puppetReport(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /reports/puppet ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "reports/puppet"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-yaml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    puppetReport.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'reports/puppet', 'form_params': [], 'method_name': 'puppetReport', 'custom_headers': {'Content-Type': 'application/x-yaml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /reports/puppet ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class container:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importIDActionXML(self,
                          container_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /container/{id}/import ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/import"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSecurity(self,
                    container_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/security/{security_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removePolicy(self,
                     container_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /container/{id}/policy/{policyid} ]

        @param container_id: container_id
        @type container_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy/%(policyid)s"
        path_params = {"id": container_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'container/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createConfigurationRepository(self,
                                      container_id,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: POST /container/{id}/configuration/repository ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/configuration/repository"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createConfigurationRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/configuration/repository', 'form_params': [], 'method_name': 'createConfigurationRepository', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/configuration/repository ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicyAssignments(self,
                                container_id,
                                **kwargs):
        """
        [ HTTP: GET /container/{id}/policyassignment/search ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policyassignment/search"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     container_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /container/{id}/export ]

        @param container_id: container_id
        @type container_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/export"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProjects(self,
                    container_id,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/project ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/project"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/project', 'form_params': [], 'method_name': 'getProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/project ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteContainer(self,
                        container_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'container/%(id)s', 'form_params': [], 'method_name': 'deleteContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchContainers(self,
                         **kwargs):
        """
        [ HTTP: GET /container/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container/search', 'form_params': [], 'method_name': 'searchContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUserGroup(self,
                                container_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachPolicy(self,
                     container_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /container/{id}/policy/{policyid} ]

        @param container_id: container_id
        @type container_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy/%(policyid)s"
        path_params = {"id": container_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'container/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurity(self,
                    container_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /container/{id}/security ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getContainer(self,
                     container_id=None,
                     **kwargs):
        """
        [ HTTP: GET /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'container/%(id)s', 'form_params': [], 'method_name': 'getContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /container/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [], 'method_path': 'container/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/export ]', 'method_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getContainersById(self,
                          container_id,
                          **kwargs):
        """
        [ HTTP: GET /container/{id}/container ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/container"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getContainersById.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/container', 'form_params': [], 'method_name': 'getContainersById', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/container ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityRights(self,
                             container_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUser(self,
                           container_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/user/{user_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "user_id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurity(self,
                       container_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUserGroup(self,
                             container_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/usergroup ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": container_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createProject(self,
                      container_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /container/{id}/project ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/project"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/project', 'form_params': [], 'method_name': 'createProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/project ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createContainer(self,
                        container_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /container/{id}/container ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/container"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/container', 'form_params': [], 'method_name': 'createContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/container ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityRights(self,
                          container_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/rights ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": container_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getContainers(self,
                      **kwargs):
        """
        [ HTTP: GET /container ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container', 'form_params': [], 'method_name': 'getContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /container/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'container/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityAccessRight(self,
                               container_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUser(self,
                        container_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/user ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/user"
        path_params = {"id": container_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicies(self,
                    container_id,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/policy ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /container/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityAccessRight(self,
                                  container_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDAction(self,
                       container_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /container/{id}/import ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/import"
        path_params = {"id": container_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAll(self,
                  exportOpts=None,
                  **kwargs):
        """
        [ HTTP: GET /container/exportTree ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/exportTree"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAll.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [], 'method_path': 'container/exportTree', 'form_params': [], 'method_name': 'exportAll', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/exportTree ]', 'method_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class search:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getSearchFields(self,
                        field_type=None,
                        **kwargs):
        """
        [ HTTP: GET /search/field/{type} ]

        @param field_type: field_type
        @type field_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search/field/%(type)s"
        path_params = {"type": field_type}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSearchFields.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'field_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'search/field/%(type)s', 'form_params': [], 'method_name': 'getSearchFields', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /search/field/{type} ]', 'method_params': [{'defaultValue': None, 'alias': 'field_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def search(self,
               **kwargs):
        """
        [ HTTP: GET /search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    search.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'search', 'form_params': [], 'method_name': 'search', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchAssets(self,
                     **kwargs):
        """
        [ HTTP: GET /search/asset ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search/asset"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchAssets.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'search/asset', 'form_params': [], 'method_name': 'searchAssets', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /search/asset ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storeproducttype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getProductType(self,
                       storeproducttype_id=None,
                       **kwargs):
        """
        [ HTTP: GET /storeproducttype/{id} ]

        @param storeproducttype_id: storeproducttype_id
        @type storeproducttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/%(id)s"
        path_params = {"id": storeproducttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProductType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproducttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeproducttype/%(id)s', 'form_params': [], 'method_name': 'getProductType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproducttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproducttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProductTypes(self,
                        **kwargs):
        """
        [ HTTP: GET /storeproducttype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProductTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproducttype', 'form_params': [], 'method_name': 'getProductTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproducttype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createProductType(self,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /storeproducttype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createProductType.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproducttype', 'form_params': [], 'method_name': 'createProductType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storeproducttype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProductAdapterItems(self,
                               storeproducttype_ptype,
                               **kwargs):
        """
        [ HTTP: GET /storeproducttype/{ptype}/products ]

        @param storeproducttype_ptype: storeproducttype_ptype
        @type storeproducttype_ptype: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/%(ptype)s/products"
        path_params = {"ptype": storeproducttype_ptype}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProductAdapterItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproducttype_ptype', 'kind': 'xs:string', 'required': True, 'name': 'ptype'}], 'method_path': 'storeproducttype/%(ptype)s/products', 'form_params': [], 'method_name': 'getProductAdapterItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproducttype/{ptype}/products ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproducttype_ptype', 'kind': 'xs:string', 'required': True, 'name': 'ptype'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     storeproducttype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storeproducttype/{id}/export ]

        @param storeproducttype_id: storeproducttype_id
        @type storeproducttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/%(id)s/export"
        path_params = {"id": storeproducttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproducttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storeproducttype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproducttype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproducttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storeproducttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproducttype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproducttype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchProductTypes(self,
                           **kwargs):
        """
        [ HTTP: GET /storeproducttype/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchProductTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproducttype/search', 'form_params': [], 'method_name': 'searchProductTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproducttype/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class custom:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getAsset(self,
                 custom_id=None,
                 **kwargs):
        """
        [ HTTP: GET /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAsset.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'custom/%(id)s', 'form_params': [], 'method_name': 'getAsset', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteCustomItem(self,
                         custom_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteCustomItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'custom/%(id)s', 'form_params': [], 'method_name': 'deleteCustomItem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /custom/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAsset(self,
                    custom_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAsset.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'custom/%(id)s', 'form_params': [], 'method_name': 'updateAsset', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /custom/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAssetXML(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /custom ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAssetXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom', 'form_params': [], 'method_name': 'createAssetXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /custom ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCustomItems(self,
                          **kwargs):
        """
        [ HTTP: GET /custom/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCustomItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom/search', 'form_params': [], 'method_name': 'searchCustomItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAssetsXML(self,
                     **kwargs):
        """
        [ HTTP: GET /custom ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAssetsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom', 'form_params': [], 'method_name': 'getAssetsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     custom_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /custom/{id}/export ]

        @param custom_id: custom_id
        @type custom_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s/export"
        path_params = {"id": custom_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'custom/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /custom/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class launchitem:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def searchLaunchItems(self,
                          **kwargs):
        """
        [ HTTP: GET /launchitem/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchLaunchItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'launchitem/search', 'form_params': [], 'method_name': 'searchLaunchItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitem/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deploy(self,
               launchitem_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/deploy ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/deploy"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deploy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/deploy', 'form_params': [], 'method_name': 'deploy', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /launchitem/{id}/deploy ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               launchitem_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /launchitem/{id}/reject ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/reject"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /launchitem/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getLaunchItem(self,
                      launchitem_id=None,
                      **kwargs):
        """
        [ HTTP: GET /launchitem/{id} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getLaunchItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'launchitem/%(id)s', 'form_params': [], 'method_name': 'getLaunchItem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitem/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def restartLaunchItem(self,
                          launchitem_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/restart ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/restart"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    restartLaunchItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/restart', 'form_params': [], 'method_name': 'restartLaunchItem', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /launchitem/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deployByLocation(self,
                         launchitem_id,
                         deploy_locationId=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/deploy/{locationId} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param deploy_locationId: deploy_locationId
        @type deploy_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/deploy/%(locationId)s"
        path_params = {"id": launchitem_id,
                       "locationId": deploy_locationId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deployByLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploy_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}], 'method_path': 'launchitem/%(id)s/deploy/%(locationId)s', 'form_params': [], 'method_name': 'deployByLocation', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /launchitem/{id}/deploy/{locationId} ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'deploy_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getInstances(self,
                     launchitem_id,
                     **kwargs):
        """
        [ HTTP: GET /launchitem/{id}/instances ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/instances"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/instances', 'form_params': [], 'method_name': 'getInstances', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitem/{id}/instances ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteLaunchItem(self,
                         launchitem_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /launchitem/{id} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteLaunchItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'launchitem/%(id)s', 'form_params': [], 'method_name': 'deleteLaunchItem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /launchitem/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stopLaunchItem(self,
                       launchitem_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/stop ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/stop"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stopLaunchItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/stop', 'form_params': [], 'method_name': 'stopLaunchItem', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /launchitem/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                launchitem_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /launchitem/{id}/approve ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/approve"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /launchitem/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getLaunchItems(self,
                       **kwargs):
        """
        [ HTTP: GET /launchitem ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getLaunchItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'launchitem', 'form_params': [], 'method_name': 'getLaunchItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitem ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def releaseLaunchItem(self,
                          launchitem_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/release ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/release"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    releaseLaunchItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/release', 'form_params': [], 'method_name': 'releaseLaunchItem', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /launchitem/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def startLaunchItem(self,
                        launchitem_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/start ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/start"
        path_params = {"id": launchitem_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    startLaunchItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitem/%(id)s/start', 'form_params': [], 'method_name': 'startLaunchItem', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /launchitem/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitem_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class ldapgroup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getMappings(self,
                    **kwargs):
        """
        [ HTTP: GET /ldapgroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getMappings.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'ldapgroup', 'form_params': [], 'method_name': 'getMappings', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /ldapgroup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMappingXML(self,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /ldapgroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMappingXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'ldapgroup', 'form_params': [], 'method_name': 'createMappingXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /ldapgroup ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def setMappings(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /ldapgroup/set ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/set"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setMappings.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'ldapgroup/set', 'form_params': [], 'method_name': 'setMappings', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /ldapgroup/set ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteMapping(self,
                      ldapgroup_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /ldapgroup/{id} ]

        @param ldapgroup_id: ldapgroup_id
        @type ldapgroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(id)s"
        path_params = {"id": ldapgroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapgroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'ldapgroup/%(id)s', 'form_params': [], 'method_name': 'deleteMapping', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /ldapgroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapgroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMapping(self,
                      ldapgroup_ldapGpName,
                      agilityGpName=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /ldapgroup/{ldapGpName}/{agilityGpName} ]

        @param ldapgroup_ldapGpName: ldapgroup_ldapGpName
        @type ldapgroup_ldapGpName: str
        @param agilityGpName: agilityGpName
        @type agilityGpName: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(ldapGpName)s/%(agilityGpName)s"
        path_params = {"ldapGpName": ldapgroup_ldapGpName,
                       "agilityGpName": agilityGpName}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapgroup_ldapGpName', 'kind': 'xs:string', 'required': True, 'name': 'ldapGpName'}, {'defaultValue': None, 'alias': 'agilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'agilityGpName'}], 'method_path': 'ldapgroup/%(ldapGpName)s/%(agilityGpName)s', 'form_params': [], 'method_name': 'createMapping', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /ldapgroup/{ldapGpName}/{agilityGpName} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapgroup_ldapGpName', 'kind': 'xs:string', 'required': True, 'name': 'ldapGpName'}, {'defaultValue': None, 'alias': 'agilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'agilityGpName'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateMapping(self,
                      ldapgroup_id,
                      newAgilityGpName=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /ldapgroup/{id}/{newAgilityGpName} ]

        @param ldapgroup_id: ldapgroup_id
        @type ldapgroup_id: str
        @param newAgilityGpName: newAgilityGpName
        @type newAgilityGpName: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(id)s/%(newAgilityGpName)s"
        path_params = {"id": ldapgroup_id,
                       "newAgilityGpName": newAgilityGpName}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapgroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'newAgilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'newAgilityGpName'}], 'method_path': 'ldapgroup/%(id)s/%(newAgilityGpName)s', 'form_params': [], 'method_name': 'updateMapping', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /ldapgroup/{id}/{newAgilityGpName} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapgroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'newAgilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'newAgilityGpName'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getMapping(self,
                   ldapgroup_id=None,
                   **kwargs):
        """
        [ HTTP: GET /ldapgroup/{id} ]

        @param ldapgroup_id: ldapgroup_id
        @type ldapgroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(id)s"
        path_params = {"id": ldapgroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapgroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'ldapgroup/%(id)s', 'form_params': [], 'method_name': 'getMapping', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /ldapgroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapgroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class addressrange:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deleteAddressRange(self,
                           addressrange_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /addressrange/{id} ]

        @param addressrange_id: addressrange_id
        @type addressrange_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "addressrange/%(id)s"
        path_params = {"id": addressrange_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAddressRange.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'addressrange_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'addressrange/%(id)s', 'form_params': [], 'method_name': 'deleteAddressRange', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /addressrange/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'addressrange_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAddressRange(self,
                        addressrange_id=None,
                        **kwargs):
        """
        [ HTTP: GET /addressrange/{id} ]

        @param addressrange_id: addressrange_id
        @type addressrange_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "addressrange/%(id)s"
        path_params = {"id": addressrange_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAddressRange.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'addressrange_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'addressrange/%(id)s', 'form_params': [], 'method_name': 'getAddressRange', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /addressrange/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'addressrange_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class solution:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateArtifactOrder(self,
                            solution_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /solution/{id}/saveorder/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/saveorder/artifact"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateArtifactOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/saveorder/artifact', 'form_params': [], 'method_name': 'updateArtifactOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solution/{id}/saveorder/artifact ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createDeploymentVersionedArtifacts(self,
                                           solution_id,
                                           data=None,
                                           **kwargs):
        """
        [ HTTP: POST /solution/{id}/deployment/version ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/deployment/version"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createDeploymentVersionedArtifacts.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/deployment/version', 'form_params': [], 'method_name': 'createDeploymentVersionedArtifacts', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /solution/{id}/deployment/version ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSolutions(self,
                     includeEnvironments=None,
                     orderDeployments=None,
                     **kwargs):
        """
        [ HTTP: GET /solution ]

        @param includeEnvironments: includeEnvironments
        @type includeEnvironments: str
        @param orderDeployments: orderDeployments
        @type orderDeployments: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"includeEnvironments": includeEnvironments,
                        "orderDeployments": orderDeployments}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSolutions.context = {'query_params': [{'defaultValue': None, 'alias': 'includeEnvironments', 'kind': 'xs:string', 'required': False, 'name': 'includeEnvironments'}, {'defaultValue': None, 'alias': 'orderDeployments', 'kind': 'xs:string', 'required': False, 'name': 'orderDeployments'}], 'hasFiles': False, 'path_params': [], 'method_path': 'solution', 'form_params': [], 'method_name': 'getSolutions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution ]', 'method_params': [{'defaultValue': None, 'alias': 'includeEnvironments', 'kind': 'xs:string', 'required': False, 'name': 'includeEnvironments'}, {'defaultValue': None, 'alias': 'orderDeployments', 'kind': 'xs:string', 'required': False, 'name': 'orderDeployments'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchSolutions(self,
                        **kwargs):
        """
        [ HTTP: GET /solution/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchSolutions.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'solution/search', 'form_params': [], 'method_name': 'searchSolutions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSolution(self,
                       solution_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /solution/{id} ]

        @param solution_id: solution_id
        @type solution_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSolution.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'solution/%(id)s', 'form_params': [], 'method_name': 'deleteSolution', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /solution/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployments(self,
                       solution_id,
                       ready=None,
                       **kwargs):
        """
        [ HTTP: GET /solution/{id}/deployment ]

        @param solution_id: solution_id
        @type solution_id: str
        @param ready: ready
        @type ready: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/deployment"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"ready": ready}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployments.context = {'query_params': [{'defaultValue': None, 'alias': 'ready', 'kind': 'xs:string', 'required': False, 'name': 'ready'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/deployment', 'form_params': [], 'method_name': 'getDeployments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/{id}/deployment ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'ready', 'kind': 'xs:string', 'required': False, 'name': 'ready'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateSolution(self,
                       solution_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /solution/{id} ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateSolution.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'solution/%(id)s', 'form_params': [], 'method_name': 'updateSolution', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solution/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createArtifactFixedOrder(self,
                                 solution_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /solution/{id}/fixedorder/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/fixedorder/artifact"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createArtifactFixedOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/fixedorder/artifact', 'form_params': [], 'method_name': 'createArtifactFixedOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /solution/{id}/fixedorder/artifact ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSolution(self,
                    solution_id=None,
                    orderDeployments=None,
                    **kwargs):
        """
        [ HTTP: GET /solution/{id} ]

        @param solution_id: solution_id
        @type solution_id: str
        @param orderDeployments: orderDeployments
        @type orderDeployments: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"orderDeployments": orderDeployments}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSolution.context = {'query_params': [{'defaultValue': None, 'alias': 'orderDeployments', 'kind': 'xs:string', 'required': False, 'name': 'orderDeployments'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'solution/%(id)s', 'form_params': [], 'method_name': 'getSolution', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'orderDeployments', 'kind': 'xs:string', 'required': False, 'name': 'orderDeployments'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createArtifact(self,
                       solution_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /solution/{id}/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/artifact"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/artifact', 'form_params': [], 'method_name': 'createArtifact', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /solution/{id}/artifact ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createDeployment(self,
                         solution_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /solution/{id}/deployment ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/deployment"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createDeployment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/deployment', 'form_params': [], 'method_name': 'createDeployment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /solution/{id}/deployment ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     solution_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /solution/{id}/export ]

        @param solution_id: solution_id
        @type solution_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/export"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifacts(self,
                     solution_id,
                     version=None,
                     **kwargs):
        """
        [ HTTP: GET /solution/{id}/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/artifact"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifacts.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/artifact', 'form_params': [], 'method_name': 'getArtifacts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/{id}/artifact ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /solution/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'solution/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchArtifacts(self,
                        solution_id,
                        **kwargs):
        """
        [ HTTP: GET /solution/{id}/artifact/search ]

        @param solution_id: solution_id
        @type solution_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/artifact/search"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchArtifacts.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/artifact/search', 'form_params': [], 'method_name': 'searchArtifacts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solution/{id}/artifact/search ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createArtifactAnyOrder(self,
                               solution_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /solution/{id}/anyorder/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/anyorder/artifact"
        path_params = {"id": solution_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createArtifactAnyOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solution/%(id)s/anyorder/artifact', 'form_params': [], 'method_name': 'createArtifactAnyOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /solution/{id}/anyorder/artifact ]', 'method_params': [{'defaultValue': None, 'alias': 'solution_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class auth:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deleteAuthentication(self,
                             auth_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /auth/{id} ]

        @param auth_id: auth_id
        @type auth_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/%(id)s"
        path_params = {"id": auth_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAuthentication.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'auth_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'auth/%(id)s', 'form_params': [], 'method_name': 'deleteAuthentication', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /auth/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'auth_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchAuthentication(self,
                             **kwargs):
        """
        [ HTTP: GET /auth/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchAuthentication.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'auth/search', 'form_params': [], 'method_name': 'searchAuthentication', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /auth/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAuthentication(self,
                          auth_id=None,
                          **kwargs):
        """
        [ HTTP: GET /auth/{id} ]

        @param auth_id: auth_id
        @type auth_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/%(id)s"
        path_params = {"id": auth_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAuthentication.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'auth_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'auth/%(id)s', 'form_params': [], 'method_name': 'getAuthentication', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /auth/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'auth_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAuthentication(self,
                             auth_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /auth/{id} ]

        @param auth_id: auth_id
        @type auth_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/%(id)s"
        path_params = {"id": auth_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAuthentication.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'auth_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'auth/%(id)s', 'form_params': [], 'method_name': 'updateAuthentication', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /auth/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'auth_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAuthentication(self,
                             id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /auth ]

        @param id: id
        @type id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth"
        path_params = {"id": id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAuthentication.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'auth', 'form_params': [], 'method_name': 'createAuthentication', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /auth ]', 'method_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAuthenticationCurrent(self,
                                    data=None,
                                    **kwargs):
        """
        [ HTTP: PUT /auth/current ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/current"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAuthenticationCurrent.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'auth/current', 'form_params': [], 'method_name': 'updateAuthenticationCurrent', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /auth/current ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAuthentications(self,
                           id,
                           **kwargs):
        """
        [ HTTP: GET /auth ]

        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth"
        path_params = {"id": id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAuthentications.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'auth', 'form_params': [], 'method_name': 'getAuthentications', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /auth ]', 'method_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAuthenticationCurrent(self,
                                    **kwargs):
        """
        [ HTTP: DELETE /auth/current ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/current"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAuthenticationCurrent.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'auth/current', 'form_params': [], 'method_name': 'deleteAuthenticationCurrent', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /auth/current ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAuthenticationCurrent(self,
                                 **kwargs):
        """
        [ HTTP: GET /auth/current ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/current"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAuthenticationCurrent.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'auth/current', 'form_params': [], 'method_name': 'getAuthenticationCurrent', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /auth/current ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class scriptlanguage:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getScriptLanguage(self,
                          scriptlanguage_id=None,
                          **kwargs):
        """
        [ HTTP: GET /scriptlanguage/{id} ]

        @param scriptlanguage_id: scriptlanguage_id
        @type scriptlanguage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/%(id)s"
        path_params = {"id": scriptlanguage_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptLanguage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptlanguage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptlanguage/%(id)s', 'form_params': [], 'method_name': 'getScriptLanguage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptlanguage/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptlanguage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptLanguagesXML(self,
                              **kwargs):
        """
        [ HTTP: GET /scriptlanguage ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptLanguagesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptlanguage', 'form_params': [], 'method_name': 'getScriptLanguagesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptlanguage ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateScriptLanguage(self,
                             scriptlanguage_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /scriptlanguage/{id} ]

        @param scriptlanguage_id: scriptlanguage_id
        @type scriptlanguage_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/%(id)s"
        path_params = {"id": scriptlanguage_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateScriptLanguage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptlanguage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptlanguage/%(id)s', 'form_params': [], 'method_name': 'updateScriptLanguage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /scriptlanguage/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptlanguage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteScriptLanguage(self,
                             scriptlanguage_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /scriptlanguage/{id} ]

        @param scriptlanguage_id: scriptlanguage_id
        @type scriptlanguage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/%(id)s"
        path_params = {"id": scriptlanguage_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteScriptLanguage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptlanguage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptlanguage/%(id)s', 'form_params': [], 'method_name': 'deleteScriptLanguage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /scriptlanguage/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptlanguage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createScriptLanguage(self,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /scriptlanguage ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createScriptLanguage.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptlanguage', 'form_params': [], 'method_name': 'createScriptLanguage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /scriptlanguage ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchScriptLanguages(self,
                              **kwargs):
        """
        [ HTTP: GET /scriptlanguage/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchScriptLanguages.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptlanguage/search', 'form_params': [], 'method_name': 'searchScriptLanguages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptlanguage/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class domain:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getDomain(self,
                  domain_id=None,
                  **kwargs):
        """
        [ HTTP: GET /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDomain.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'domain/%(id)s', 'form_params': [], 'method_name': 'getDomain', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createUserXML(self,
                      domain_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /domain/{id}/user ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/user"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createUserXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/user', 'form_params': [], 'method_name': 'createUserXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /domain/{id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getUsersXML(self,
                    domain_id,
                    **kwargs):
        """
        [ HTTP: GET /domain/{id}/user ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/user"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getUsersXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/user', 'form_params': [], 'method_name': 'getUsersXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createRoleXML(self,
                      domain_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /domain/{id}/projectrole ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/projectrole"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createRoleXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/projectrole', 'form_params': [], 'method_name': 'createRoleXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /domain/{id}/projectrole ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDomainsXML(self,
                      **kwargs):
        """
        [ HTTP: GET /domain ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDomainsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'domain', 'form_params': [], 'method_name': 'getDomainsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRolesXML(self,
                    domain_id,
                    **kwargs):
        """
        [ HTTP: GET /domain/{id}/projectrole ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/projectrole"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRolesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/projectrole', 'form_params': [], 'method_name': 'getRolesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id}/projectrole ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     domain_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /domain/{id}/export ]

        @param domain_id: domain_id
        @type domain_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/export"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDomain(self,
                     domain_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDomain.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'domain/%(id)s', 'form_params': [], 'method_name': 'deleteDomain', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /domain/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /domain/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'domain/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createDomainXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /domain ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createDomainXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'domain', 'form_params': [], 'method_name': 'createDomainXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /domain ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateDomain(self,
                     domain_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateDomain.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'domain/%(id)s', 'form_params': [], 'method_name': 'updateDomain', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /domain/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class resources:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getCategoriesXML(self,
                         **kwargs):
        """
        [ HTTP: GET /resources ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "resources"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCategoriesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'resources', 'form_params': [], 'method_name': 'getCategoriesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /resources ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class tree:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getTreeProjects(self,
                        **kwargs):
        """
        [ HTTP: GET /tree/project ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "tree/project"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTreeProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'tree/project', 'form_params': [], 'method_name': 'getTreeProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /tree/project ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDesignTreeNode(self,
                          design_type,
                          id=None,
                          **kwargs):
        """
        [ HTTP: GET /tree/design/{type}/{id} ]

        @param design_type: design_type
        @type design_type: str
        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "tree/design/%(type)s/%(id)s"
        path_params = {"type": design_type,
                       "id": id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDesignTreeNode.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'design_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'tree/design/%(type)s/%(id)s', 'form_params': [], 'method_name': 'getDesignTreeNode', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /tree/design/{type}/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'design_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class servicebindingtype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getType(self,
                servicebindingtype_id=None,
                **kwargs):
        """
        [ HTTP: GET /servicebindingtype/{id} ]

        @param servicebindingtype_id: servicebindingtype_id
        @type servicebindingtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "servicebindingtype/%(id)s"
        path_params = {"id": servicebindingtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'servicebindingtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'servicebindingtype/%(id)s', 'form_params': [], 'method_name': 'getType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /servicebindingtype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'servicebindingtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class runtime:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getRuntimes(self,
                    **kwargs):
        """
        [ HTTP: GET /runtime ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRuntimes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'runtime', 'form_params': [], 'method_name': 'getRuntimes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /runtime ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateRuntime(self,
                      runtime_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /runtime/{id} ]

        @param runtime_id: runtime_id
        @type runtime_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/%(id)s"
        path_params = {"id": runtime_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateRuntime.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'runtime_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'runtime/%(id)s', 'form_params': [], 'method_name': 'updateRuntime', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /runtime/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'runtime_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRuntime(self,
                   runtime_id=None,
                   **kwargs):
        """
        [ HTTP: GET /runtime/{id} ]

        @param runtime_id: runtime_id
        @type runtime_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/%(id)s"
        path_params = {"id": runtime_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRuntime.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'runtime_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'runtime/%(id)s', 'form_params': [], 'method_name': 'getRuntime', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /runtime/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'runtime_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteRuntime(self,
                      runtime_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /runtime/{id} ]

        @param runtime_id: runtime_id
        @type runtime_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/%(id)s"
        path_params = {"id": runtime_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteRuntime.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'runtime_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'runtime/%(id)s', 'form_params': [], 'method_name': 'deleteRuntime', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /runtime/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'runtime_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchRuntimes(self,
                       **kwargs):
        """
        [ HTTP: GET /runtime/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchRuntimes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'runtime/search', 'form_params': [], 'method_name': 'searchRuntimes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /runtime/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class environment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importIDActionXML(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /environment/{id}/import ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/import"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSecurity(self,
                    environment_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/security/{security_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getBlueprints(self,
                      environment_id,
                      **kwargs):
        """
        [ HTTP: GET /environment/{id}/blueprint ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/blueprint"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getBlueprints.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/blueprint', 'form_params': [], 'method_name': 'getBlueprints', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/blueprint ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removePolicy(self,
                     environment_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/policy/{policyid} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy/%(policyid)s"
        path_params = {"id": environment_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'environment/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicyAssignments(self,
                                environment_id,
                                **kwargs):
        """
        [ HTTP: GET /environment/{id}/policyassignment/search ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policyassignment/search"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAlias(self,
                    environment_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTopologyFixedOrder(self,
                                 environment_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /environment/{id}/fixedorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/fixedorder/topology"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTopologyFixedOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/fixedorder/topology', 'form_params': [], 'method_name': 'createTopologyFixedOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/fixedorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMultiVariable(self,
                            environment_env_id,
                            variable_vname=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /environment/{env_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"env_id": environment_env_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMultiVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'environment/%(env_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'createMultiVariable', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{env_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     environment_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /environment/{id}/export ]

        @param environment_id: environment_id
        @type environment_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/export"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def rebootEnvironment(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/restart ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/restart"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    rebootEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/restart', 'form_params': [], 'method_name': 'rebootEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariableXML(self,
                       environment_env_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{env_id}/variable/{variable_id: [0-9]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariableXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(env_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'getVariableXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{env_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRuntimes(self,
                    environment_id,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/runtime ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/runtime"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRuntimes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/runtime', 'form_params': [], 'method_name': 'getRuntimes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/runtime ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createScript(self,
                     environment_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /environment/{id}/script ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/script"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/script', 'form_params': [], 'method_name': 'createScript', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAlias(self,
                    environment_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /environment/{id}/alias ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/alias', 'form_params': [], 'method_name': 'createAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateVariable(self,
                       environment_env_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /environment/{env_id}/variable/{variable_id: [0-9]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(env_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{env_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEnvironmentsXML(self,
                           **kwargs):
        """
        [ HTTP: GET /environment ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEnvironmentsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environment', 'form_params': [], 'method_name': 'getEnvironmentsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVariable(self,
                       environment_env_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /environment/{env_id}/variable/{variable_id: [0-9]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(env_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{env_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def cloneEnvironment(self,
                         environment_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /environment/{id}/clone ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/clone"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    cloneEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/clone', 'form_params': [], 'method_name': 'cloneEnvironment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTemplateAny(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/anyorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/anyorder/template"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTemplateAny.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/anyorder/template', 'form_params': [], 'method_name': 'createTemplateAny', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/anyorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUserGroup(self,
                                environment_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachPolicy(self,
                     environment_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /environment/{id}/policy/{policyid} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy/%(policyid)s"
        path_params = {"id": environment_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'environment/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createVariable(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/variable ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTemplatesXML(self,
                        environment_id,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/template"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTemplatesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/template', 'form_params': [], 'method_name': 'getTemplatesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurity(self,
                    environment_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /environment/{id}/security ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTopology(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/topology"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/topology', 'form_params': [], 'method_name': 'createTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def releaseEnvironment(self,
                           environment_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /environment/{id}/release ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/release"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    releaseEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/release', 'form_params': [], 'method_name': 'releaseEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityRights(self,
                             environment_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUser(self,
                           environment_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/user/{user_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "user_id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteEnvironment(self,
                          environment_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environment/%(id)s', 'form_params': [], 'method_name': 'deleteEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTopologyAnyOrder(self,
                               environment_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /environment/{id}/anyorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/anyorder/topology"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTopologyAnyOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/anyorder/topology', 'form_params': [], 'method_name': 'createTopologyAnyOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/anyorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurity(self,
                       environment_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUserGroup(self,
                             environment_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/usergroup ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": environment_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTemplate(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/template"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/template', 'form_params': [], 'method_name': 'createTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariablesByName(self,
                           environment_env_id,
                           variable_vname=None,
                           **kwargs):
        """
        [ HTTP: GET /environment/{env_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"env_id": environment_env_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariablesByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'environment/%(env_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'getVariablesByName', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{env_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchEnvironments(self,
                           **kwargs):
        """
        [ HTTP: GET /environment/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchEnvironments.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environment/search', 'form_params': [], 'method_name': 'searchEnvironments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployments(self,
                       environment_id,
                       ready=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{id}/solutiondeployment ]

        @param environment_id: environment_id
        @type environment_id: str
        @param ready: ready
        @type ready: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/solutiondeployment"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"ready": ready}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployments.context = {'query_params': [{'defaultValue': None, 'alias': 'ready', 'kind': 'xs:string', 'required': False, 'name': 'ready'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/solutiondeployment', 'form_params': [], 'method_name': 'getDeployments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/solutiondeployment ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'ready', 'kind': 'xs:string', 'required': False, 'name': 'ready'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def startEnvironment(self,
                         environment_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /environment/{id}/start ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/start"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    startEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/start', 'form_params': [], 'method_name': 'startEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAlias(self,
                 environment_id,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityRights(self,
                          environment_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/rights ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": environment_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def upateEnvironment(self,
                         environment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    upateEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environment/%(id)s', 'form_params': [], 'method_name': 'upateEnvironment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createBlueprint(self,
                        environment_id,
                        force=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/blueprint ]

        @param environment_id: environment_id
        @type environment_id: str
        @param force: force
        @type force: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/blueprint"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"force": force}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createBlueprint.context = {'query_params': [{'defaultValue': None, 'alias': 'force', 'kind': 'xs:boolean', 'required': False, 'name': 'force'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/blueprint', 'form_params': [], 'method_name': 'createBlueprint', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/blueprint ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'force', 'kind': 'xs:boolean', 'required': False, 'name': 'force'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /environment/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [], 'method_path': 'environment/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/export ]', 'method_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEnvironment(self,
                       environment_id=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environment/%(id)s', 'form_params': [], 'method_name': 'getEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTopologyManualOrder(self,
                                  environment_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /environment/{id}/manualorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/manualorder/topology"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTopologyManualOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/manualorder/topology', 'form_params': [], 'method_name': 'createTopologyManualOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/manualorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityAccessRight(self,
                               environment_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTemplateManual(self,
                             environment_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /environment/{id}/manualorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/manualorder/template"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTemplateManual.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/manualorder/template', 'form_params': [], 'method_name': 'createTemplateManual', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/manualorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createRuntime(self,
                      environment_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /environment/{id}/runtime ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/runtime"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createRuntime.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/runtime', 'form_params': [], 'method_name': 'createRuntime', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/runtime ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPackage(self,
                      environment_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /environment/{id}/package ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/package"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/package', 'form_params': [], 'method_name': 'createPackage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAlias(self,
                    environment_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTemplateFixed(self,
                            environment_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /environment/{id}/fixedorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/fixedorder/template"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTemplateFixed.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/fixedorder/template', 'form_params': [], 'method_name': 'createTemplateFixed', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/fixedorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPackages(self,
                    environment_id,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/package ]

        @param environment_id: environment_id
        @type environment_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/package"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPackages.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTopologiesXML(self,
                         environment_id,
                         **kwargs):
        """
        [ HTTP: GET /environment/{id}/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/topology"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTopologiesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/topology', 'form_params': [], 'method_name': 'getTopologiesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScripts(self,
                   environment_id,
                   version=None,
                   **kwargs):
        """
        [ HTTP: GET /environment/{id}/script ]

        @param environment_id: environment_id
        @type environment_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/script"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScripts.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/script', 'form_params': [], 'method_name': 'getScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicies(self,
                    environment_id,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/policy ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityAccessRight(self,
                                  environment_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUser(self,
                        environment_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/user ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/user"
        path_params = {"id": environment_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDAction(self,
                       environment_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /environment/{id}/import ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/import"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stopEnvironment(self,
                        environment_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/stop ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/stop"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stopEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/stop', 'form_params': [], 'method_name': 'stopEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariablesXML(self,
                        environment_id,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/variable ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariablesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/variable', 'form_params': [], 'method_name': 'getVariablesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAliases(self,
                   environment_id,
                   **kwargs):
        """
        [ HTTP: GET /environment/{id}/alias ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias"
        path_params = {"id": environment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAliases.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/alias', 'form_params': [], 'method_name': 'getAliases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class launchitemdeployment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getDeployment(self,
                      launchitemdeployment_id=None,
                      **kwargs):
        """
        [ HTTP: GET /launchitemdeployment/{id} ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s"
        path_params = {"id": launchitemdeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'launchitemdeployment/%(id)s', 'form_params': [], 'method_name': 'getDeployment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitemdeployment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployments(self,
                       **kwargs):
        """
        [ HTTP: GET /launchitemdeployment ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployments.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'launchitemdeployment', 'form_params': [], 'method_name': 'getDeployments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitemdeployment ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchDeployments(self,
                          **kwargs):
        """
        [ HTTP: GET /launchitemdeployment/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchDeployments.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'launchitemdeployment/search', 'form_params': [], 'method_name': 'searchDeployments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /launchitemdeployment/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                launchitemdeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /launchitemdeployment/{id}/approve ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s/approve"
        path_params = {"id": launchitemdeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitemdeployment/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /launchitemdeployment/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               launchitemdeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /launchitemdeployment/{id}/reject ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s/reject"
        path_params = {"id": launchitemdeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'launchitemdeployment/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /launchitemdeployment/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDeployment(self,
                         launchitemdeployment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /launchitemdeployment/{id} ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s"
        path_params = {"id": launchitemdeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDeployment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'launchitemdeployment/%(id)s', 'form_params': [], 'method_name': 'deleteDeployment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /launchitemdeployment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'launchitemdeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class setup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /setup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'setup/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /setup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProperty(self,
                    setup_id,
                    property_propid=None,
                    **kwargs):
        """
        [ HTTP: GET /setup/{id}/property/{propid} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property/%(propid)s"
        path_params = {"id": setup_id,
                       "propid": property_propid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProperty.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}], 'method_path': 'setup/%(id)s/property/%(propid)s', 'form_params': [], 'method_name': 'getProperty', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /setup/{id}/property/{propid} ]', 'method_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def setPropertyXML(self,
                       setup_id,
                       property_propid=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /setup/{id}/property/{propid} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property/%(propid)s"
        path_params = {"id": setup_id,
                       "propid": property_propid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setPropertyXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}], 'method_path': 'setup/%(id)s/property/%(propid)s', 'form_params': [], 'method_name': 'setPropertyXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /setup/{id}/property/{propid} ]', 'method_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getConfiguation(self,
                        setup_id=None,
                        **kwargs):
        """
        [ HTTP: GET /setup/{id} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s"
        path_params = {"id": setup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getConfiguation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'setup/%(id)s', 'form_params': [], 'method_name': 'getConfiguation', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /setup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     setup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /setup/{id}/export ]

        @param setup_id: setup_id
        @type setup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/export"
        path_params = {"id": setup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'setup/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /setup/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /setup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'setup/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /setup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getConfigurations(self,
                          **kwargs):
        """
        [ HTTP: GET /setup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getConfigurations.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'setup', 'form_params': [], 'method_name': 'getConfigurations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /setup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProperties(self,
                      setup_id,
                      **kwargs):
        """
        [ HTTP: GET /setup/{id}/property ]

        @param setup_id: setup_id
        @type setup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property"
        path_params = {"id": setup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProperties.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'setup/%(id)s/property', 'form_params': [], 'method_name': 'getProperties', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /setup/{id}/property ]', 'method_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def setProperty(self,
                    setup_id,
                    property_propid=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /setup/{id}/property/{propid} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property/%(propid)s"
        path_params = {"id": setup_id,
                       "propid": property_propid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setProperty.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}], 'method_path': 'setup/%(id)s/property/%(propid)s', 'form_params': [], 'method_name': 'setProperty', 'custom_headers': {'Content-Type': 'application/x-www-form-urlencoded'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /setup/{id}/property/{propid} ]', 'method_params': [{'defaultValue': None, 'alias': 'setup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /setup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'setup/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /setup/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class paas:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deletePlatformService(self,
                              paas_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /paas/{id} ]

        @param paas_id: paas_id
        @type paas_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s"
        path_params = {"id": paas_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletePlatformService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'paas/%(id)s', 'form_params': [], 'method_name': 'deletePlatformService', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /paas/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPlatformService(self,
                              id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /paas ]

        @param id: id
        @type id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas"
        path_params = {"id": id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPlatformService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'paas', 'form_params': [], 'method_name': 'createPlatformService', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /paas ]', 'method_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPlatformServices(self,
                            id,
                            **kwargs):
        """
        [ HTTP: GET /paas ]

        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas"
        path_params = {"id": id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPlatformServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'paas', 'form_params': [], 'method_name': 'getPlatformServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paas ]', 'method_params': [{'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPlatformService(self,
                           paas_id=None,
                           **kwargs):
        """
        [ HTTP: GET /paas/{id} ]

        @param paas_id: paas_id
        @type paas_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s"
        path_params = {"id": paas_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPlatformService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'paas/%(id)s', 'form_params': [], 'method_name': 'getPlatformService', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paas/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifactTypes(self,
                         paas_id,
                         **kwargs):
        """
        [ HTTP: GET /paas/{id}/artifacttype ]

        @param paas_id: paas_id
        @type paas_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s/artifacttype"
        path_params = {"id": paas_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifactTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'paas/%(id)s/artifacttype', 'form_params': [], 'method_name': 'getArtifactTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paas/{id}/artifacttype ]', 'method_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPlatformServices(self,
                               **kwargs):
        """
        [ HTTP: GET /paas/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPlatformServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'paas/search', 'form_params': [], 'method_name': 'searchPlatformServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paas/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updatePlatformService(self,
                              paas_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /paas/{id} ]

        @param paas_id: paas_id
        @type paas_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s"
        path_params = {"id": paas_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updatePlatformService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'paas/%(id)s', 'form_params': [], 'method_name': 'updatePlatformService', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /paas/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'paas_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storecatalog:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getAuthorizedUsers(self,
                           storecatalog_id,
                           **kwargs):
        """
        [ HTTP: GET /storecatalog/{id}/security ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/security"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAuthorizedUsers.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s/security', 'form_params': [], 'method_name': 'getAuthorizedUsers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def setProductsList(self,
                        storecatalog_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /storecatalog/{id}/products ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/products"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setProductsList.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s/products', 'form_params': [], 'method_name': 'setProductsList', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storecatalog/{id}/products ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createCatalog(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /storecatalog ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createCatalog.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecatalog', 'form_params': [], 'method_name': 'createCatalog', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storecatalog ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCatalogs(self,
                    **kwargs):
        """
        [ HTTP: GET /storecatalog ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCatalogs.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecatalog', 'form_params': [], 'method_name': 'getCatalogs', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCatalogs(self,
                       **kwargs):
        """
        [ HTTP: GET /storecatalog/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCatalogs.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecatalog/search', 'form_params': [], 'method_name': 'searchCatalogs', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def setAuthorizedUsers(self,
                           storecatalog_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /storecatalog/{id}/security ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/security"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setAuthorizedUsers.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s/security', 'form_params': [], 'method_name': 'setAuthorizedUsers', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storecatalog/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProductsList(self,
                        storecatalog_id,
                        **kwargs):
        """
        [ HTTP: GET /storecatalog/{id}/products ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/products"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProductsList.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s/products', 'form_params': [], 'method_name': 'getProductsList', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog/{id}/products ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     storecatalog_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storecatalog/{id}/export ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/export"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCatalog(self,
                      storecatalog_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /storecatalog/{id} ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCatalog.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s', 'form_params': [], 'method_name': 'updateCatalog', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storecatalog/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storecatalog/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecatalog/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCatalog(self,
                   storecatalog_id=None,
                   **kwargs):
        """
        [ HTTP: GET /storecatalog/{id} ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCatalog.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s', 'form_params': [], 'method_name': 'getCatalog', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecatalog/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteCatalog(self,
                      storecatalog_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /storecatalog/{id} ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s"
        path_params = {"id": storecatalog_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteCatalog.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storecatalog/%(id)s', 'form_params': [], 'method_name': 'deleteCatalog', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /storecatalog/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storecatalog_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class os:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def createOperatingSystem(self,
                              os_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /os/{id}/child ]

        @param os_id: os_id
        @type os_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s/child"
        path_params = {"id": os_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'os/%(id)s/child', 'form_params': [], 'method_name': 'createOperatingSystem', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /os/{id}/child ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTaxonomy(self,
                    **kwargs):
        """
        [ HTTP: GET /os/taxonomy ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/taxonomy"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTaxonomy.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'os/taxonomy', 'form_params': [], 'method_name': 'getTaxonomy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os/taxonomy ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getOperatingSystems(self,
                            **kwargs):
        """
        [ HTTP: GET /os ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getOperatingSystems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'os', 'form_params': [], 'method_name': 'getOperatingSystems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchOperatingSystems(self,
                               **kwargs):
        """
        [ HTTP: GET /os/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchOperatingSystems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'os/search', 'form_params': [], 'method_name': 'searchOperatingSystems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteOperatingSystem(self,
                              os_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'os/%(id)s', 'form_params': [], 'method_name': 'deleteOperatingSystem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /os/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getOperatingSystem(self,
                           os_id=None,
                           **kwargs):
        """
        [ HTTP: GET /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'os/%(id)s', 'form_params': [], 'method_name': 'getOperatingSystem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateOperatingSystem(self,
                              os_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'os/%(id)s', 'form_params': [], 'method_name': 'updateOperatingSystem', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /os/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class configuration_policy:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def evaluate(self,
                 policy_artifacttype,
                 hostname=None,
                 **kwargs):
        """
        [ HTTP: GET /configuration/policy/{artifacttype}/{hostname} ]

        @param policy_artifacttype: policy_artifacttype
        @type policy_artifacttype: str
        @param hostname: hostname
        @type hostname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/policy/%(artifacttype)s/%(hostname)s"
        path_params = {"artifacttype": policy_artifacttype,
                       "hostname": hostname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    evaluate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_artifacttype', 'kind': 'xs:string', 'required': True, 'name': 'artifacttype'}, {'defaultValue': None, 'alias': 'hostname', 'kind': 'xs:string', 'required': False, 'name': 'hostname'}], 'method_path': 'configuration/policy/%(artifacttype)s/%(hostname)s', 'form_params': [], 'method_name': 'evaluate', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/policy/{artifacttype}/{hostname} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_artifacttype', 'kind': 'xs:string', 'required': True, 'name': 'artifacttype'}, {'defaultValue': None, 'alias': 'hostname', 'kind': 'xs:string', 'required': False, 'name': 'hostname'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class user:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateUser(self,
                   user_id=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'user/%(id)s', 'form_params': [], 'method_name': 'updateUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /user/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /user/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'user/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /user/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteUser(self,
                   user_id=None,
                   **kwargs):
        """
        [ HTTP: DELETE /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'user/%(id)s', 'form_params': [], 'method_name': 'deleteUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /user/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addUser(self,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /user ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user', 'form_params': [], 'method_name': 'addUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /user ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchUsers(self,
                    **kwargs):
        """
        [ HTTP: GET /user/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchUsers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user/search', 'form_params': [], 'method_name': 'searchUsers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getUsersXML(self,
                    **kwargs):
        """
        [ HTTP: GET /user ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getUsersXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user', 'form_params': [], 'method_name': 'getUsersXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getUser(self,
                user_id=None,
                **kwargs):
        """
        [ HTTP: GET /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'user/%(id)s', 'form_params': [], 'method_name': 'getUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /user/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /user/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     user_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /user/{id}/export ]

        @param user_id: user_id
        @type user_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s/export"
        path_params = {"id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'user/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /user/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class volumestoragesnapshot:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getVolumeStorageSnapshot(self,
                                 volumestoragesnapshot_id=None,
                                 **kwargs):
        """
        [ HTTP: GET /volumestoragesnapshot/{id} ]

        @param volumestoragesnapshot_id: volumestoragesnapshot_id
        @type volumestoragesnapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestoragesnapshot/%(id)s"
        path_params = {"id": volumestoragesnapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolumeStorageSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volumestoragesnapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'volumestoragesnapshot/%(id)s', 'form_params': [], 'method_name': 'getVolumeStorageSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volumestoragesnapshot/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volumestoragesnapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVolumeStorageSnapshotSnapshotXML(self,
                                            **kwargs):
        """
        [ HTTP: GET /volumestoragesnapshot ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestoragesnapshot"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolumeStorageSnapshotSnapshotXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'volumestoragesnapshot', 'form_params': [], 'method_name': 'getVolumeStorageSnapshotSnapshotXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volumestoragesnapshot ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class solutiondeployment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def setDeploymentReady(self,
                           solutiondeployment_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/setready ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/setready"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setDeploymentReady.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/setready', 'form_params': [], 'method_name': 'setDeploymentReady', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/setready ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSolutionDeployments(self,
                               ready=None,
                               **kwargs):
        """
        [ HTTP: GET /solutiondeployment ]

        @param ready: ready
        @type ready: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"ready": ready}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSolutionDeployments.context = {'query_params': [{'defaultValue': None, 'alias': 'ready', 'kind': 'xs:string', 'required': False, 'name': 'ready'}], 'hasFiles': False, 'path_params': [], 'method_path': 'solutiondeployment', 'form_params': [], 'method_name': 'getSolutionDeployments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solutiondeployment ]', 'method_params': [{'defaultValue': None, 'alias': 'ready', 'kind': 'xs:string', 'required': False, 'name': 'ready'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateSolutionDeployment(self,
                                 solutiondeployment_id=None,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateSolutionDeployment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s', 'form_params': [], 'method_name': 'updateSolutionDeployment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSolutionDeployment(self,
                                 solutiondeployment_id=None,
                                 **kwargs):
        """
        [ HTTP: DELETE /solutiondeployment/{id} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSolutionDeployment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s', 'form_params': [], 'method_name': 'deleteSolutionDeployment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /solutiondeployment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deploy(self,
               solutiondeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/deploy ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/deploy"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deploy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/deploy', 'form_params': [], 'method_name': 'deploy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/deploy ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSolutionDeployment(self,
                              solutiondeployment_id=None,
                              **kwargs):
        """
        [ HTTP: GET /solutiondeployment/{id} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSolutionDeployment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s', 'form_params': [], 'method_name': 'getSolutionDeployment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solutiondeployment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stop(self,
             solutiondeployment_id,
             data=None,
             **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/stop ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/stop"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stop.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/stop', 'form_params': [], 'method_name': 'stop', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def submit(self,
               solutiondeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/submit ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/submit"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    submit.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/submit', 'form_params': [], 'method_name': 'submit', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/submit ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def start(self,
              solutiondeployment_id,
              data=None,
              **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/start ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/start"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    start.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/start', 'form_params': [], 'method_name': 'start', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateName(self,
                   solutiondeployment_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/name ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/name"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/name', 'form_params': [], 'method_name': 'updateName', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/name ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               solutiondeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/reject ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/reject"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def release(self,
                solutiondeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/release ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/release"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    release.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/release', 'form_params': [], 'method_name': 'release', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchDeployments(self,
                          **kwargs):
        """
        [ HTTP: GET /solutiondeployment/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchDeployments.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'solutiondeployment/search', 'form_params': [], 'method_name': 'searchDeployments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /solutiondeployment/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def promote(self,
                solutiondeployment_id,
                promote_locationId=None,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/promote/{locationId} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param promote_locationId: promote_locationId
        @type promote_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/promote/%(locationId)s"
        path_params = {"id": solutiondeployment_id,
                       "locationId": promote_locationId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    promote.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'promote_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}], 'method_path': 'solutiondeployment/%(id)s/promote/%(locationId)s', 'form_params': [], 'method_name': 'promote', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/promote/{locationId} ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'promote_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                solutiondeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/approve ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/approve"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def restart(self,
                solutiondeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/restart ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/restart"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    restart.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/restart', 'form_params': [], 'method_name': 'restart', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def unsetDeploymentReady(self,
                             solutiondeployment_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/unsetready ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/unsetready"
        path_params = {"id": solutiondeployment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    unsetDeploymentReady.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'solutiondeployment/%(id)s/unsetready', 'form_params': [], 'method_name': 'unsetDeploymentReady', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/unsetready ]', 'method_params': [{'defaultValue': None, 'alias': 'solutiondeployment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class connection:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getConnection(self,
                      connection_id=None,
                      **kwargs):
        """
        [ HTTP: GET /connection/{id} ]

        @param connection_id: connection_id
        @type connection_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/%(id)s"
        path_params = {"id": connection_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getConnection.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'connection_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'connection/%(id)s', 'form_params': [], 'method_name': 'getConnection', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /connection/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'connection_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getConnectionsXML(self,
                          **kwargs):
        """
        [ HTTP: GET /connection ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getConnectionsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'connection', 'form_params': [], 'method_name': 'getConnectionsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /connection ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createConnection(self,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /connection ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createConnection.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'connection', 'form_params': [], 'method_name': 'createConnection', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /connection ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchConnections(self,
                          **kwargs):
        """
        [ HTTP: GET /connection/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchConnections.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'connection/search', 'form_params': [], 'method_name': 'searchConnections', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /connection/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteConnection(self,
                         connection_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /connection/{id} ]

        @param connection_id: connection_id
        @type connection_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/%(id)s"
        path_params = {"id": connection_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteConnection.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'connection_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'connection/%(id)s', 'form_params': [], 'method_name': 'deleteConnection', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /connection/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'connection_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class configuration_artifacttype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importArtifactType(self,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /configuration/artifacttype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importArtifactType.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifacttype/import', 'form_params': [], 'method_name': 'importArtifactType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifacttype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importArtifactTypes(self,
                            data=None,
                            files=None,
                            **kwargs):
        """
        [ HTTP: PUT /configuration/artifacttype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importArtifactTypes.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'configuration/artifacttype/import', 'form_params': [], 'method_name': 'importArtifactTypes', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifacttype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifactTypes(self,
                         **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifactTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifacttype', 'form_params': [], 'method_name': 'getArtifactTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifacttype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportArtifactType(self,
                           artifacttype_id,
                           recursive=None,
                           **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype/{id}/export ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/%(id)s/export"
        path_params = {"id": artifacttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportArtifactType.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/artifacttype/%(id)s/export', 'form_params': [], 'method_name': 'exportArtifactType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifacttype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifactType(self,
                        artifacttype_id=None,
                        **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifactType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/artifacttype/%(id)s', 'form_params': [], 'method_name': 'getArtifactType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifacttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllArtifactTypes(self,
                               **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllArtifactTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifacttype/export', 'form_params': [], 'method_name': 'exportAllArtifactTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifacttype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class designdeployer:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def searchDeployers(self,
                        **kwargs):
        """
        [ HTTP: GET /designdeployer/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchDeployers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'designdeployer/search', 'form_params': [], 'method_name': 'searchDeployers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /designdeployer/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDeployer(self,
                       designdeployer_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /designdeployer/{id} ]

        @param designdeployer_id: designdeployer_id
        @type designdeployer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/%(id)s"
        path_params = {"id": designdeployer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designdeployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'designdeployer/%(id)s', 'form_params': [], 'method_name': 'deleteDeployer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /designdeployer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'designdeployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployers(self,
                     **kwargs):
        """
        [ HTTP: GET /designdeployer ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'designdeployer', 'form_params': [], 'method_name': 'getDeployers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /designdeployer ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateDeployer(self,
                       designdeployer_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /designdeployer/{id} ]

        @param designdeployer_id: designdeployer_id
        @type designdeployer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/%(id)s"
        path_params = {"id": designdeployer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designdeployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'designdeployer/%(id)s', 'form_params': [], 'method_name': 'updateDeployer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /designdeployer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'designdeployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployer(self,
                    designdeployer_id=None,
                    **kwargs):
        """
        [ HTTP: GET /designdeployer/{id} ]

        @param designdeployer_id: designdeployer_id
        @type designdeployer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/%(id)s"
        path_params = {"id": designdeployer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designdeployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'designdeployer/%(id)s', 'form_params': [], 'method_name': 'getDeployer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /designdeployer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'designdeployer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class volumestorage:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deleteSnapshot(self,
                       volumestorage_id,
                       snapshot_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /volumestorage/{id}/snapshot/{snapshot_id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": volumestorage_id,
                       "snapshot_id": snapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'volumestorage/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'deleteSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /volumestorage/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVolumeStorage(self,
                         volumestorage_id=None,
                         **kwargs):
        """
        [ HTTP: GET /volumestorage/{id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s"
        path_params = {"id": volumestorage_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolumeStorage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'volumestorage/%(id)s', 'form_params': [], 'method_name': 'getVolumeStorage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volumestorage/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVolumeStoragesXML(self,
                             **kwargs):
        """
        [ HTTP: GET /volumestorage ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolumeStoragesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'volumestorage', 'form_params': [], 'method_name': 'getVolumeStoragesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volumestorage ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSnapshot(self,
                    volumestorage_id,
                    snapshot_id=None,
                    **kwargs):
        """
        [ HTTP: GET /volumestorage/{id}/snapshot/{snapshot_id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": volumestorage_id,
                       "snapshot_id": snapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'volumestorage/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'getSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volumestorage/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def revertSnapshot(self,
                       volumestorage_id,
                       snapshot_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /volumestorage/{id}/snapshot/{snapshot_id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": volumestorage_id,
                       "snapshot_id": snapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    revertSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'volumestorage/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'revertSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /volumestorage/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createSnapshot(self,
                       volumestorage_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /volumestorage/{id}/snapshot ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot"
        path_params = {"id": volumestorage_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'volumestorage/%(id)s/snapshot', 'form_params': [], 'method_name': 'createSnapshot', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /volumestorage/{id}/snapshot ]', 'method_params': [{'defaultValue': None, 'alias': 'volumestorage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class blueprint_designcontainer:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getDesignContainer(self,
                           blueprint_bp_id,
                           designcontainer_id=None,
                           **kwargs):
        """
        [ HTTP: GET /blueprint/{bp_id}/designcontainer/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": designcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(bp_id)s/designcontainer/%(id)s', 'form_params': [], 'method_name': 'getDesignContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /blueprint/{bp_id}/designcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateDesignContainer(self,
                              blueprint_bp_id,
                              designcontainer_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /blueprint/{bp_id}/designcontainer/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": designcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(bp_id)s/designcontainer/%(id)s', 'form_params': [], 'method_name': 'updateDesignContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /blueprint/{bp_id}/designcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createDesignContainer(self,
                              blueprint_bp_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /blueprint/{bp_id}/designcontainer ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer"
        path_params = {"bp_id": blueprint_bp_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}], 'method_path': 'blueprint/%(bp_id)s/designcontainer', 'form_params': [], 'method_name': 'createDesignContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /blueprint/{bp_id}/designcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDesignContainer(self,
                              blueprint_bp_id,
                              designcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /blueprint/{bp_id}/designcontainer/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": designcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'blueprint/%(bp_id)s/designcontainer/%(id)s', 'form_params': [], 'method_name': 'deleteDesignContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /blueprint/{bp_id}/designcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'blueprint_bp_id', 'kind': 'xs:int', 'required': True, 'name': 'bp_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class artifactattachment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getAttachmentMulti(self,
                           artifactattachment_id=None,
                           **kwargs):
        """
        [ HTTP: GET /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachmentMulti.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifactattachment/%(id)s', 'form_params': [], 'method_name': 'getAttachmentMulti', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifactattachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAttachment(self,
                         artifactattachment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifactattachment/%(id)s', 'form_params': [], 'method_name': 'updateAttachment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /artifactattachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAttachment(self,
                         artifactattachment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifactattachment/%(id)s', 'form_params': [], 'method_name': 'deleteAttachment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /artifactattachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAttachments(self,
                       **kwargs):
        """
        [ HTTP: GET /artifactattachment ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachments.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'artifactattachment', 'form_params': [], 'method_name': 'getAttachments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifactattachment ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAttachment(self,
                      artifactattachment_id=None,
                      **kwargs):
        """
        [ HTTP: GET /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifactattachment/%(id)s', 'form_params': [], 'method_name': 'getAttachment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifactattachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifactattachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class globals:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deleteSecurity(self,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id} ]

        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s"
        path_params = {"security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUserGroup(self,
                             security_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/usergroup ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/usergroup"
        path_params = {"security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importContainerRights(self,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: PUT /global/security/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importContainerRights.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'global/security/import', 'form_params': [], 'method_name': 'importContainerRights', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /global/security/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSecurity(self,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /global/security/{security_id} ]

        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s"
        path_params = {"security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /global/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUserGroup(self,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/usergroup/{usergroup_id} ]

        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"security_id": security_id,
                       "usergroup_id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'global/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUser(self,
                        security_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/user ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/user"
        path_params = {"security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportContainerRights(self,
                              security_id,
                              exportOpts=None,
                              **kwargs):
        """
        [ HTTP: GET /global/security/{security_id}/export ]

        @param security_id: security_id
        @type security_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/export"
        path_params = {"security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportContainerRights.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/export', 'form_params': [], 'method_name': 'exportContainerRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /global/security/{security_id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurity(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /global/security ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'global/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityAccessRight(self,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/rights/{rights_id}/accessright ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityAccessRight(self,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def clearStatsCache(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /global/cache/statsclear ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/cache/statsclear"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    clearStatsCache.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'global/cache/statsclear', 'form_params': [], 'method_name': 'clearStatsCache', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/cache/statsclear ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityRights(self,
                          security_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/rights ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights"
        path_params = {"security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getGlobalContainer(self,
                           **kwargs):
        """
        [ HTTP: GET /global/container ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/container"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getGlobalContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'global/container', 'form_params': [], 'method_name': 'getGlobalContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /global/container ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityRights(self,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/rights/{rights_id} ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUser(self,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/user/{user_id} ]

        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/user/%(user_id)s"
        path_params = {"security_id": security_id,
                       "user_id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'global/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storecategory:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getCategory(self,
                    storecategory_id=None,
                    **kwargs):
        """
        [ HTTP: GET /storecategory/{id} ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s"
        path_params = {"id": storecategory_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCategory.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storecategory/%(id)s', 'form_params': [], 'method_name': 'getCategory', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecategory/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteCategory(self,
                       storecategory_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /storecategory/{id} ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s"
        path_params = {"id": storecategory_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteCategory.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storecategory/%(id)s', 'form_params': [], 'method_name': 'deleteCategory', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /storecategory/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCategories(self,
                      **kwargs):
        """
        [ HTTP: GET /storecategory ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCategories.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecategory', 'form_params': [], 'method_name': 'getCategories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecategory ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCategory(self,
                       storecategory_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /storecategory/{id} ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s"
        path_params = {"id": storecategory_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCategory.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storecategory/%(id)s', 'form_params': [], 'method_name': 'updateCategory', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storecategory/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCatgories(self,
                        **kwargs):
        """
        [ HTTP: GET /storecategory/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCatgories.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecategory/search', 'form_params': [], 'method_name': 'searchCatgories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecategory/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     storecategory_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storecategory/{id}/export ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s/export"
        path_params = {"id": storecategory_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storecategory/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecategory/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'storecategory_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createCategory(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /storecategory ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createCategory.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecategory', 'form_params': [], 'method_name': 'createCategory', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storecategory ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storecategory/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storecategory/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storecategory/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class networkservicetype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateNetworkServiceType(self,
                                 networkservicetype_id=None,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: PUT /networkservicetype/{id: \d+} ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id: \d+)s"
        path_params = {"id": networkservicetype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateNetworkServiceType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservicetype/%(id: \\d+)s', 'form_params': [], 'method_name': 'updateNetworkServiceType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservicetype/{id: \\d+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /networkservicetype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'networkservicetype/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservicetype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteNetworkServiceType(self,
                                 networkservicetype_id=None,
                                 **kwargs):
        """
        [ HTTP: DELETE /networkservicetype/{id: \d+} ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id: \d+)s"
        path_params = {"id": networkservicetype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteNetworkServiceType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservicetype/%(id: \\d+)s', 'form_params': [], 'method_name': 'deleteNetworkServiceType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /networkservicetype/{id: \\d+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createNetworkServiceType(self,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /networkservicetype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createNetworkServiceType.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservicetype', 'form_params': [], 'method_name': 'createNetworkServiceType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /networkservicetype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkServiceType(self,
                              networkservicetype_id=None,
                              **kwargs):
        """
        [ HTTP: GET /networkservicetype/{id: \d+} ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id: \d+)s"
        path_params = {"id": networkservicetype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkServiceType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservicetype/%(id: \\d+)s', 'form_params': [], 'method_name': 'getNetworkServiceType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservicetype/{id: \\d+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /networkservicetype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservicetype/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservicetype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkServiceTypes(self,
                               **kwargs):
        """
        [ HTTP: GET /networkservicetype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkServiceTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservicetype', 'form_params': [], 'method_name': 'getNetworkServiceTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservicetype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     networkservicetype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /networkservicetype/{id}/export ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id)s/export"
        path_params = {"id": networkservicetype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'networkservicetype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservicetype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservicetype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /networkservicetype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservicetype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservicetype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkServiceTypeByName(self,
                                    networkservicetype_type=None,
                                    **kwargs):
        """
        [ HTTP: GET /networkservicetype/{type: [^0-9]\w+} ]

        @param networkservicetype_type: networkservicetype_type
        @type networkservicetype_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(type: [^0-9]\w+)s"
        path_params = {"type": networkservicetype_type}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkServiceTypeByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservicetype_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'networkservicetype/%(type: [^0-9]\\w+)s', 'form_params': [], 'method_name': 'getNetworkServiceTypeByName', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservicetype/{type: [^0-9]\\w+} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservicetype_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class environmenttype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def searchEnvironmentTypes(self,
                               **kwargs):
        """
        [ HTTP: GET /environmenttype/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchEnvironmentTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype/search', 'form_params': [], 'method_name': 'searchEnvironmentTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEnvironmentType(self,
                           environmenttype_id=None,
                           **kwargs):
        """
        [ HTTP: GET /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEnvironmentType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s', 'form_params': [], 'method_name': 'getEnvironmentType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteEnvironmentType(self,
                              environmenttype_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteEnvironmentType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s', 'form_params': [], 'method_name': 'deleteEnvironmentType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environmenttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createEnvironmentTypeXML(self,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /environmenttype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createEnvironmentTypeXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype', 'form_params': [], 'method_name': 'createEnvironmentTypeXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environmenttype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEnvironmentTypesXML(self,
                               **kwargs):
        """
        [ HTTP: GET /environmenttype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEnvironmentTypesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype', 'form_params': [], 'method_name': 'getEnvironmentTypesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateEnvironmentType(self,
                              environmenttype_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateEnvironmentType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s', 'form_params': [], 'method_name': 'updateEnvironmentType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environmenttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     environmenttype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /environmenttype/{id}/export ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s/export"
        path_params = {"id": environmenttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /environmenttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class policy:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def clearCache(self,
                   **kwargs):
        """
        [ HTTP: DELETE /policy/cache ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/cache"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    clearCache.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/cache', 'form_params': [], 'method_name': 'clearCache', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /policy/cache ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkOut(self,
                 policy_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /policy/{id}/checkout ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/checkout"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkIn(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/checkin ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/checkin"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEffectiveProtocol(self,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /policy/protocol/effective ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/protocol/effective"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEffectiveProtocol.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/protocol/effective', 'form_params': [], 'method_name': 'getEffectiveProtocol', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /policy/protocol/effective ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicyMetas(self,
                       **kwargs):
        """
        [ HTTP: GET /policy/meta ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/meta"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicyMetas.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/meta', 'form_params': [], 'method_name': 'getPolicyMetas', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/meta ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicies(self,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /policy ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicies.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deletePolicy(self,
                     policy_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'policy/%(id)s', 'form_params': [], 'method_name': 'deletePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /policy/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicyMeta(self,
                      meta_type=None,
                      **kwargs):
        """
        [ HTTP: GET /policy/meta/{type} ]

        @param meta_type: meta_type
        @type meta_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/meta/%(type)s"
        path_params = {"type": meta_type}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicyMeta.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'meta_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'policy/meta/%(type)s', 'form_params': [], 'method_name': 'getPolicyMeta', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/meta/{type} ]', 'method_params': [{'defaultValue': None, 'alias': 'meta_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updatePolicy(self,
                     policy_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updatePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'policy/%(id)s', 'form_params': [], 'method_name': 'updatePolicy', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /policy/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPolicy(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /policy ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy', 'form_params': [], 'method_name': 'createPolicy', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               policy_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /policy/{id}/reject ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/reject"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     policy_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /policy/{id}/export ]

        @param policy_id: policy_id
        @type policy_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/export"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicies(self,
                       assignmentTargetType=None,
                       **kwargs):
        """
        [ HTTP: GET /policy/search ]

        @param assignmentTargetType: assignmentTargetType
        @type assignmentTargetType: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"assignmentTargetType": assignmentTargetType}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicies.context = {'query_params': [{'defaultValue': None, 'alias': 'assignmentTargetType', 'kind': 'xs:string', 'required': False, 'name': 'assignmentTargetType'}], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/search', 'form_params': [], 'method_name': 'searchPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/search ]', 'method_params': [{'defaultValue': None, 'alias': 'assignmentTargetType', 'kind': 'xs:string', 'required': False, 'name': 'assignmentTargetType'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /policy/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicy(self,
                  policy_id=None,
                  **kwargs):
        """
        [ HTTP: GET /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'policy/%(id)s', 'form_params': [], 'method_name': 'getPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/approve ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/approve"
        path_params = {"id": policy_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getResourceMetrics(self,
                           type=None,
                           **kwargs):
        """
        [ HTTP: GET /policy/resource/weightInfos ]

        @param type: type
        @type type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/resource/weightInfos"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"type": type}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getResourceMetrics.context = {'query_params': [{'defaultValue': None, 'alias': 'type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/resource/weightInfos', 'form_params': [], 'method_name': 'getResourceMetrics', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/resource/weightInfos ]', 'method_params': [{'defaultValue': None, 'alias': 'type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storeedition:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def orderByLocation(self,
                        storeedition_id,
                        order_locationId=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /storeedition/{id}/order/{locationId} ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param order_locationId: order_locationId
        @type order_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s/order/%(locationId)s"
        path_params = {"id": storeedition_id,
                       "locationId": order_locationId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    orderByLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'order_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}], 'method_path': 'storeedition/%(id)s/order/%(locationId)s', 'form_params': [], 'method_name': 'orderByLocation', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storeedition/{id}/order/{locationId} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'order_locationId', 'kind': 'xs:int', 'required': False, 'name': 'locationId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEdition(self,
                   storeedition_id=None,
                   **kwargs):
        """
        [ HTTP: GET /storeedition/{id} ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s"
        path_params = {"id": storeedition_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEdition.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeedition/%(id)s', 'form_params': [], 'method_name': 'getEdition', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeedition/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateEdition(self,
                      storeedition_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /storeedition/{id} ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s"
        path_params = {"id": storeedition_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateEdition.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeedition/%(id)s', 'form_params': [], 'method_name': 'updateEdition', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storeedition/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchEditions(self,
                       **kwargs):
        """
        [ HTTP: GET /storeedition/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchEditions.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeedition/search', 'form_params': [], 'method_name': 'searchEditions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeedition/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEditions(self,
                    **kwargs):
        """
        [ HTTP: GET /storeedition ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEditions.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeedition', 'form_params': [], 'method_name': 'getEditions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeedition ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def order(self,
              storeedition_id,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /storeedition/{id}/order ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s/order"
        path_params = {"id": storeedition_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    order.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storeedition/%(id)s/order', 'form_params': [], 'method_name': 'order', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storeedition/{id}/order ]', 'method_params': [{'defaultValue': None, 'alias': 'storeedition_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class location:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateLocation(self,
                       location_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /location/{id} ]

        @param location_id: location_id
        @type location_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s"
        path_params = {"id": location_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'location/%(id)s', 'form_params': [], 'method_name': 'updateLocation', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /location/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getLocation(self,
                    location_id=None,
                    **kwargs):
        """
        [ HTTP: GET /location/{id} ]

        @param location_id: location_id
        @type location_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s"
        path_params = {"id": location_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'location/%(id)s', 'form_params': [], 'method_name': 'getLocation', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getLocationsXML(self,
                        **kwargs):
        """
        [ HTTP: GET /location ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getLocationsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'location', 'form_params': [], 'method_name': 'getLocationsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getLocationMetrics(self,
                           location_id,
                           **kwargs):
        """
        [ HTTP: GET /location/{id}/usage ]

        @param location_id: location_id
        @type location_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s/usage"
        path_params = {"id": location_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getLocationMetrics.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'location/%(id)s/usage', 'form_params': [], 'method_name': 'getLocationMetrics', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/{id}/usage ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchLocations(self,
                        **kwargs):
        """
        [ HTTP: GET /location/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchLocations.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'location/search', 'form_params': [], 'method_name': 'searchLocations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     location_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /location/{id}/export ]

        @param location_id: location_id
        @type location_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s/export"
        path_params = {"id": location_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'location/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /location/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'location/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class configuration_artifact:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'configuration/artifact/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifact/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifact/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifact/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifact(self,
                    artifact_id=None,
                    **kwargs):
        """
        [ HTTP: GET /configuration/artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/artifact/%(id)s', 'form_params': [], 'method_name': 'getArtifact', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifact/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateArtifact(self,
                       artifact_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/artifact/%(id)s', 'form_params': [], 'method_name': 'updateArtifact', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifact/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               artifact_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/{id}/reject ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/reject"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/artifact/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifact/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     artifact_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/artifact/{id}/export ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/export"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/artifact/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifact/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifacts(self,
                     **kwargs):
        """
        [ HTTP: GET /configuration/artifact ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifacts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifact', 'form_params': [], 'method_name': 'getArtifacts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifact ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/artifact/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifact/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifact/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                artifact_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/{id}/approve ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/approve"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/artifact/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/artifact/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchArtifacts(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/artifact/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchArtifacts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/artifact/search', 'form_params': [], 'method_name': 'searchArtifacts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/artifact/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class network:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getNetworkUsage(self,
                        network_id,
                        **kwargs):
        """
        [ HTTP: GET /network/{id}/usage ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/usage"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkUsage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'network/%(id)s/usage', 'form_params': [], 'method_name': 'getNetworkUsage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id}/usage ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworksXML(self,
                       **kwargs):
        """
        [ HTTP: GET /network ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworksXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network', 'form_params': [], 'method_name': 'getNetworksXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteNetwork(self,
                      network_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'network/%(id)s', 'form_params': [], 'method_name': 'deleteNetwork', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /network/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkInterfaces(self,
                             network_id,
                             **kwargs):
        """
        [ HTTP: GET /network/{id}/interfaces ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/interfaces"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkInterfaces.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'network/%(id)s/interfaces', 'form_params': [], 'method_name': 'getNetworkInterfaces', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id}/interfaces ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAddressRange(self,
                           network_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /network/{id}/addressrange ]

        @param network_id: network_id
        @type network_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/addressrange"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAddressRange.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'network/%(id)s/addressrange', 'form_params': [], 'method_name': 'createAddressRange', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /network/{id}/addressrange ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createNetwork(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /network ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network', 'form_params': [], 'method_name': 'createNetwork', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /network ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAvailableAddresses(self,
                              network_id,
                              **kwargs):
        """
        [ HTTP: GET /network/{id}/addresses ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/addresses"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAvailableAddresses.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'network/%(id)s/addresses', 'form_params': [], 'method_name': 'getAvailableAddresses', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id}/addresses ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateNetwork(self,
                      network_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'network/%(id)s', 'form_params': [], 'method_name': 'updateNetwork', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /network/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     network_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /network/{id}/export ]

        @param network_id: network_id
        @type network_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/export"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'network/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /network/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetwork(self,
                   network_id=None,
                   **kwargs):
        """
        [ HTTP: GET /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'network/%(id)s', 'form_params': [], 'method_name': 'getNetwork', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchNetworks(self,
                       **kwargs):
        """
        [ HTTP: GET /network/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchNetworks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network/search', 'form_params': [], 'method_name': 'searchNetworks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class scriptclasspath:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def deleteScriptClasspath(self,
                              scriptclasspath_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /scriptclasspath/{id} ]

        @param scriptclasspath_id: scriptclasspath_id
        @type scriptclasspath_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath/%(id)s"
        path_params = {"id": scriptclasspath_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteScriptClasspath.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptclasspath/%(id)s', 'form_params': [], 'method_name': 'deleteScriptClasspath', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /scriptclasspath/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createScriptClasspath(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /scriptclasspath ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createScriptClasspath.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptclasspath', 'form_params': [], 'method_name': 'createScriptClasspath', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /scriptclasspath ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptClasspath(self,
                           scriptclasspath_id=None,
                           **kwargs):
        """
        [ HTTP: GET /scriptclasspath/{id} ]

        @param scriptclasspath_id: scriptclasspath_id
        @type scriptclasspath_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath/%(id)s"
        path_params = {"id": scriptclasspath_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptClasspath.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptclasspath/%(id)s', 'form_params': [], 'method_name': 'getScriptClasspath', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptclasspath/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptClasspathsXML(self,
                               **kwargs):
        """
        [ HTTP: GET /scriptclasspath ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptClasspathsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptclasspath', 'form_params': [], 'method_name': 'getScriptClasspathsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptclasspath ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchScriptClasspaths(self,
                               **kwargs):
        """
        [ HTTP: GET /scriptclasspath/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchScriptClasspaths.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptclasspath/search', 'form_params': [], 'method_name': 'searchScriptClasspaths', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptclasspath/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class template:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def attachPackage(self,
                      template_id,
                      package_pkgid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /template/{id}/package/{pkgid} ]

        @param template_id: template_id
        @type template_id: str
        @param package_pkgid: package_pkgid
        @type package_pkgid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package/%(pkgid)s"
        path_params = {"id": template_id,
                       "pkgid": package_pkgid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'package_pkgid', 'kind': 'xs:int', 'required': False, 'name': 'pkgid'}], 'method_path': 'template/%(id)s/package/%(pkgid)s', 'form_params': [], 'method_name': 'attachPackage', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/package/{pkgid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'package_pkgid', 'kind': 'xs:int', 'required': False, 'name': 'pkgid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removePolicy(self,
                     template_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /template/{id}/policy/{policyid} ]

        @param template_id: template_id
        @type template_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy/%(policyid)s"
        path_params = {"id": template_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'template/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteTemplate(self,
                       template_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'template/%(id)s', 'form_params': [], 'method_name': 'deleteTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScaleUpPolicy(self,
                         template_id,
                         **kwargs):
        """
        [ HTTP: GET /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'getScaleUpPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMultiVariable(self,
                            template_templ_id,
                            variable_vname=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /template/{templ_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param template_templ_id: template_templ_id
        @type template_templ_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(templ_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"templ_id": template_templ_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMultiVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_templ_id', 'kind': 'xs:int', 'required': True, 'name': 'templ_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'template/%(templ_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'createMultiVariable', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{templ_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_templ_id', 'kind': 'xs:int', 'required': True, 'name': 'templ_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createScaleUpPolicy(self,
                            template_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'createScaleUpPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicyAssignments(self,
                                template_id,
                                **kwargs):
        """
        [ HTTP: GET /template/{id}/policyassignment/search ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policyassignment/search"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     template_id,
                     recursive=None,
                     exportOpts=None,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/export ]

        @param template_id: template_id
        @type template_id: str
        @param recursive: recursive
        @type recursive: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/export"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive,
                        "exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTemplates(self,
                     **kwargs):
        """
        [ HTTP: GET /template ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'template', 'form_params': [], 'method_name': 'getTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVolume(self,
                     template_id,
                     volume_volid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /template/{id}/volume/{volid} ]

        @param template_id: template_id
        @type template_id: str
        @param volume_volid: volume_volid
        @type volume_volid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume/%(volid)s"
        path_params = {"id": template_id,
                       "volid": volume_volid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'volume_volid', 'kind': 'xs:int', 'required': False, 'name': 'volid'}], 'method_path': 'template/%(id)s/volume/%(volid)s', 'form_params': [], 'method_name': 'deleteVolume', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/volume/{volid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'volume_volid', 'kind': 'xs:int', 'required': False, 'name': 'volid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateVariable(self,
                       template_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /template/{id}/variable/{variable_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAliasByName(self,
                          template_id,
                          alias_name=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /template/{id}/alias/{name: [a-zA-Z0-9_\-]+} ]

        @param template_id: template_id
        @type template_id: str
        @param alias_name: alias_name
        @type alias_name: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/alias/%(name: [a-zA-Z0-9_\-]+)s"
        path_params = {"id": template_id,
                       "name": alias_name}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAliasByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}], 'method_path': 'template/%(id)s/alias/%(name: [a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'updateAliasByName', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/alias/{name: [a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updatescaleDownPolicy(self,
                              template_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updatescaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'updatescaleDownPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVariable(self,
                       template_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /template/{id}/variable/{variable_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removePackage(self,
                      template_id,
                      packageid=None,
                      **kwargs):
        """
        [ HTTP: DELETE /template/{id}/package/{packageid} ]

        @param template_id: template_id
        @type template_id: str
        @param packageid: packageid
        @type packageid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package/%(packageid)s"
        path_params = {"id": template_id,
                       "packageid": packageid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removePackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'packageid', 'kind': 'xs:int', 'required': False, 'name': 'packageid'}], 'method_path': 'template/%(id)s/package/%(packageid)s', 'form_params': [], 'method_name': 'removePackage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/package/{packageid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'packageid', 'kind': 'xs:int', 'required': False, 'name': 'packageid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addPackage(self,
                   template_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /template/{id}/package ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/package', 'form_params': [], 'method_name': 'addPackage', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTemplate(self,
                    template_id=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'template/%(id)s', 'form_params': [], 'method_name': 'getTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createVariable(self,
                       template_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /template/{id}/variable ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteScaleUpPolicy(self,
                            template_id,
                            **kwargs):
        """
        [ HTTP: DELETE /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'deleteScaleUpPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def waitForInstances(self,
                         template_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /template/{id}/compute/wait ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/compute/wait"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    waitForInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/compute/wait', 'form_params': [], 'method_name': 'waitForInstances', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/compute/wait ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createscaleDownPolicy(self,
                              template_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createscaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'createscaleDownPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getscaleDownPolicy(self,
                           template_id,
                           **kwargs):
        """
        [ HTTP: GET /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getscaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'getscaleDownPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariable(self,
                    template_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getInstances(self,
                     template_id,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/compute ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/compute"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/compute', 'form_params': [], 'method_name': 'getInstances', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/compute ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /template/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [], 'method_path': 'template/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/export ]', 'method_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateScaleUpPolicy(self,
                            template_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'updateScaleUpPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteConfigurationResource(self,
                                    template_id,
                                    configurationresource_crid=None,
                                    **kwargs):
        """
        [ HTTP: DELETE /template/{id}/configurationresource/{crid} ]

        @param template_id: template_id
        @type template_id: str
        @param configurationresource_crid: configurationresource_crid
        @type configurationresource_crid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/configurationresource/%(crid)s"
        path_params = {"id": template_id,
                       "crid": configurationresource_crid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteConfigurationResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'configurationresource_crid', 'kind': 'xs:int', 'required': False, 'name': 'crid'}], 'method_path': 'template/%(id)s/configurationresource/%(crid)s', 'form_params': [], 'method_name': 'deleteConfigurationResource', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/configurationresource/{crid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'configurationresource_crid', 'kind': 'xs:int', 'required': False, 'name': 'crid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariableByName(self,
                          template_templ_id,
                          variable_vname=None,
                          **kwargs):
        """
        [ HTTP: GET /template/{templ_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param template_templ_id: template_templ_id
        @type template_templ_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(templ_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"templ_id": template_templ_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariableByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_templ_id', 'kind': 'xs:int', 'required': True, 'name': 'templ_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'template/%(templ_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'getVariableByName', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{templ_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_templ_id', 'kind': 'xs:int', 'required': True, 'name': 'templ_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariables(self,
                     template_id,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/variable ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/variable', 'form_params': [], 'method_name': 'getVariables', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateTemplate(self,
                       template_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'template/%(id)s', 'form_params': [], 'method_name': 'updateTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def decryptVariable(self,
                        template_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+}/decrypt ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s/decrypt"
        path_params = {"id": template_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def releaseTemplate(self,
                        template_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /template/{id}/release ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/release"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    releaseTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/release', 'form_params': [], 'method_name': 'releaseTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addConfigurationResource(self,
                                 template_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /template/{id}/configurationresource ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/configurationresource"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addConfigurationResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/configurationresource', 'form_params': [], 'method_name': 'addConfigurationResource', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/configurationresource ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVolumes(self,
                   template_id,
                   **kwargs):
        """
        [ HTTP: GET /template/{id}/volume ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolumes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/volume', 'form_params': [], 'method_name': 'getVolumes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/volume ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAlias(self,
                    template_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /template/{id}/alias/{alias_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/alias/%(alias_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'template/%(id)s/alias/%(alias_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/alias/{alias_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPackages(self,
                    template_id,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/package ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPackages.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deletescaleDownPolicy(self,
                              template_id,
                              **kwargs):
        """
        [ HTTP: DELETE /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletescaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'deletescaleDownPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicies(self,
                    template_id,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/policy ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def rebootTemplate(self,
                       template_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /template/{id}/restart ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/restart"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    rebootTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/restart', 'form_params': [], 'method_name': 'rebootTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addVolume(self,
                  template_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /template/{id}/volume ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/volume', 'form_params': [], 'method_name': 'addVolume', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/volume ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachPolicy(self,
                     template_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /template/{id}/policy/{policyid} ]

        @param template_id: template_id
        @type template_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy/%(policyid)s"
        path_params = {"id": template_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'template/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchTemplates(self,
                        **kwargs):
        """
        [ HTTP: GET /template/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'template/search', 'form_params': [], 'method_name': 'searchTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stopTemplate(self,
                     template_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /template/{id}/stop ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/stop"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stopTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/stop', 'form_params': [], 'method_name': 'stopTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def startTemplate(self,
                      template_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /template/{id}/start ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/start"
        path_params = {"id": template_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    startTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/start', 'form_params': [], 'method_name': 'startTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class paastype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getPlatformServiceType(self,
                               paastype_id=None,
                               **kwargs):
        """
        [ HTTP: GET /paastype/{id} ]

        @param paastype_id: paastype_id
        @type paastype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype/%(id)s"
        path_params = {"id": paastype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPlatformServiceType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'paastype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'paastype/%(id)s', 'form_params': [], 'method_name': 'getPlatformServiceType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paastype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'paastype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createArtifactType(self,
                           paastype_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /paastype/{id}/artifacttype ]

        @param paastype_id: paastype_id
        @type paastype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype/%(id)s/artifacttype"
        path_params = {"id": paastype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createArtifactType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'paastype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'paastype/%(id)s/artifacttype', 'form_params': [], 'method_name': 'createArtifactType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /paastype/{id}/artifacttype ]', 'method_params': [{'defaultValue': None, 'alias': 'paastype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchTypes(self,
                    **kwargs):
        """
        [ HTTP: GET /paastype/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'paastype/search', 'form_params': [], 'method_name': 'searchTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paastype/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTypes(self,
                 **kwargs):
        """
        [ HTTP: GET /paastype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'paastype', 'form_params': [], 'method_name': 'getTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /paastype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class script:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateScriptBody(self,
                         script_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /script/{id}/body ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/body"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateScriptBody.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/body', 'form_params': [], 'method_name': 'updateScriptBody', 'custom_headers': {'Content-Type': 'text/plain'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /script/{id}/body ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchScripts(self,
                      **kwargs):
        """
        [ HTTP: GET /script/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchScripts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'script/search', 'form_params': [], 'method_name': 'searchScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkOut(self,
                 script_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /script/{id}/checkout ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/checkout"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkIn(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/checkin ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/checkin"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAttachmentMulti(self,
                              script_id,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: POST /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAttachmentMulti.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/attachment', 'form_params': [], 'method_name': 'createAttachmentMulti', 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptMulti(self,
                       script_id=None,
                       **kwargs):
        """
        [ HTTP: GET /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptMulti.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'getScriptMulti', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAttachmentsXML(self,
                          script_id,
                          **kwargs):
        """
        [ HTTP: GET /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachmentsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/attachment', 'form_params': [], 'method_name': 'getAttachmentsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     script_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /script/{id}/export ]

        @param script_id: script_id
        @type script_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/export"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptsXML(self,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /script ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptsXML.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'script', 'form_params': [], 'method_name': 'getScriptsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScript(self,
                  script_id=None,
                  **kwargs):
        """
        [ HTTP: GET /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'getScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateScript(self,
                     script_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'updateScript', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               script_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /script/{id}/reject ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/reject"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteScript(self,
                     script_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'deleteScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        exportOpts=None,
                        recursive=None,
                        **kwargs):
        """
        [ HTTP: GET /script/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [], 'method_path': 'script/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/export ]', 'method_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/approve ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/approve"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAttachmentXML(self,
                            script_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAttachmentXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/attachment', 'form_params': [], 'method_name': 'createAttachmentXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAttachmentXML(self,
                            script_id,
                            attachment_id=None,
                            **kwargs):
        """
        [ HTTP: DELETE /script/{id}/attachment/{attachment_id} ]

        @param script_id: script_id
        @type script_id: str
        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment/%(attachment_id)s"
        path_params = {"id": script_id,
                       "attachment_id": attachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAttachmentXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'attachment_id'}], 'method_path': 'script/%(id)s/attachment/%(attachment_id)s', 'form_params': [], 'method_name': 'deleteAttachmentXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /script/{id}/attachment/{attachment_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'attachment_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class task:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getTasksXML(self,
                    **kwargs):
        """
        [ HTTP: GET /task ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTasksXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'task', 'form_params': [], 'method_name': 'getTasksXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchTopTasks(self,
                       **kwargs):
        """
        [ HTTP: GET /task/search/top ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/search/top"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchTopTasks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'task/search/top', 'form_params': [], 'method_name': 'searchTopTasks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task/search/top ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTask(self,
                task_id=None,
                **kwargs):
        """
        [ HTTP: GET /task/{id} ]

        @param task_id: task_id
        @type task_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s"
        path_params = {"id": task_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTask.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'task/%(id)s', 'form_params': [], 'method_name': 'getTask', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTaskChildren(self,
                        task_id,
                        **kwargs):
        """
        [ HTTP: GET /task/{id}/task ]

        @param task_id: task_id
        @type task_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/task"
        path_params = {"id": task_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTaskChildren.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'task/%(id)s/task', 'form_params': [], 'method_name': 'getTaskChildren', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task/{id}/task ]', 'method_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class cloudtype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def createModel(self,
                    cloudtype_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /cloudtype/{id}/model ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model"
        path_params = {"id": cloudtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s/model', 'form_params': [], 'method_name': 'createModel', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloudtype/{id}/model ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCloudType(self,
                     cloudtype_id=None,
                     **kwargs):
        """
        [ HTTP: GET /cloudtype/{id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s"
        path_params = {"id": cloudtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCloudType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s', 'form_params': [], 'method_name': 'getCloudType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteModel(self,
                    cloudtype_id,
                    model_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /cloudtype/{id}/model/{model_id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/%(model_id)s"
        path_params = {"id": cloudtype_id,
                       "model_id": model_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}], 'method_path': 'cloudtype/%(id)s/model/%(model_id)s', 'form_params': [], 'method_name': 'deleteModel', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloudtype/{id}/model/{model_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCloudType(self,
                        cloudtype_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /cloudtype/{id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s"
        path_params = {"id": cloudtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCloudType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s', 'form_params': [], 'method_name': 'updateCloudType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /cloudtype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getModel(self,
                 cloudtype_id,
                 model_id=None,
                 **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model/{model_id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/%(model_id)s"
        path_params = {"id": cloudtype_id,
                       "model_id": model_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}], 'method_path': 'cloudtype/%(id)s/model/%(model_id)s', 'form_params': [], 'method_name': 'getModel', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model/{model_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudTypeModelsXML(self,
                                 cloudtype_id,
                                 **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model/search ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/search"
        path_params = {"id": cloudtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudTypeModelsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s/model/search', 'form_params': [], 'method_name': 'searchCloudTypeModelsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getModels(self,
                  cloudtype_id,
                  **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model"
        path_params = {"id": cloudtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getModels.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s/model', 'form_params': [], 'method_name': 'getModels', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCloudTypes(self,
                      **kwargs):
        """
        [ HTTP: GET /cloudtype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCloudTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloudtype', 'form_params': [], 'method_name': 'getCloudTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class topology:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getTopologies(self,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /topology ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTopologies.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'topology', 'form_params': [], 'method_name': 'getTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDActionXML(self,
                          topology_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /topology/{id}/import ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/import"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               topology_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /topology/{id}/reject ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/reject"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def supportsVersioning(self,
                           **kwargs):
        """
        [ HTTP: GET /topology/versionable ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/versionable"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    supportsVersioning.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'topology/versionable', 'form_params': [], 'method_name': 'supportsVersioning', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/versionable ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAlias(self,
                    topology_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMultiVariable(self,
                            topology_top_id,
                            variable_vname=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{top_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param topology_top_id: topology_top_id
        @type topology_top_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(top_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"top_id": topology_top_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMultiVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_top_id', 'kind': 'xs:int', 'required': True, 'name': 'top_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'topology/%(top_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'createMultiVariable', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{top_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_top_id', 'kind': 'xs:int', 'required': True, 'name': 'top_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicyAssignments(self,
                                topology_id,
                                **kwargs):
        """
        [ HTTP: GET /topology/{id}/policyassignment/search ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/policyassignment/search"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     topology_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/export ]

        @param topology_id: topology_id
        @type topology_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/export"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def setAccessUris(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{topology_id}/accessuris ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuris"
        path_params = {"topology_id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    setAccessUris.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}], 'method_path': 'topology/%(topology_id)s/accessuris', 'form_params': [], 'method_name': 'setAccessUris', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{topology_id}/accessuris ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAlias(self,
                    topology_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /topology/{id}/alias ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/alias"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/alias', 'form_params': [], 'method_name': 'createAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkOut(self,
                 topology_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/checkout ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/checkout"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateVariable(self,
                       topology_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/variable/{variable_id: [0-9]+} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateTopology(self,
                       topology_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'topology/%(id)s', 'form_params': [], 'method_name': 'updateTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getChildTopologies(self,
                           topology_id,
                           **kwargs):
        """
        [ HTTP: GET /topology/{id}/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/topology"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getChildTopologies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/topology', 'form_params': [], 'method_name': 'getChildTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteTopology(self,
                       topology_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'topology/%(id)s', 'form_params': [], 'method_name': 'deleteTopology', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVariable(self,
                       topology_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/variable/{variable_id: [0-9]+} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDAction(self,
                       topology_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{id}/import ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/import"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createVariable(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/variable ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTemplateAny(self,
                               topology_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /topology/{id}/anyorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/anyorder/template"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTemplateAny.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/anyorder/template', 'form_params': [], 'method_name': 'createChildTemplateAny', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/anyorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTemplateManual(self,
                                  topology_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /topology/{id}/manualorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/manualorder/template"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTemplateManual.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/manualorder/template', 'form_params': [], 'method_name': 'createChildTemplateManual', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/manualorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAccessUri(self,
                     topology_id,
                     accessuri_id=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/accessuri/{accessuri_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param accessuri_id: accessuri_id
        @type accessuri_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri/%(accessuri_id)s"
        path_params = {"topology_id": topology_id,
                       "accessuri_id": accessuri_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAccessUri.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'accessuri_id', 'kind': 'xs:int', 'required': False, 'name': 'accessuri_id'}], 'method_path': 'topology/%(topology_id)s/accessuri/%(accessuri_id)s', 'form_params': [], 'method_name': 'getAccessUri', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{topology_id}/accessuri/{accessuri_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'accessuri_id', 'kind': 'xs:int', 'required': False, 'name': 'accessuri_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariable(self,
                    topology_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/variable/{variable_id: [0-9]+} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{topology_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def cloneTopology(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/clone ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/clone"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    cloneTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/clone', 'form_params': [], 'method_name': 'cloneTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createDeployer(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/deployer ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/deployer"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/deployer', 'form_params': [], 'method_name': 'createDeployer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/deployer ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTemplate(self,
                            topology_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{id}/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/template"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/template', 'form_params': [], 'method_name': 'createChildTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def rebootTopology(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/restart ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/restart"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    rebootTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/restart', 'form_params': [], 'method_name': 'rebootTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariableByName(self,
                          topology_top_id,
                          variable_vname=None,
                          **kwargs):
        """
        [ HTTP: GET /topology/{top_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param topology_top_id: topology_top_id
        @type topology_top_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(top_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"top_id": topology_top_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariableByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_top_id', 'kind': 'xs:int', 'required': True, 'name': 'top_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'topology/%(top_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'getVariableByName', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{top_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_top_id', 'kind': 'xs:int', 'required': True, 'name': 'top_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTopologyStats(self,
                         topology_id,
                         **kwargs):
        """
        [ HTTP: GET /topology/{id}/stats ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/stats"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTopologyStats.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/stats', 'form_params': [], 'method_name': 'getTopologyStats', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/stats ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAcessUri(self,
                       topology_id,
                       accessuri_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/accessuri/{accessuri_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param accessuri_id: accessuri_id
        @type accessuri_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri/%(accessuri_id)s"
        path_params = {"topology_id": topology_id,
                       "accessuri_id": accessuri_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAcessUri.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'accessuri_id', 'kind': 'xs:int', 'required': False, 'name': 'accessuri_id'}], 'method_path': 'topology/%(topology_id)s/accessuri/%(accessuri_id)s', 'form_params': [], 'method_name': 'updateAcessUri', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/accessuri/{accessuri_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'accessuri_id', 'kind': 'xs:int', 'required': False, 'name': 'accessuri_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def releaseTopology(self,
                        topology_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /topology/{id}/release ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/release"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    releaseTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/release', 'form_params': [], 'method_name': 'releaseTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTopologyAnyOrder(self,
                                    topology_id,
                                    data=None,
                                    **kwargs):
        """
        [ HTTP: POST /topology/{id}/anyorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/anyorder/topology"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTopologyAnyOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/anyorder/topology', 'form_params': [], 'method_name': 'createChildTopologyAnyOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/anyorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariables(self,
                     topology_id,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/variable ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/variable', 'form_params': [], 'method_name': 'getVariables', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getChildTemplates(self,
                          topology_id,
                          **kwargs):
        """
        [ HTTP: GET /topology/{id}/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/template"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getChildTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/template', 'form_params': [], 'method_name': 'getChildTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAlias(self,
                 topology_id,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{topology_id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAccessUris(self,
                      topology_id,
                      **kwargs):
        """
        [ HTTP: GET /topology/{id}/accessuri ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/accessuri"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAccessUris.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/accessuri', 'form_params': [], 'method_name': 'getAccessUris', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/accessuri ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /topology/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'topology/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTopology(self,
                    topology_id=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'topology/%(id)s', 'form_params': [], 'method_name': 'getTopology', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stopTopology(self,
                     topology_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /topology/{id}/stop ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/stop"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stopTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/stop', 'form_params': [], 'method_name': 'stopTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                topology_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /topology/{id}/approve ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/approve"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAlias(self,
                    topology_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDeployers(self,
                     topology_id,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/deployer ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/deployer"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDeployers.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/deployer', 'form_params': [], 'method_name': 'getDeployers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/deployer ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAccessUri(self,
                        topology_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /topology/{topology_id}/accessuri ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri"
        path_params = {"topology_id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAccessUri.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}], 'method_path': 'topology/%(topology_id)s/accessuri', 'form_params': [], 'method_name': 'createAccessUri', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{topology_id}/accessuri ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTemplateFixed(self,
                                 topology_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/fixedorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/fixedorder/template"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTemplateFixed.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/fixedorder/template', 'form_params': [], 'method_name': 'createChildTemplateFixed', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/fixedorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTopology(self,
                            topology_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{id}/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/topology"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/topology', 'form_params': [], 'method_name': 'createChildTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def startTopology(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/start ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/start"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    startTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/start', 'form_params': [], 'method_name': 'startTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTopologyManualOrder(self,
                                       topology_id,
                                       data=None,
                                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/manualorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/manualorder/topology"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTopologyManualOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/manualorder/topology', 'form_params': [], 'method_name': 'createChildTopologyManualOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/manualorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createChildTopologyFixedOrder(self,
                                      topology_id,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/fixedorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/fixedorder/topology"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createChildTopologyFixedOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/fixedorder/topology', 'form_params': [], 'method_name': 'createChildTopologyFixedOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/fixedorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAccessUri(self,
                        topology_id,
                        accessuri_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/accessuri/{accessuri_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param accessuri_id: accessuri_id
        @type accessuri_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri/%(accessuri_id)s"
        path_params = {"topology_id": topology_id,
                       "accessuri_id": accessuri_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAccessUri.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'accessuri_id', 'kind': 'xs:int', 'required': False, 'name': 'accessuri_id'}], 'method_path': 'topology/%(topology_id)s/accessuri/%(accessuri_id)s', 'form_params': [], 'method_name': 'deleteAccessUri', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/accessuri/{accessuri_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'accessuri_id', 'kind': 'xs:int', 'required': False, 'name': 'accessuri_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkIn(self,
                topology_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /topology/{id}/checkin ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/checkin"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAliases(self,
                   topology_id,
                   **kwargs):
        """
        [ HTTP: GET /topology/{id}/alias ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/alias"
        path_params = {"id": topology_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAliases.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/alias', 'form_params': [], 'method_name': 'getAliases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchTopologies(self,
                         **kwargs):
        """
        [ HTTP: GET /topology/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchTopologies.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'topology/search', 'form_params': [], 'method_name': 'searchTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class model:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getModel(self,
                 model_id=None,
                 **kwargs):
        """
        [ HTTP: GET /model/{id} ]

        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s"
        path_params = {"id": model_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'model/%(id)s', 'form_params': [], 'method_name': 'getModel', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getModelsXML(self,
                     **kwargs):
        """
        [ HTTP: GET /model ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getModelsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'model', 'form_params': [], 'method_name': 'getModelsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addResource(self,
                    model_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /model/{id}/resource ]

        @param model_id: model_id
        @type model_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource"
        path_params = {"id": model_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'model/%(id)s/resource', 'form_params': [], 'method_name': 'addResource', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /model/{id}/resource ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteResource(self,
                       model_id,
                       resource_resid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /model/{id}/resource/{resid} ]

        @param model_id: model_id
        @type model_id: str
        @param resource_resid: resource_resid
        @type resource_resid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource/%(resid)s"
        path_params = {"id": model_id,
                       "resid": resource_resid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resource_resid', 'kind': 'xs:int', 'required': False, 'name': 'resid'}], 'method_path': 'model/%(id)s/resource/%(resid)s', 'form_params': [], 'method_name': 'deleteResource', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /model/{id}/resource/{resid} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resource_resid', 'kind': 'xs:int', 'required': False, 'name': 'resid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateResource(self,
                       model_id,
                       resourceId=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /model/{id}/resource/{resourceId} ]

        @param model_id: model_id
        @type model_id: str
        @param resourceId: resourceId
        @type resourceId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource/%(resourceId)s"
        path_params = {"id": model_id,
                       "resourceId": resourceId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resourceId', 'kind': 'xs:int', 'required': False, 'name': 'resourceId'}], 'method_path': 'model/%(id)s/resource/%(resourceId)s', 'form_params': [], 'method_name': 'updateResource', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /model/{id}/resource/{resourceId} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resourceId', 'kind': 'xs:int', 'required': False, 'name': 'resourceId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchModels(self,
                     **kwargs):
        """
        [ HTTP: GET /model/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchModels.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'model/search', 'form_params': [], 'method_name': 'searchModels', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     model_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /model/{id}/export ]

        @param model_id: model_id
        @type model_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/export"
        path_params = {"id": model_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'model/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateModel(self,
                    model_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /model/{id} ]

        @param model_id: model_id
        @type model_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s"
        path_params = {"id": model_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'model/%(id)s', 'form_params': [], 'method_name': 'updateModel', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /model/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /model/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'model/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class designcontainer_designcontainer:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getDesignContainer(self,
                           designcontainer_dc_id,
                           designcontainer_id=None,
                           **kwargs):
        """
        [ HTTP: GET /designcontainer/{dc_id}/designcontainer/{id} ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer/%(id)s"
        path_params = {"dc_id": designcontainer_dc_id,
                       "id": designcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'designcontainer/%(dc_id)s/designcontainer/%(id)s', 'form_params': [], 'method_name': 'getDesignContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /designcontainer/{dc_id}/designcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def listDesignContainers(self,
                             designcontainer_dc_id,
                             **kwargs):
        """
        [ HTTP: GET /designcontainer/{dc_id}/designcontainer ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer"
        path_params = {"dc_id": designcontainer_dc_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    listDesignContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}], 'method_path': 'designcontainer/%(dc_id)s/designcontainer', 'form_params': [], 'method_name': 'listDesignContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /designcontainer/{dc_id}/designcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createSubDesignContainer(self,
                                 designcontainer_dc_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /designcontainer/{dc_id}/designcontainer ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer"
        path_params = {"dc_id": designcontainer_dc_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createSubDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}], 'method_path': 'designcontainer/%(dc_id)s/designcontainer', 'form_params': [], 'method_name': 'createSubDesignContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /designcontainer/{dc_id}/designcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDesignContainer(self,
                              designcontainer_dc_id,
                              designcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /designcontainer/{dc_id}/designcontainer/{id} ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer/%(id)s"
        path_params = {"dc_id": designcontainer_dc_id,
                       "id": designcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDesignContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'designcontainer/%(dc_id)s/designcontainer/%(id)s', 'form_params': [], 'method_name': 'deleteDesignContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /designcontainer/{dc_id}/designcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'designcontainer_dc_id', 'kind': 'xs:int', 'required': True, 'name': 'dc_id'}, {'defaultValue': None, 'alias': 'designcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storeproduct:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getProduct(self,
                   storeproduct_id=None,
                   **kwargs):
        """
        [ HTTP: GET /storeproduct/{id} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s"
        path_params = {"id": storeproduct_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProduct.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeproduct/%(id)s', 'form_params': [], 'method_name': 'getProduct', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createProduct(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /storeproduct ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createProduct.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproduct', 'form_params': [], 'method_name': 'createProduct', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storeproduct ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getReview(self,
                  storeproduct_id,
                  reviewid=None,
                  **kwargs):
        """
        [ HTTP: GET /storeproduct/{id}/review/{reviewid} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param reviewid: reviewid
        @type reviewid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/review/%(reviewid)s"
        path_params = {"id": storeproduct_id,
                       "reviewid": reviewid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getReview.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'reviewid', 'kind': 'xs:int', 'required': False, 'name': 'reviewid'}], 'method_path': 'storeproduct/%(id)s/review/%(reviewid)s', 'form_params': [], 'method_name': 'getReview', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct/{id}/review/{reviewid} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'reviewid', 'kind': 'xs:int', 'required': False, 'name': 'reviewid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteProduct(self,
                      storeproduct_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /storeproduct/{id} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s"
        path_params = {"id": storeproduct_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteProduct.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeproduct/%(id)s', 'form_params': [], 'method_name': 'deleteProduct', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /storeproduct/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateProduct(self,
                      storeproduct_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /storeproduct/{id} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s"
        path_params = {"id": storeproduct_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateProduct.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeproduct/%(id)s', 'form_params': [], 'method_name': 'updateProduct', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storeproduct/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteReview(self,
                     storeproduct_id,
                     reviewid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /storeproduct/{id}/review/{reviewid} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param reviewid: reviewid
        @type reviewid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/review/%(reviewid)s"
        path_params = {"id": storeproduct_id,
                       "reviewid": reviewid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteReview.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'reviewid', 'kind': 'xs:int', 'required': False, 'name': 'reviewid'}], 'method_path': 'storeproduct/%(id)s/review/%(reviewid)s', 'form_params': [], 'method_name': 'deleteReview', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /storeproduct/{id}/review/{reviewid} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'reviewid', 'kind': 'xs:int', 'required': False, 'name': 'reviewid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateReview(self,
                     storeproduct_id,
                     reviewid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /storeproduct/{id}/review/{reviewid} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param reviewid: reviewid
        @type reviewid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/review/%(reviewid)s"
        path_params = {"id": storeproduct_id,
                       "reviewid": reviewid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateReview.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'reviewid', 'kind': 'xs:int', 'required': False, 'name': 'reviewid'}], 'method_path': 'storeproduct/%(id)s/review/%(reviewid)s', 'form_params': [], 'method_name': 'updateReview', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storeproduct/{id}/review/{reviewid} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'reviewid', 'kind': 'xs:int', 'required': False, 'name': 'reviewid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createReview(self,
                     storeproduct_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /storeproduct/{id}/review ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/review"
        path_params = {"id": storeproduct_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createReview.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storeproduct/%(id)s/review', 'form_params': [], 'method_name': 'createReview', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storeproduct/{id}/review ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     storeproduct_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storeproduct/{id}/export ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/export"
        path_params = {"id": storeproduct_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storeproduct/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getReviews(self,
                   storeproduct_id,
                   **kwargs):
        """
        [ HTTP: GET /storeproduct/{id}/reviews ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/reviews"
        path_params = {"id": storeproduct_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getReviews.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storeproduct/%(id)s/reviews', 'form_params': [], 'method_name': 'getReviews', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct/{id}/reviews ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproduct_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storeproduct/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproduct/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProducts(self,
                    **kwargs):
        """
        [ HTTP: GET /storeproduct ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProducts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproduct', 'form_params': [], 'method_name': 'getProducts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchProducts(self,
                       **kwargs):
        """
        [ HTTP: GET /storeproduct/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchProducts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproduct/search', 'form_params': [], 'method_name': 'searchProducts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproduct/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class permissiontype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getPermissionType(self,
                          permissiontype_id=None,
                          **kwargs):
        """
        [ HTTP: GET /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'permissiontype/%(id)s', 'form_params': [], 'method_name': 'getPermissionType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /permissiontype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deletePermissionType(self,
                             permissiontype_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletePermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'permissiontype/%(id)s', 'form_params': [], 'method_name': 'deletePermissionType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /permissiontype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updatePermissionType(self,
                             permissiontype_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updatePermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'permissiontype/%(id)s', 'form_params': [], 'method_name': 'updatePermissionType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /permissiontype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class project:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getProject(self,
                   project_id=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'project/%(id)s', 'form_params': [], 'method_name': 'getProject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTopologies(self,
                      project_id,
                      **kwargs):
        """
        [ HTTP: GET /project/{id}/topology ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/topology"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTopologies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/topology', 'form_params': [], 'method_name': 'getTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDActionXML(self,
                          project_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /project/{id}/import ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/import"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSecurity(self,
                    project_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/security/{security_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def releaseProject(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/release ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/release"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    releaseProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/release', 'form_params': [], 'method_name': 'releaseProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getBlueprints(self,
                      project_id,
                      **kwargs):
        """
        [ HTTP: GET /project/{project_id}/blueprint ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/blueprint"
        path_params = {"project_id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getBlueprints.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}], 'method_path': 'project/%(project_id)s/blueprint', 'form_params': [], 'method_name': 'getBlueprints', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{project_id}/blueprint ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removePolicy(self,
                     project_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /project/{id}/policy/{policyid} ]

        @param project_id: project_id
        @type project_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy/%(policyid)s"
        path_params = {"id": project_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'project/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicyAssignments(self,
                                project_id,
                                **kwargs):
        """
        [ HTTP: GET /project/{id}/policyassignment/search ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policyassignment/search"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAlias(self,
                    project_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityAccessRight(self,
                                  project_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMultiVariable(self,
                            project_id,
                            variable_vname=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /project/{project_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"project_id": project_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMultiVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'project/%(project_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'createMultiVariable', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{project_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTemplates(self,
                     project_id,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/template ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/template"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/template', 'form_params': [], 'method_name': 'getTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     project_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/export ]

        @param project_id: project_id
        @type project_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/export"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProjects(self,
                    **kwargs):
        """
        [ HTTP: GET /project ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project', 'form_params': [], 'method_name': 'getProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAlias(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/alias ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/alias', 'form_params': [], 'method_name': 'createAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateVariable(self,
                       project_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/{project_id}/variable/{variable_id: [0-9]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{project_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def startProject(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/start ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/start"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    startProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/start', 'form_params': [], 'method_name': 'startProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVariable(self,
                       project_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /project/{project_id}/variable/{variable_id: [0-9]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{project_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicies(self,
                    project_id,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/policy ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUserGroup(self,
                                project_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachPolicy(self,
                     project_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /project/{id}/policy/{policyid} ]

        @param project_id: project_id
        @type project_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy/%(policyid)s"
        path_params = {"id": project_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'project/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createVariable(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/variable ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurity(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/security ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTopology(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/topology ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/topology"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/topology', 'form_params': [], 'method_name': 'createTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createEnvironment(self,
                          project_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /project/{id}/environment ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/environment"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/environment', 'form_params': [], 'method_name': 'createEnvironment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/environment ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariable(self,
                    project_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{project_id}/variable/{variable_id: [0-9]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{project_id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSolutions(self,
                     project_id,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/solution ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/solution"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSolutions.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/solution', 'form_params': [], 'method_name': 'getSolutions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/solution ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityRights(self,
                             project_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUser(self,
                           project_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/user/{user_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "user_id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurity(self,
                       project_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUserGroup(self,
                             project_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/usergroup ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": project_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTemplate(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/template ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/template"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/template', 'form_params': [], 'method_name': 'createTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariables(self,
                     project_id,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/variable ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/variable', 'form_params': [], 'method_name': 'getVariables', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def cloneProject(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/clone ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/clone"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    cloneProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/clone', 'form_params': [], 'method_name': 'cloneProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createProject(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /project ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project', 'form_params': [], 'method_name': 'createProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAlias(self,
                 project_id,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateProject(self,
                      project_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'project/%(id)s', 'form_params': [], 'method_name': 'updateProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteProject(self,
                      project_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'project/%(id)s', 'form_params': [], 'method_name': 'deleteProject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stopProject(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/stop ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/stop"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stopProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/stop', 'form_params': [], 'method_name': 'stopProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityRights(self,
                          project_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/rights ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": project_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createBlueprint(self,
                        project_id,
                        force=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project/{id}/blueprint ]

        @param project_id: project_id
        @type project_id: str
        @param force: force
        @type force: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/blueprint"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"force": force}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createBlueprint.context = {'query_params': [{'defaultValue': None, 'alias': 'force', 'kind': 'xs:boolean', 'required': False, 'name': 'force'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/blueprint', 'form_params': [], 'method_name': 'createBlueprint', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/blueprint ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'force', 'kind': 'xs:boolean', 'required': False, 'name': 'force'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def decryptVariable(self,
                        project_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /project/{id}/variable/{variable_id}/decrypt ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": project_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /project/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}], 'hasFiles': False, 'path_params': [], 'method_path': 'project/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/export ]', 'method_params': [{'defaultValue': None, 'alias': 'exportOpts', 'kind': 'xs:string', 'required': False, 'name': 'exportOpts'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariablesByName(self,
                           project_id,
                           variable_vname=None,
                           **kwargs):
        """
        [ HTTP: GET /project/{project_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"project_id": project_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariablesByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'project/%(project_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'getVariablesByName', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{project_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /project/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'project/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityAccessRight(self,
                               project_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPackage(self,
                      project_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /project/{id}/package ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/package"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/package', 'form_params': [], 'method_name': 'createPackage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAlias(self,
                    project_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPackages(self,
                    project_id,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/package ]

        @param project_id: project_id
        @type project_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/package"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPackages.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScripts(self,
                   project_id,
                   version=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id}/script ]

        @param project_id: project_id
        @type project_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/script"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScripts.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/script', 'form_params': [], 'method_name': 'getScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getEnvironments(self,
                        project_id,
                        **kwargs):
        """
        [ HTTP: GET /project/{id}/environment ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/environment"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEnvironments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/environment', 'form_params': [], 'method_name': 'getEnvironments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/environment ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /project/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createScript(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/script ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/script"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/script', 'form_params': [], 'method_name': 'createScript', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def restartProject(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/restart ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/restart"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    restartProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/restart', 'form_params': [], 'method_name': 'restartProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUser(self,
                        project_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/user ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/user"
        path_params = {"id": project_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDAction(self,
                       project_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/{id}/import ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/import"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchProjects(self,
                       **kwargs):
        """
        [ HTTP: GET /project/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project/search', 'form_params': [], 'method_name': 'searchProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAliases(self,
                   project_id,
                   **kwargs):
        """
        [ HTTP: GET /project/{id}/alias ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAliases.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/alias', 'form_params': [], 'method_name': 'getAliases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createSolution(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/solution ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/solution"
        path_params = {"id": project_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createSolution.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/solution', 'form_params': [], 'method_name': 'createSolution', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/solution ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class compute:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getInstancesXML(self,
                        **kwargs):
        """
        [ HTTP: GET /compute ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getInstancesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'compute', 'form_params': [], 'method_name': 'getInstancesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkAccess(self,
                    ip=None,
                    port=None,
                    auth=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/access ]

        @param ip: ip
        @type ip: str
        @param port: port
        @type port: str
        @param auth: auth
        @type auth: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/access"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"ip": ip,
                        "port": port,
                        "auth": auth}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkAccess.context = {'query_params': [{'defaultValue': None, 'alias': 'ip', 'kind': 'xs:string', 'required': False, 'name': 'ip'}, {'defaultValue': None, 'alias': 'port', 'kind': 'xs:int', 'required': False, 'name': 'port'}, {'defaultValue': None, 'alias': 'auth', 'kind': 'xs:string', 'required': False, 'name': 'auth'}], 'hasFiles': False, 'path_params': [], 'method_path': 'compute/access', 'form_params': [], 'method_name': 'checkAccess', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/access ]', 'method_params': [{'defaultValue': None, 'alias': 'ip', 'kind': 'xs:string', 'required': False, 'name': 'ip'}, {'defaultValue': None, 'alias': 'port', 'kind': 'xs:int', 'required': False, 'name': 'port'}, {'defaultValue': None, 'alias': 'auth', 'kind': 'xs:string', 'required': False, 'name': 'auth'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSnapshot(self,
                       compute_id,
                       snapshot_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'deleteSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /compute/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def startInstance(self,
                      compute_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/start ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/start"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    startInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/start', 'form_params': [], 'method_name': 'startInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateInstance(self,
                       compute_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'compute/%(id)s', 'form_params': [], 'method_name': 'updateInstance', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /compute/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def revertSnapshot(self,
                       compute_id,
                       snapshot_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    revertSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'revertSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /compute/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchInstances(self,
                        **kwargs):
        """
        [ HTTP: GET /compute/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'compute/search', 'form_params': [], 'method_name': 'searchInstances', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateVariable(self,
                       compute_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id}/variable/{variable_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'compute/%(id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /compute/{id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAliasByName(self,
                          compute_id,
                          alias_name=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /compute/{id}/alias/{name: [a-zA-Z0-9_\-]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param alias_name: alias_name
        @type alias_name: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/alias/%(name: [a-zA-Z0-9_\-]+)s"
        path_params = {"id": compute_id,
                       "name": alias_name}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAliasByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}], 'method_path': 'compute/%(id)s/alias/%(name: [a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'updateAliasByName', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/alias/{name: [a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def executeScript(self,
                      compute_id,
                      execute_scriptid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/execute/{scriptid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param execute_scriptid: execute_scriptid
        @type execute_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/execute/%(scriptid)s"
        path_params = {"id": compute_id,
                       "scriptid": execute_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    executeScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'execute_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'compute/%(id)s/execute/%(scriptid)s', 'form_params': [], 'method_name': 'executeScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/execute/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'execute_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def releaseInstance(self,
                        compute_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /compute/{id}/release ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/release"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    releaseInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/release', 'form_params': [], 'method_name': 'releaseInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVariable(self,
                       compute_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /compute/{id}/variable/{variable_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'compute/%(id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /compute/{id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getInstance(self,
                    compute_id=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'compute/%(id)s', 'form_params': [], 'method_name': 'getInstance', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def acknowledgeDegrade(self,
                           compute_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /compute/{id}/ack ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/ack"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    acknowledgeDegrade.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/ack', 'form_params': [], 'method_name': 'acknowledgeDegrade', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /compute/{id}/ack ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createVariable(self,
                       compute_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /compute/{id}/variable ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def rebootInstance(self,
                       compute_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /compute/{id}/restart ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/restart"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    rebootInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/restart', 'form_params': [], 'method_name': 'rebootInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariable(self,
                    compute_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id}/variable/{variable_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'compute/%(id)s/variable/%(variable_id: [0-9]+)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/variable/{variable_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def stopInstance(self,
                     compute_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /compute/{id}/stop ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/stop"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    stopInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/stop', 'form_params': [], 'method_name': 'stopInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptStatuses(self,
                          compute_id,
                          **kwargs):
        """
        [ HTTP: GET /compute/{id}/scriptstatus ]

        @param compute_id: compute_id
        @type compute_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/scriptstatus"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptStatuses.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/scriptstatus', 'form_params': [], 'method_name': 'getScriptStatuses', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/scriptstatus ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariableByName(self,
                          compute_instance_id,
                          variable_vname=None,
                          **kwargs):
        """
        [ HTTP: GET /compute/{instance_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param compute_instance_id: compute_instance_id
        @type compute_instance_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(instance_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"instance_id": compute_instance_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariableByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_instance_id', 'kind': 'xs:int', 'required': True, 'name': 'instance_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'compute/%(instance_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'getVariableByName', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{instance_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_instance_id', 'kind': 'xs:int', 'required': True, 'name': 'instance_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def executeScriptTask(self,
                          compute_id,
                          queue_scriptid=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /compute/{id}/queue/{scriptid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param queue_scriptid: queue_scriptid
        @type queue_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/queue/%(scriptid)s"
        path_params = {"id": compute_id,
                       "scriptid": queue_scriptid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    executeScriptTask.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'queue_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'compute/%(id)s/queue/%(scriptid)s', 'form_params': [], 'method_name': 'executeScriptTask', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/queue/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'queue_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSnapshot(self,
                    compute_id,
                    snapshot_id=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'getSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def decryptVariable(self,
                        compute_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /compute/{id}/variable/{variable_id}/decrypt ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'compute/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createMultiVariable(self,
                            compute_instance_id,
                            variable_vname=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /compute/{instance_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param compute_instance_id: compute_instance_id
        @type compute_instance_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(instance_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"instance_id": compute_instance_id,
                       "vname": variable_vname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createMultiVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_instance_id', 'kind': 'xs:int', 'required': True, 'name': 'instance_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}], 'method_path': 'compute/%(instance_id)s/variable/%(vname: [a-zA-Z][a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'createMultiVariable', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{instance_id}/variable/{vname: [a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_instance_id', 'kind': 'xs:int', 'required': True, 'name': 'instance_id'}, {'defaultValue': None, 'alias': 'variable_vname', 'kind': 'xs:string', 'required': False, 'name': 'vname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def snapshotInstance(self,
                         compute_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /compute/{id}/snapshot ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot"
        path_params = {"id": compute_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    snapshotInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/snapshot', 'form_params': [], 'method_name': 'snapshotInstance', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/snapshot ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAlias(self,
                    compute_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /compute/{id}/alias/{alias_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/alias/%(alias_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "alias_id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'compute/%(id)s/alias/%(alias_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/alias/{alias_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getScriptStatus(self,
                        compute_id,
                        scriptstatusid=None,
                        **kwargs):
        """
        [ HTTP: GET /compute/{id}/scriptstatus/{scriptstatusid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param scriptstatusid: scriptstatusid
        @type scriptstatusid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/scriptstatus/%(scriptstatusid)s"
        path_params = {"id": compute_id,
                       "scriptstatusid": scriptstatusid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getScriptStatus.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'scriptstatusid', 'kind': 'xs:int', 'required': False, 'name': 'scriptstatusid'}], 'method_path': 'compute/%(id)s/scriptstatus/%(scriptstatusid)s', 'form_params': [], 'method_name': 'getScriptStatus', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/scriptstatus/{scriptstatusid} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'scriptstatusid', 'kind': 'xs:int', 'required': False, 'name': 'scriptstatusid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storeproductadapter:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getProductAdapters(self,
                           **kwargs):
        """
        [ HTTP: GET /storeproductadapter ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproductadapter"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProductAdapters.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproductadapter', 'form_params': [], 'method_name': 'getProductAdapters', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproductadapter ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchProductAdapters(self,
                              **kwargs):
        """
        [ HTTP: GET /storeproductadapter/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproductadapter/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchProductAdapters.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storeproductadapter/search', 'form_params': [], 'method_name': 'searchProductAdapters', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproductadapter/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProductAdapter(self,
                          storeproductadapter_id=None,
                          **kwargs):
        """
        [ HTTP: GET /storeproductadapter/{id} ]

        @param storeproductadapter_id: storeproductadapter_id
        @type storeproductadapter_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproductadapter/%(id)s"
        path_params = {"id": storeproductadapter_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProductAdapter.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storeproductadapter_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storeproductadapter/%(id)s', 'form_params': [], 'method_name': 'getProductAdapter', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storeproductadapter/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storeproductadapter_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class volume:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getVolumesXML(self,
                      **kwargs):
        """
        [ HTTP: GET /volume ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolumesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'volume', 'form_params': [], 'method_name': 'getVolumesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volume ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVolume(self,
                  volume_id=None,
                  **kwargs):
        """
        [ HTTP: GET /volume/{id} ]

        @param volume_id: volume_id
        @type volume_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume/%(id)s"
        path_params = {"id": volume_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'volume/%(id)s', 'form_params': [], 'method_name': 'getVolume', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volume/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVolume(self,
                     volume_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /volume/{id} ]

        @param volume_id: volume_id
        @type volume_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume/%(id)s"
        path_params = {"id": volume_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'volume/%(id)s', 'form_params': [], 'method_name': 'deleteVolume', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /volume/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class attachment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getAttachmentsXML(self,
                          **kwargs):
        """
        [ HTTP: GET /attachment ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachmentsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'attachment', 'form_params': [], 'method_name': 'getAttachmentsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /attachment ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAttachmentMulti(self,
                           attachment_id=None,
                           **kwargs):
        """
        [ HTTP: GET /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachmentMulti.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'attachment/%(id)s', 'form_params': [], 'method_name': 'getAttachmentMulti', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /attachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAttachment(self,
                         attachment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'attachment/%(id)s', 'form_params': [], 'method_name': 'deleteAttachment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /attachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAttachment(self,
                         attachment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'attachment/%(id)s', 'form_params': [], 'method_name': 'updateAttachment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /attachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class theme:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getTheme(self,
                 **kwargs):
        """
        [ HTTP: GET /theme ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "theme"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTheme.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'theme', 'form_params': [], 'method_name': 'getTheme', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /theme ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class artifact:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def publishArtifactMulti(self,
                             artifact_id,
                             data=None,
                             files=None,
                             **kwargs):
        """
        [ HTTP: POST /artifact/{id}/publish ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/publish"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    publishArtifactMulti.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/publish', 'form_params': [], 'method_name': 'publishArtifactMulti', 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /artifact/{id}/publish ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAllVersions(self,
                       artifact_slotId,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /artifact/{slotId}/version ]

        @param artifact_slotId: artifact_slotId
        @type artifact_slotId: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(slotId)s/version"
        path_params = {"slotId": artifact_slotId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"includeHead": includeHead}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAllVersions.context = {'query_params': [{'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}], 'method_path': 'artifact/%(slotId)s/version', 'form_params': [], 'method_name': 'getAllVersions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/{slotId}/version ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}, {'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteArtifact(self,
                       artifact_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifact/%(id)s', 'form_params': [], 'method_name': 'deleteArtifact', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /artifact/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def hardDeleteArtifact(self,
                           artifact_id,
                           **kwargs):
        """
        [ HTTP: DELETE /artifact/{id}/hard ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/hard"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    hardDeleteArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/hard', 'form_params': [], 'method_name': 'hardDeleteArtifact', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /artifact/{id}/hard ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAttachment(self,
                         artifact_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /artifact/{id}/attachment ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/attachment', 'form_params': [], 'method_name': 'createAttachment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /artifact/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchArtifacts(self,
                        **kwargs):
        """
        [ HTTP: GET /artifact/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchArtifacts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'artifact/search', 'form_params': [], 'method_name': 'searchArtifacts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateArtifact(self,
                       artifact_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifact/%(id)s', 'form_params': [], 'method_name': 'updateArtifact', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /artifact/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAttachments(self,
                       artifact_id,
                       **kwargs):
        """
        [ HTTP: GET /artifact/{id}/attachment ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAttachments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/attachment', 'form_params': [], 'method_name': 'getAttachments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifactMulti(self,
                         artifact_id=None,
                         **kwargs):
        """
        [ HTTP: GET /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifactMulti.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifact/%(id)s', 'form_params': [], 'method_name': 'getArtifactMulti', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateArtifactConfiguration(self,
                                    artifact_id,
                                    data=None,
                                    **kwargs):
        """
        [ HTTP: PUT /artifact/{id}/config ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/config"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateArtifactConfiguration.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/config', 'form_params': [], 'method_name': 'updateArtifactConfiguration', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /artifact/{id}/config ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifact(self,
                    artifact_id=None,
                    **kwargs):
        """
        [ HTTP: GET /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifact.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifact/%(id)s', 'form_params': [], 'method_name': 'getArtifact', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     artifact_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /artifact/{id}/export ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/export"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getArtifacts(self,
                     **kwargs):
        """
        [ HTTP: GET /artifact ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getArtifacts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'artifact', 'form_params': [], 'method_name': 'getArtifacts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /artifact/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'artifact/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifact/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createAttachmentMulti(self,
                              artifact_id,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: POST /artifact/{id}/attachment ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment"
        path_params = {"id": artifact_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createAttachmentMulti.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'artifact/%(id)s/attachment', 'form_params': [], 'method_name': 'createAttachmentMulti', 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /artifact/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteArtifactSlot(self,
                           artifact_slotId,
                           **kwargs):
        """
        [ HTTP: DELETE /artifact/{slotId}/slot ]

        @param artifact_slotId: artifact_slotId
        @type artifact_slotId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(slotId)s/slot"
        path_params = {"slotId": artifact_slotId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteArtifactSlot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}], 'method_path': 'artifact/%(slotId)s/slot', 'form_params': [], 'method_name': 'deleteArtifactSlot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /artifact/{slotId}/slot ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAttachmentXML(self,
                            artifact_id,
                            attachment_id=None,
                            **kwargs):
        """
        [ HTTP: DELETE /artifact/{id}/attachment/{attachment_id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment/%(attachment_id)s"
        path_params = {"id": artifact_id,
                       "attachment_id": attachment_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAttachmentXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'attachment_id'}], 'method_path': 'artifact/%(id)s/attachment/%(attachment_id)s', 'form_params': [], 'method_name': 'deleteAttachmentXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /artifact/{id}/attachment/{attachment_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifact_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'attachment_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storage:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getStoragesXML(self,
                       **kwargs):
        """
        [ HTTP: GET /storage ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getStoragesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storage', 'form_params': [], 'method_name': 'getStoragesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storage ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getStorage(self,
                   storage_id=None,
                   **kwargs):
        """
        [ HTTP: GET /storage/{id} ]

        @param storage_id: storage_id
        @type storage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s"
        path_params = {"id": storage_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getStorage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storage/%(id)s', 'form_params': [], 'method_name': 'getStorage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storage/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class stack:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateStack(self,
                    stack_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'stack/%(id)s', 'form_params': [], 'method_name': 'updateStack', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /stack/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAllVersions(self,
                       stack_slotId,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /stack/{slotId}/version ]

        @param stack_slotId: stack_slotId
        @type stack_slotId: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(slotId)s/version"
        path_params = {"slotId": stack_slotId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"includeHead": includeHead}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAllVersions.context = {'query_params': [{'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}], 'method_path': 'stack/%(slotId)s/version', 'form_params': [], 'method_name': 'getAllVersions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/{slotId}/version ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_slotId', 'kind': 'xs:int', 'required': True, 'name': 'slotId'}, {'defaultValue': None, 'alias': 'includeHead', 'kind': 'xs:string', 'required': False, 'name': 'includeHead'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getStack(self,
                 stack_id=None,
                 **kwargs):
        """
        [ HTTP: GET /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'stack/%(id)s', 'form_params': [], 'method_name': 'getStack', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteTargetCloud(self,
                          stack_id,
                          targetcloud_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /stack/{id}/targetcloud/{targetcloud_id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param targetcloud_id: targetcloud_id
        @type targetcloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/targetcloud/%(targetcloud_id)s"
        path_params = {"id": stack_id,
                       "targetcloud_id": targetcloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteTargetCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'targetcloud_id'}], 'method_path': 'stack/%(id)s/targetcloud/%(targetcloud_id)s', 'form_params': [], 'method_name': 'deleteTargetCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /stack/{id}/targetcloud/{targetcloud_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'targetcloud_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkOut(self,
                 stack_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /stack/{id}/checkout ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/checkout"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def checkIn(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/checkin ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/checkin"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getStacksXML(self,
                     version=None,
                     **kwargs):
        """
        [ HTTP: GET /stack ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"version": version}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getStacksXML.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'stack', 'form_params': [], 'method_name': 'getStacksXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchBaseStacks(self,
                         **kwargs):
        """
        [ HTTP: GET /stack/base/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/base/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchBaseStacks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack/base/search', 'form_params': [], 'method_name': 'searchBaseStacks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/base/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createTargetCloud(self,
                          stack_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /stack/{id}/targetcloud ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/targetcloud"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createTargetCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/targetcloud', 'form_params': [], 'method_name': 'createTargetCloud', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/targetcloud ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteStack(self,
                    stack_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'stack/%(id)s', 'form_params': [], 'method_name': 'deleteStack', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /stack/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def build(self,
              stack_id,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /stack/{id}/build ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/build"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    build.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/build', 'form_params': [], 'method_name': 'build', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/build ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def reject(self,
               stack_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /stack/{id}/reject ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/reject"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     stack_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /stack/{id}/export ]

        @param stack_id: stack_id
        @type stack_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/export"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteStackAllVersions(self,
                               stack_id,
                               **kwargs):
        """
        [ HTTP: DELETE /stack/{id}/all ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/all"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteStackAllVersions.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/all', 'form_params': [], 'method_name': 'deleteStackAllVersions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /stack/{id}/all ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /stack/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchStacks(self,
                     **kwargs):
        """
        [ HTTP: GET /stack/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchStacks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack/search', 'form_params': [], 'method_name': 'searchStacks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def approve(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/approve ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/approve"
        path_params = {"id": stack_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createStack(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /stack ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack', 'form_params': [], 'method_name': 'createStack', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class artifacttype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def updateType(self,
                   artifacttype_id=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifacttype/%(id)s', 'form_params': [], 'method_name': 'updateType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /artifacttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getType(self,
                **kwargs):
        """
        [ HTTP: GET /artifacttype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getType.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'artifacttype', 'form_params': [], 'method_name': 'getType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifacttype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteDeployer(self,
                       artifacttype_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteDeployer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifacttype/%(id)s', 'form_params': [], 'method_name': 'deleteDeployer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /artifacttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTypeById(self,
                    artifacttype_id=None,
                    **kwargs):
        """
        [ HTTP: GET /artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTypeById.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'artifacttype/%(id)s', 'form_params': [], 'method_name': 'getTypeById', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /artifacttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'artifacttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class alias:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getAlias(self,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'alias/%(id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /alias/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAliasesXML(self,
                      **kwargs):
        """
        [ HTTP: GET /alias ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAliasesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'alias', 'form_params': [], 'method_name': 'getAliasesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /alias ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteAlias(self,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'alias/%(id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /alias/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateAlias(self,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'alias/%(id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /alias/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class variable:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def inputVariables(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /variable ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "variable"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    inputVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'variable', 'form_params': [], 'method_name': 'inputVariables', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /variable ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class projectrole:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getProjectRole(self,
                       projectrole_id=None,
                       **kwargs):
        """
        [ HTTP: GET /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'projectrole/%(id)s', 'form_params': [], 'method_name': 'getProjectRole', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /projectrole/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'projectrole/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /projectrole/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchRoles(self,
                    **kwargs):
        """
        [ HTTP: GET /projectrole/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchRoles.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole/search', 'form_params': [], 'method_name': 'searchRoles', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateProjectRole(self,
                          projectrole_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'projectrole/%(id)s', 'form_params': [], 'method_name': 'updateProjectRole', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /projectrole/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /projectrole/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /projectrole/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createProjectRole(self,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /projectrole ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole', 'form_params': [], 'method_name': 'createProjectRole', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /projectrole ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     projectrole_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /projectrole/{id}/export ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s/export"
        path_params = {"id": projectrole_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'projectrole/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteProjectRole(self,
                          projectrole_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'projectrole/%(id)s', 'form_params': [], 'method_name': 'deleteProjectRole', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /projectrole/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /projectrole/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getProjectRolesXML(self,
                           **kwargs):
        """
        [ HTTP: GET /projectrole ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getProjectRolesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole', 'form_params': [], 'method_name': 'getProjectRolesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class eula:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getEULA(self,
                **kwargs):
        """
        [ HTTP: GET /eula ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "eula"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEULA.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'eula', 'form_params': [], 'method_name': 'getEULA', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /eula ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def acceptEULA(self,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /eula/accept ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "eula/accept"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    acceptEULA.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'eula/accept', 'form_params': [], 'method_name': 'acceptEULA', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /eula/accept ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class configuration_resource:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /configuration/resource/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'configuration/resource/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/resource/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getResource(self,
                    resource_id=None,
                    **kwargs):
        """
        [ HTTP: GET /configuration/resource/{id} ]

        @param resource_id: resource_id
        @type resource_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s"
        path_params = {"id": resource_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/resource/%(id)s', 'form_params': [], 'method_name': 'getResource', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/resource/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getResourceXML(self,
                       resource_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/resource/{id} ]

        @param resource_id: resource_id
        @type resource_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s"
        path_params = {"id": resource_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getResourceXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/resource/%(id)s', 'form_params': [], 'method_name': 'getResourceXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/resource/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /configuration/resource/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/resource/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/resource/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     resource_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/resource/{id}/export ]

        @param resource_id: resource_id
        @type resource_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s/export"
        path_params = {"id": resource_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/resource/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/resource/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/resource/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/resource/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/resource/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchResources(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/resource/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchResources.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/resource/search', 'form_params': [], 'method_name': 'searchResources', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/resource/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteConfigurationResource(self,
                                    resource_id=None,
                                    **kwargs):
        """
        [ HTTP: DELETE /configuration/resource/{id} ]

        @param resource_id: resource_id
        @type resource_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s"
        path_params = {"id": resource_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteConfigurationResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/resource/%(id)s', 'form_params': [], 'method_name': 'deleteConfigurationResource', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /configuration/resource/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'resource_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getResources(self,
                     **kwargs):
        """
        [ HTTP: GET /configuration/resource ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getResources.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/resource', 'form_params': [], 'method_name': 'getResources', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/resource ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class propertytype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /propertytype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'propertytype/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertytype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createPropertyTypeXML(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /propertytype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createPropertyTypeXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype', 'form_params': [], 'method_name': 'createPropertyTypeXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /propertytype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     propertytype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /propertytype/{id}/export ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s/export"
        path_params = {"id": propertytype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'propertytype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /propertytype/{id}/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype/%(id)s/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertytype/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deletePropertyType(self,
                           propertytype_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deletePropertyType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertytype/%(id)s', 'form_params': [], 'method_name': 'deletePropertyType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /propertytype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPropertyTypesXML(self,
                            **kwargs):
        """
        [ HTTP: GET /propertytype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPropertyTypesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype', 'form_params': [], 'method_name': 'getPropertyTypesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPropertyType(self,
                        propertytype_id=None,
                        **kwargs):
        """
        [ HTTP: GET /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPropertyType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertytype/%(id)s', 'form_params': [], 'method_name': 'getPropertyType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /propertytype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updatePropertyType(self,
                           propertytype_id=None,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updatePropertyType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertytype/%(id)s', 'form_params': [], 'method_name': 'updatePropertyType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertytype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class authtype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def searchTypes(self,
                    **kwargs):
        """
        [ HTTP: GET /authtype/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authtype/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'authtype/search', 'form_params': [], 'method_name': 'searchTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /authtype/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getAuthenticationType(self,
                              authtype_id=None,
                              **kwargs):
        """
        [ HTTP: GET /authtype/{id} ]

        @param authtype_id: authtype_id
        @type authtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authtype/%(id)s"
        path_params = {"id": authtype_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getAuthenticationType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'authtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'authtype/%(id)s', 'form_params': [], 'method_name': 'getAuthenticationType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /authtype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'authtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getTypes(self,
                 **kwargs):
        """
        [ HTTP: GET /authtype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authtype"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'authtype', 'form_params': [], 'method_name': 'getTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /authtype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class networkinterface:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getNetwork(self,
                   networkinterface_id=None,
                   **kwargs):
        """
        [ HTTP: GET /networkinterface/{id} ]

        @param networkinterface_id: networkinterface_id
        @type networkinterface_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkinterface/%(id)s"
        path_params = {"id": networkinterface_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkinterface_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkinterface/%(id)s', 'form_params': [], 'method_name': 'getNetwork', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkinterface/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkinterface_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class onboard:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getSearchFields(self,
                        field_id=None,
                        **kwargs):
        """
        [ HTTP: GET /onboard/search/field/{id} ]

        @param field_id: field_id
        @type field_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/search/field/%(id)s"
        path_params = {"id": field_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSearchFields.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'field_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'onboard/search/field/%(id)s', 'form_params': [], 'method_name': 'getSearchFields', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /onboard/search/field/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'field_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchUnmanagedInstancesByCloud(self,
                                        search_cloudId=None,
                                        **kwargs):
        """
        [ HTTP: GET /onboard/search/{cloudId} ]

        @param search_cloudId: search_cloudId
        @type search_cloudId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/search/%(cloudId)s"
        path_params = {"cloudId": search_cloudId}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchUnmanagedInstancesByCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'search_cloudId', 'kind': 'xs:int', 'required': False, 'name': 'cloudId'}], 'method_path': 'onboard/search/%(cloudId)s', 'form_params': [], 'method_name': 'searchUnmanagedInstancesByCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /onboard/search/{cloudId} ]', 'method_params': [{'defaultValue': None, 'alias': 'search_cloudId', 'kind': 'xs:int', 'required': False, 'name': 'cloudId'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getOnboardMeta(self,
                       **kwargs):
        """
        [ HTTP: GET /onboard/meta ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/meta"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getOnboardMeta.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'onboard/meta', 'form_params': [], 'method_name': 'getOnboardMeta', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /onboard/meta ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchUnmanagedInstances(self,
                                 **kwargs):
        """
        [ HTTP: GET /onboard/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchUnmanagedInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'onboard/search', 'form_params': [], 'method_name': 'searchUnmanagedInstances', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /onboard/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getOnboardMetaById(self,
                           meta_id=None,
                           **kwargs):
        """
        [ HTTP: GET /onboard/meta/{id} ]

        @param meta_id: meta_id
        @type meta_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/meta/%(id)s"
        path_params = {"id": meta_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getOnboardMetaById.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'meta_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'onboard/meta/%(id)s', 'form_params': [], 'method_name': 'getOnboardMetaById', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /onboard/meta/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'meta_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def preflight(self,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /onboard/check ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/check"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    preflight.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'onboard/check', 'form_params': [], 'method_name': 'preflight', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /onboard/check ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def onboard(self,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /onboard ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    onboard.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'onboard', 'form_params': [], 'method_name': 'onboard', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /onboard ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getClouds(self,
                  **kwargs):
        """
        [ HTTP: GET /onboard/cloud ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/cloud"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getClouds.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'onboard/cloud', 'form_params': [], 'method_name': 'getClouds', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /onboard/cloud ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class customcontainer:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importIDActionXML(self,
                          customcontainer_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/import ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/import"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getSecurity(self,
                    customcontainer_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/security/{security_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def removePolicy(self,
                     customcontainer_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/policy/{policyid} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy/%(policyid)s"
        path_params = {"id": customcontainer_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'customcontainer/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchPolicyAssignments(self,
                                customcontainer_id,
                                **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/policyassignment/search ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policyassignment/search"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     customcontainer_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/export ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/export"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getChildCustomContainers(self,
                                 customcontainer_id,
                                 **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/customcontainer ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customcontainer"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getChildCustomContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/customcontainer', 'form_params': [], 'method_name': 'getChildCustomContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/customcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchContainers(self,
                         **kwargs):
        """
        [ HTTP: GET /customcontainer/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer/search', 'form_params': [], 'method_name': 'searchContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCustomContainer(self,
                           customcontainer_id=None,
                           **kwargs):
        """
        [ HTTP: GET /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s', 'form_params': [], 'method_name': 'getCustomContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUserGroup(self,
                                customcontainer_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def attachPolicy(self,
                     customcontainer_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/policy/{policyid} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy/%(policyid)s"
        path_params = {"id": customcontainer_id,
                       "policyid": policyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'customcontainer/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurity(self,
                    customcontainer_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCustomItems(self,
                       customcontainer_id,
                       **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/customitems ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customitems"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCustomItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/customitems', 'form_params': [], 'method_name': 'getCustomItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/customitems ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteCustomContainer(self,
                              customcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s', 'form_params': [], 'method_name': 'deleteCustomContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityRights(self,
                             customcontainer_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityUser(self,
                           customcontainer_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/user/{user_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "user_id": user_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurity(self,
                       customcontainer_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCustomContainers(self,
                            **kwargs):
        """
        [ HTTP: GET /customcontainer ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCustomContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer', 'form_params': [], 'method_name': 'getCustomContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUserGroup(self,
                             customcontainer_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/usergroup ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importIDAction(self,
                       customcontainer_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/import ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/import"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityAccessRight(self,
                               customcontainer_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCustomContainer(self,
                              customcontainer_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s', 'form_params': [], 'method_name': 'updateCustomContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityRights(self,
                          customcontainer_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/rights ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /customcontainer/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /customcontainer/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'customcontainer/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCustomItems(self,
                          customcontainer_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/customitems ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customitems"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCustomItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/customitems', 'form_params': [], 'method_name': 'updateCustomItems', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/customitems ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSecurityUser(self,
                        customcontainer_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/user ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/user"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getPolicies(self,
                    customcontainer_id,
                    **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/policy ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy"
        path_params = {"id": customcontainer_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /customcontainer/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteSecurityAccessRight(self,
                                  customcontainer_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createCustomContainer(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /customcontainer ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer', 'form_params': [], 'method_name': 'createCustomContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class credential:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getCredential2(self,
                       credential_id,
                       **kwargs):
        """
        [ HTTP: GET /credential/{id}/decrypt ]

        @param credential_id: credential_id
        @type credential_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/decrypt"
        path_params = {"id": credential_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCredential2.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'credential/%(id)s/decrypt', 'form_params': [], 'method_name': 'getCredential2', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/{id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCredential(self,
                      credential_id=None,
                      **kwargs):
        """
        [ HTTP: GET /credential/{id} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s"
        path_params = {"id": credential_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCredential.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'credential/%(id)s', 'form_params': [], 'method_name': 'getCredential', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCredential(self,
                         credential_id,
                         encrypt_fieldname=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /credential/{id}/encrypt/{fieldname} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param encrypt_fieldname: encrypt_fieldname
        @type encrypt_fieldname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/encrypt/%(fieldname)s"
        path_params = {"id": credential_id,
                       "fieldname": encrypt_fieldname}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCredential.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'encrypt_fieldname', 'kind': 'xs:string', 'required': False, 'name': 'fieldname'}], 'method_path': 'credential/%(id)s/encrypt/%(fieldname)s', 'form_params': [], 'method_name': 'updateCredential', 'custom_headers': {'Content-Type': 'text/plain'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /credential/{id}/encrypt/{fieldname} ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'encrypt_fieldname', 'kind': 'xs:string', 'required': False, 'name': 'fieldname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCredential2Field(self,
                            credential_id,
                            decrypt_field=None,
                            **kwargs):
        """
        [ HTTP: GET /credential/{id}/decrypt/{field} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param decrypt_field: decrypt_field
        @type decrypt_field: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/decrypt/%(field)s"
        path_params = {"id": credential_id,
                       "field": decrypt_field}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCredential2Field.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'decrypt_field', 'kind': 'xs:string', 'required': False, 'name': 'field'}], 'method_path': 'credential/%(id)s/decrypt/%(field)s', 'form_params': [], 'method_name': 'getCredential2Field', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/{id}/decrypt/{field} ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'decrypt_field', 'kind': 'xs:string', 'required': False, 'name': 'field'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCredentials(self,
                          **kwargs):
        """
        [ HTTP: GET /credential/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCredentials.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'credential/search', 'form_params': [], 'method_name': 'searchCredentials', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class cloud:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def getEffectiveModels(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/model/effective ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/model/effective"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getEffectiveModels.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/model/effective', 'form_params': [], 'method_name': 'getEffectiveModels', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/model/effective ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudImagesXML(self,
                             cloud_id,
                             **kwargs):
        """
        [ HTTP: GET /cloud/{id}/image/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/image/search"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudImagesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/image/search', 'form_params': [], 'method_name': 'searchCloudImagesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/image/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCloudKeysXML(self,
                        cloud_id,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCloudKeysXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/key', 'form_params': [], 'method_name': 'getCloudKeysXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/key ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     cloud_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /cloud/{id}/export ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/export"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariableXML(self,
                       cloud_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariableXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'getVariableXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateVariable(self,
                       cloud_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /cloud/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudVolumes(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/volume/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/volume/search"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudVolumes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/volume/search', 'form_params': [], 'method_name': 'searchCloudVolumes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/volume/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteVariable(self,
                       cloud_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createVariable(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/variable ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateCloud(self,
                    cloud_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloud/%(id)s', 'form_params': [], 'method_name': 'updateCloud', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /cloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudNetworks(self,
                            cloud_id,
                            **kwargs):
        """
        [ HTTP: GET /cloud/{id}/network/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/network/search"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudNetworks.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/network/search', 'form_params': [], 'method_name': 'searchCloudNetworks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/network/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createRepository(self,
                         cloud_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /cloud/{id}/repository ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/repository"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/repository', 'form_params': [], 'method_name': 'createRepository', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/repository ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /cloud/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCloudKey(self,
                    cloud_id,
                    keyid=None,
                    **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key/{keyid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param keyid: keyid
        @type keyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/%(keyid)s"
        path_params = {"id": cloud_id,
                       "keyid": keyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCloudKey.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}], 'method_path': 'cloud/%(id)s/key/%(keyid)s', 'form_params': [], 'method_name': 'getCloudKey', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/key/{keyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getRepositories(self,
                        cloud_id,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/repository ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/repository"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getRepositories.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/repository', 'form_params': [], 'method_name': 'getRepositories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/repository ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudNetworkServices(self,
                                   cloud_id,
                                   **kwargs):
        """
        [ HTTP: GET /cloud/{id}/networkservice/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice/search"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudNetworkServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/networkservice/search', 'form_params': [], 'method_name': 'searchCloudNetworkServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/networkservice/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCloudsXML(self,
                     **kwargs):
        """
        [ HTTP: GET /cloud ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCloudsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud', 'form_params': [], 'method_name': 'getCloudsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteCloud(self,
                    cloud_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloud/%(id)s', 'form_params': [], 'method_name': 'deleteCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createLocation(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/location ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/location', 'form_params': [], 'method_name': 'createLocation', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/location ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworkServices(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/networkservice ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworkServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/networkservice', 'form_params': [], 'method_name': 'getNetworkServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/networkservice ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def syncCloud(self,
                  cloud_id,
                  excludes=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /cloud/{id}/resync ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param excludes: excludes
        @type excludes: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/resync"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {"excludes": excludes}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    syncCloud.context = {'query_params': [{'defaultValue': None, 'alias': 'excludes', 'kind': 'xs:string', 'required': False, 'name': 'excludes'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/resync', 'form_params': [], 'method_name': 'syncCloud', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/resync ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'excludes', 'kind': 'xs:string', 'required': False, 'name': 'excludes'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getNetworks(self,
                    cloud_id,
                    **kwargs):
        """
        [ HTTP: GET /cloud/{id}/network ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/network"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getNetworks.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/network', 'form_params': [], 'method_name': 'getNetworks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/network ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchClouds(self,
                     **kwargs):
        """
        [ HTTP: GET /cloud/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchClouds.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud/search', 'form_params': [], 'method_name': 'searchClouds', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getLocations(self,
                     cloud_id,
                     **kwargs):
        """
        [ HTTP: GET /cloud/{id}/location ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getLocations.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/location', 'form_params': [], 'method_name': 'getLocations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/location ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudKeysXML(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/search"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudKeysXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/key/search', 'form_params': [], 'method_name': 'searchCloudKeysXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/key/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createNetworkService(self,
                             cloud_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /cloud/{id}/networkservice ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/networkservice', 'form_params': [], 'method_name': 'createNetworkService', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/networkservice ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchCloudLocations(self,
                             cloud_id,
                             **kwargs):
        """
        [ HTTP: GET /cloud/{id}/location/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location/search"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchCloudLocations.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/location/search', 'form_params': [], 'method_name': 'searchCloudLocations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/location/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createCloudKey(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/key ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createCloudKey.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/key', 'form_params': [], 'method_name': 'createCloudKey', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/key ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def createCloudXML(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    createCloudXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud', 'form_params': [], 'method_name': 'createCloudXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteLocation(self,
                       cloud_id,
                       location_locid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/location/{locid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param location_locid: location_locid
        @type location_locid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location/%(locid)s"
        path_params = {"id": cloud_id,
                       "locid": location_locid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'location_locid', 'kind': 'xs:int', 'required': False, 'name': 'locid'}], 'method_path': 'cloud/%(id)s/location/%(locid)s', 'form_params': [], 'method_name': 'deleteLocation', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id}/location/{locid} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'location_locid', 'kind': 'xs:int', 'required': False, 'name': 'locid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteCloudKey(self,
                       cloud_id,
                       keyid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/key/{keyid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param keyid: keyid
        @type keyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/%(keyid)s"
        path_params = {"id": cloud_id,
                       "keyid": keyid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteCloudKey.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}], 'method_path': 'cloud/%(id)s/key/%(keyid)s', 'form_params': [], 'method_name': 'deleteCloudKey', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id}/key/{keyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getVariablesXML(self,
                        cloud_id,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getVariablesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/variable', 'form_params': [], 'method_name': 'getVariablesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getCloud(self,
                 cloud_id=None,
                 **kwargs):
        """
        [ HTTP: GET /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloud/%(id)s', 'form_params': [], 'method_name': 'getCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class dhcpoptions:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def exportAction(self,
                     dhcpoptions_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /dhcpoptions/{id}/export ]

        @param dhcpoptions_id: dhcpoptions_id
        @type dhcpoptions_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/%(id)s/export"
        path_params = {"id": dhcpoptions_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'dhcpoptions/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /dhcpoptions/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'dhcpoptions/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDhcpOptions(self,
                       dhcpoptions_id=None,
                       **kwargs):
        """
        [ HTTP: GET /dhcpoptions/{id} ]

        @param dhcpoptions_id: dhcpoptions_id
        @type dhcpoptions_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/%(id)s"
        path_params = {"id": dhcpoptions_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDhcpOptions.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'dhcpoptions/%(id)s', 'form_params': [], 'method_name': 'getDhcpOptions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getDhcpOptionsList(self,
                           **kwargs):
        """
        [ HTTP: GET /dhcpoptions ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getDhcpOptionsList.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'dhcpoptions', 'form_params': [], 'method_name': 'getDhcpOptionsList', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class usergroup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download    
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /usergroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'usergroup/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteUser(self,
                   usergroup_id,
                   userid=None,
                   **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id}/user/{userid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param userid: userid
        @type userid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/user/%(userid)s"
        path_params = {"id": usergroup_id,
                       "userid": userid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}], 'method_path': 'usergroup/%(id)s/user/%(userid)s', 'form_params': [], 'method_name': 'deleteUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /usergroup/{id}/user/{userid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getUserGroupsXML(self,
                         **kwargs):
        """
        [ HTTP: GET /usergroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getUserGroupsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup', 'form_params': [], 'method_name': 'getUserGroupsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def deleteUserGroup(self,
                        usergroup_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    deleteUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'usergroup/%(id)s', 'form_params': [], 'method_name': 'deleteUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /usergroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addUser(self,
                usergroup_id,
                userid=None,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /usergroup/{id}/user/{userid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param userid: userid
        @type userid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/user/%(userid)s"
        path_params = {"id": usergroup_id,
                       "userid": userid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}], 'method_path': 'usergroup/%(id)s/user/%(userid)s', 'form_params': [], 'method_name': 'addUser', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/{id}/user/{userid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addUserGroup(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /usergroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup', 'form_params': [], 'method_name': 'addUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def delSubGroup(self,
                    usergroup_id,
                    group_subid=None,
                    **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id}/group/{subid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param group_subid: group_subid
        @type group_subid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/group/%(subid)s"
        path_params = {"id": usergroup_id,
                       "subid": group_subid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    delSubGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}], 'method_path': 'usergroup/%(id)s/group/%(subid)s', 'form_params': [], 'method_name': 'delSubGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /usergroup/{id}/group/{subid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def addSubGroup(self,
                    usergroup_id,
                    group_subid=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /usergroup/{id}/group/{subid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param group_subid: group_subid
        @type group_subid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/group/%(subid)s"
        path_params = {"id": usergroup_id,
                       "subid": group_subid}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    addSubGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}], 'method_path': 'usergroup/%(id)s/group/%(subid)s', 'form_params': [], 'method_name': 'addSubGroup', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/{id}/group/{subid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /usergroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/import"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def updateUserGroup(self,
                        usergroup_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None and isinstance(data, AbstractProxy):
            data = str(data) #AbstractProxy.__str__ should return the proper xml for the POST/PUT requests

        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    updateUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'usergroup/%(id)s', 'form_params': [], 'method_name': 'updateUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def searchUserGroups(self,
                         **kwargs):
        """
        [ HTTP: GET /usergroup/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/search"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    searchUserGroups.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup/search', 'form_params': [], 'method_name': 'searchUserGroups', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAction(self,
                     usergroup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /usergroup/{id}/export ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/export"
        path_params = {"id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {"recursive": recursive}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'usergroup/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /usergroup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/export"
        path_params = {}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download    
    def getUserGroup(self,
                     usergroup_id=None,
                     **kwargs):
        """
        [ HTTP: GET /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}
        
        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if isinstance(v, AbstractProxy):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        
        
        query_params = kwargs
        wadl_query_params = {}
        
        query_params = query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)
        
                
        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204 
            raise RESTException(response)
        
        result = response
        
        return result
    getUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'usergroup/%(id)s', 'form_params': [], 'method_name': 'getUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}
