# === AUTO-GENERATED - DO NOT EDIT ===

# --------------------------------------------------------------------------
#           ***********************************************
#           ***  THIS IS GENERATED CODE: DO NOT MODIFY  ***
#           ***********************************************
#
#             Copyright (c) 2009-2014 CSC, Incorporated
#                      All Rights Reserved
#   THIS WORK CONTAINS CONFIDENTIAL PROPPRIETARY INFORMATION AND
#   TRADE SECRETS WHICH ARE THE PROPERTY OF CSC.  ALL USE,
#   DISCLOSURE AND/OR REPRODUCTION NOT EXPRESSLY AUTHORIZED BY
#   CSC IS PROHIBITED.
# --------------------------------------------------------------------------

"""
Web service API methods. This module is fully auto-generated
"""
COMPONENT_NAME = 'agility-client'
from logger import getLogger
logger = getLogger(COMPONENT_NAME)
from core.restclient.connection import RESTException
from core.http.decorators import download

class permissiontype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getPermissionType(self,
                          permissiontype_id=None,
                          **kwargs):
        """
        [ HTTP: GET /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'permissiontype/%(id)s', 'form_params': [], 'method_name': 'getPermissionType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /permissiontype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deletePermissionType(self,
                             permissiontype_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'permissiontype/%(id)s', 'form_params': [], 'method_name': 'deletePermissionType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /permissiontype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updatePermissionType(self,
                             permissiontype_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'permissiontype/%(id)s', 'form_params': [], 'method_name': 'updatePermissionType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /permissiontype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'permissiontype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class credential:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getCredential2(self,
                       credential_id,
                       **kwargs):
        """
        [ HTTP: GET /credential/{id}/decrypt ]

        @param credential_id: credential_id
        @type credential_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/decrypt"
        path_params = {"id": credential_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCredential2.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'credential/%(id)s/decrypt', 'form_params': [], 'method_name': 'getCredential2', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/{id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCredential(self,
                      credential_id=None,
                      **kwargs):
        """
        [ HTTP: GET /credential/{id} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s"
        path_params = {"id": credential_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCredential.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'credential/%(id)s', 'form_params': [], 'method_name': 'getCredential', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateCredential(self,
                         credential_id,
                         encrypt_fieldname=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /credential/{id}/encrypt/{fieldname} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param encrypt_fieldname: encrypt_fieldname
        @type encrypt_fieldname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/encrypt/%(fieldname)s"
        path_params = {"id": credential_id,
                       "fieldname": encrypt_fieldname}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCredential.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'encrypt_fieldname', 'kind': 'xs:string', 'required': False, 'name': 'fieldname'}], 'method_path': 'credential/%(id)s/encrypt/%(fieldname)s', 'form_params': [], 'method_name': 'updateCredential', 'custom_headers': {'Content-Type': 'text/plain'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /credential/{id}/encrypt/{fieldname} ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'encrypt_fieldname', 'kind': 'xs:string', 'required': False, 'name': 'fieldname'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCredential2Field(self,
                            credential_id,
                            decrypt_field=None,
                            **kwargs):
        """
        [ HTTP: GET /credential/{id}/decrypt/{field} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param decrypt_field: decrypt_field
        @type decrypt_field: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/decrypt/%(field)s"
        path_params = {"id": credential_id,
                       "field": decrypt_field}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCredential2Field.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'decrypt_field', 'kind': 'xs:string', 'required': False, 'name': 'field'}], 'method_path': 'credential/%(id)s/decrypt/%(field)s', 'form_params': [], 'method_name': 'getCredential2Field', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /credential/{id}/decrypt/{field} ]', 'method_params': [{'defaultValue': None, 'alias': 'credential_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'decrypt_field', 'kind': 'xs:string', 'required': False, 'name': 'field'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class policy:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def clearCache(self,
                   **kwargs):
        """
        [ HTTP: DELETE /policy/cache ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/cache"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clearCache.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/cache', 'form_params': [], 'method_name': 'clearCache', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /policy/cache ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkOut(self,
                 policy_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /policy/{id}/checkout ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/checkout"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkIn(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/checkin ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/checkin"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEffectiveProtocol(self,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /policy/protocol/effective ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/protocol/effective"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveProtocol.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/protocol/effective', 'form_params': [], 'method_name': 'getEffectiveProtocol', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /policy/protocol/effective ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicyMetas(self,
                       **kwargs):
        """
        [ HTTP: GET /policy/meta ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/meta"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicyMetas.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/meta', 'form_params': [], 'method_name': 'getPolicyMetas', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/meta ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicies(self,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /policy ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deletePolicy(self,
                     policy_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'policy/%(id)s', 'form_params': [], 'method_name': 'deletePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /policy/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicyMeta(self,
                      meta_type=None,
                      **kwargs):
        """
        [ HTTP: GET /policy/meta/{type} ]

        @param meta_type: meta_type
        @type meta_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/meta/%(type)s"
        path_params = {"type": meta_type}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicyMeta.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'meta_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'policy/meta/%(type)s', 'form_params': [], 'method_name': 'getPolicyMeta', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/meta/{type} ]', 'method_params': [{'defaultValue': None, 'alias': 'meta_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updatePolicy(self,
                     policy_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'policy/%(id)s', 'form_params': [], 'method_name': 'updatePolicy', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /policy/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createPolicy(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /policy ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy', 'form_params': [], 'method_name': 'createPolicy', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def reject(self,
               policy_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /policy/{id}/reject ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/reject"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     policy_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /policy/{id}/export ]

        @param policy_id: policy_id
        @type policy_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/export"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPolicies(self,
                       **kwargs):
        """
        [ HTTP: GET /policy/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/search', 'form_params': [], 'method_name': 'searchPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /policy/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'policy/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicy(self,
                  policy_id=None,
                  **kwargs):
        """
        [ HTTP: GET /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'policy/%(id)s', 'form_params': [], 'method_name': 'getPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /policy/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def approve(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/approve ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/approve"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'policy/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /policy/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'policy_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class networkservice:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /networkservice/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'networkservice/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservice/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getNetworkService(self,
                          networkservice_id=None,
                          **kwargs):
        """
        [ HTTP: GET /networkservice/{id} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id)s"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservice/%(id)s', 'form_params': [], 'method_name': 'getNetworkService', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getNetworkServicesByType(self,
                                 networkservice_type=None,
                                 **kwargs):
        """
        [ HTTP: GET /networkservice/{type: (collector)|(dhcpd)|(kmip)|(ddns)|(proxy)} ]

        @param networkservice_type: networkservice_type
        @type networkservice_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(type: (collector)|(dhcpd)|(kmip)|(ddns)|(proxy))s"
        path_params = {"type": networkservice_type}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServicesByType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'networkservice/%(type: (collector)|(dhcpd)|(kmip)|(ddns)|(proxy))s', 'form_params': [], 'method_name': 'getNetworkServicesByType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/{type: (collector)|(dhcpd)|(kmip)|(ddns)|(proxy)} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     networkservice_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /networkservice/{id}/export ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id)s/export"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'networkservice/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /networkservice/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservice/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservice/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateNetworkService(self,
                             networkservice_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /networkservice/{id} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id)s"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservice/%(id)s', 'form_params': [], 'method_name': 'updateNetworkService', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /networkservice/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteNetworkService(self,
                             networkservice_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /networkservice/{id} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id)s"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'networkservice/%(id)s', 'form_params': [], 'method_name': 'deleteNetworkService', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /networkservice/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'networkservice_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getNetworkServices(self,
                           **kwargs):
        """
        [ HTTP: GET /networkservice ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservice', 'form_params': [], 'method_name': 'getNetworkServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /networkservice/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'networkservice/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /networkservice/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class task:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTasksXML(self,
                    **kwargs):
        """
        [ HTTP: GET /task ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTasksXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'task', 'form_params': [], 'method_name': 'getTasksXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchTopTasks(self,
                       **kwargs):
        """
        [ HTTP: GET /task/search/top ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/search/top"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTopTasks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'task/search/top', 'form_params': [], 'method_name': 'searchTopTasks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task/search/top ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTask(self,
                task_id=None,
                **kwargs):
        """
        [ HTTP: GET /task/{id} ]

        @param task_id: task_id
        @type task_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTask.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'task/%(id)s', 'form_params': [], 'method_name': 'getTask', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTaskChildren(self,
                        task_id,
                        **kwargs):
        """
        [ HTTP: GET /task/{id}/task ]

        @param task_id: task_id
        @type task_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/task"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTaskChildren.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'task/%(id)s/task', 'form_params': [], 'method_name': 'getTaskChildren', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /task/{id}/task ]', 'method_params': [{'defaultValue': None, 'alias': 'task_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class acl:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAclsXML(self,
                   **kwargs):
        """
        [ HTTP: GET /acl ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "acl"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAclsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'acl', 'form_params': [], 'method_name': 'getAclsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /acl ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAcl(self,
               acl_id=None,
               **kwargs):
        """
        [ HTTP: GET /acl/{id} ]

        @param acl_id: acl_id
        @type acl_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "acl/%(id)s"
        path_params = {"id": acl_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAcl.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'acl_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'acl/%(id)s', 'form_params': [], 'method_name': 'getAcl', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /acl/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'acl_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class scriptclasspath:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteScriptClasspath(self,
                              scriptclasspath_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /scriptclasspath/{id} ]

        @param scriptclasspath_id: scriptclasspath_id
        @type scriptclasspath_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath/%(id)s"
        path_params = {"id": scriptclasspath_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteScriptClasspath.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptclasspath/%(id)s', 'form_params': [], 'method_name': 'deleteScriptClasspath', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /scriptclasspath/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createScriptClasspath(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /scriptclasspath ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScriptClasspath.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptclasspath', 'form_params': [], 'method_name': 'createScriptClasspath', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /scriptclasspath ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScriptClasspath(self,
                           scriptclasspath_id=None,
                           **kwargs):
        """
        [ HTTP: GET /scriptclasspath/{id} ]

        @param scriptclasspath_id: scriptclasspath_id
        @type scriptclasspath_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath/%(id)s"
        path_params = {"id": scriptclasspath_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptClasspath.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'scriptclasspath/%(id)s', 'form_params': [], 'method_name': 'getScriptClasspath', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptclasspath/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'scriptclasspath_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScriptClasspathsXML(self,
                               **kwargs):
        """
        [ HTTP: GET /scriptclasspath ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptClasspathsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptclasspath', 'form_params': [], 'method_name': 'getScriptClasspathsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptclasspath ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchScriptClasspaths(self,
                               **kwargs):
        """
        [ HTTP: GET /scriptclasspath/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptclasspath/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchScriptClasspaths.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'scriptclasspath/search', 'form_params': [], 'method_name': 'searchScriptClasspaths', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /scriptclasspath/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class location:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateLocation(self,
                       location_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /location/{id} ]

        @param location_id: location_id
        @type location_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'location/%(id)s', 'form_params': [], 'method_name': 'updateLocation', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /location/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     location_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /location/{id}/export ]

        @param location_id: location_id
        @type location_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s/export"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'location/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getLocation(self,
                    location_id=None,
                    **kwargs):
        """
        [ HTTP: GET /location/{id} ]

        @param location_id: location_id
        @type location_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'location/%(id)s', 'form_params': [], 'method_name': 'getLocation', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'location_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getLocationsXML(self,
                        **kwargs):
        """
        [ HTTP: GET /location ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocationsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'location', 'form_params': [], 'method_name': 'getLocationsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /location/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'location/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /location/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class security:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getEffectiveRights(self,
                           security_type,
                           id=None,
                           **kwargs):
        """
        [ HTTP: GET /security/{type}/{id} ]

        @param security_type: security_type
        @type security_type: str
        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/%(type)s/%(id)s"
        path_params = {"type": security_type,
                       "id": id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'security/%(type)s/%(id)s', 'form_params': [], 'method_name': 'getEffectiveRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/{type}/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkRight(self,
                   security_type,
                   id,
                   rightid=None,
                   **kwargs):
        """
        [ HTTP: GET /security/{type}/{id}/right/{rightid} ]

        @param security_type: security_type
        @type security_type: str
        @param id: id
        @type id: str
        @param rightid: rightid
        @type rightid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/%(type)s/%(id)s/right/%(rightid)s"
        path_params = {"type": security_type,
                       "id": id,
                       "rightid": rightid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}], 'method_path': 'security/%(type)s/%(id)s/right/%(rightid)s', 'form_params': [], 'method_name': 'checkRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/{type}/{id}/right/{rightid} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def clearCache(self,
                   **kwargs):
        """
        [ HTTP: DELETE /security/cache ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/cache"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clearCache.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'security/cache', 'form_params': [], 'method_name': 'clearCache', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /security/cache ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkGlobalRight(self,
                         rightid=None,
                         **kwargs):
        """
        [ HTTP: GET /security/global/right/{rightid} ]

        @param rightid: rightid
        @type rightid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/global/right/%(rightid)s"
        path_params = {"rightid": rightid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkGlobalRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}], 'method_path': 'security/global/right/%(rightid)s', 'form_params': [], 'method_name': 'checkGlobalRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/global/right/{rightid} ]', 'method_params': [{'defaultValue': None, 'alias': 'rightid', 'kind': 'xs:string', 'required': False, 'name': 'rightid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEffectiveGlobalRights(self,
                                 **kwargs):
        """
        [ HTTP: GET /security/global ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/global"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveGlobalRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'security/global', 'form_params': [], 'method_name': 'getEffectiveGlobalRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/global ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPermittedTree(self,
                         tree_type,
                         action=None,
                         **kwargs):
        """
        [ HTTP: GET /security/tree/{type}/{action} ]

        @param tree_type: tree_type
        @type tree_type: str
        @param action: action
        @type action: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/tree/%(type)s/%(action)s"
        path_params = {"type": tree_type,
                       "action": action}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPermittedTree.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'tree_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'action', 'kind': 'xs:string', 'required': False, 'name': 'action'}], 'method_path': 'security/tree/%(type)s/%(action)s', 'form_params': [], 'method_name': 'getPermittedTree', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /security/tree/{type}/{action} ]', 'method_params': [{'defaultValue': None, 'alias': 'tree_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'action', 'kind': 'xs:string', 'required': False, 'name': 'action'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class usergroup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /usergroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'usergroup/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteUser(self,
                   usergroup_id,
                   userid=None,
                   **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id}/user/{userid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param userid: userid
        @type userid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/user/%(userid)s"
        path_params = {"id": usergroup_id,
                       "userid": userid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}], 'method_path': 'usergroup/%(id)s/user/%(userid)s', 'form_params': [], 'method_name': 'deleteUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /usergroup/{id}/user/{userid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getUserGroupsXML(self,
                         **kwargs):
        """
        [ HTTP: GET /usergroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUserGroupsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup', 'form_params': [], 'method_name': 'getUserGroupsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteUserGroup(self,
                        usergroup_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'usergroup/%(id)s', 'form_params': [], 'method_name': 'deleteUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /usergroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addUser(self,
                usergroup_id,
                userid=None,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /usergroup/{id}/user/{userid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param userid: userid
        @type userid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/user/%(userid)s"
        path_params = {"id": usergroup_id,
                       "userid": userid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}], 'method_path': 'usergroup/%(id)s/user/%(userid)s', 'form_params': [], 'method_name': 'addUser', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/{id}/user/{userid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'userid', 'kind': 'xs:int', 'required': False, 'name': 'userid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addUserGroup(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /usergroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup', 'form_params': [], 'method_name': 'addUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def delSubGroup(self,
                    usergroup_id,
                    group_subid=None,
                    **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id}/group/{subid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param group_subid: group_subid
        @type group_subid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/group/%(subid)s"
        path_params = {"id": usergroup_id,
                       "subid": group_subid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    delSubGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}], 'method_path': 'usergroup/%(id)s/group/%(subid)s', 'form_params': [], 'method_name': 'delSubGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /usergroup/{id}/group/{subid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSubGroup(self,
                    usergroup_id,
                    group_subid=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /usergroup/{id}/group/{subid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param group_subid: group_subid
        @type group_subid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/group/%(subid)s"
        path_params = {"id": usergroup_id,
                       "subid": group_subid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSubGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}], 'method_path': 'usergroup/%(id)s/group/%(subid)s', 'form_params': [], 'method_name': 'addSubGroup', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/{id}/group/{subid} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'group_subid', 'kind': 'xs:int', 'required': False, 'name': 'subid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /usergroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateUserGroup(self,
                        usergroup_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'usergroup/%(id)s', 'form_params': [], 'method_name': 'updateUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /usergroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchUserGroups(self,
                         **kwargs):
        """
        [ HTTP: GET /usergroup/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchUserGroups.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup/search', 'form_params': [], 'method_name': 'searchUserGroups', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     usergroup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /usergroup/{id}/export ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/export"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'usergroup/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /usergroup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'usergroup/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getUserGroup(self,
                     usergroup_id=None,
                     **kwargs):
        """
        [ HTTP: GET /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'usergroup/%(id)s', 'form_params': [], 'method_name': 'getUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /usergroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class environment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importIDActionXML(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /environment/{id}/import ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/import"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSecurity(self,
                    environment_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/security/{security_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removePolicy(self,
                     environment_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/policy/{policyid} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy/%(policyid)s"
        path_params = {"id": environment_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'environment/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPolicyAssignments(self,
                                environment_id,
                                **kwargs):
        """
        [ HTTP: GET /environment/{id}/policyassignment/search ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policyassignment/search"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAlias(self,
                    environment_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTopologyFixedOrder(self,
                                 environment_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /environment/{id}/fixedorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/fixedorder/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopologyFixedOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/fixedorder/topology', 'form_params': [], 'method_name': 'createTopologyFixedOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/fixedorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def rebootEnvironment(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/restart ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/restart"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/restart', 'form_params': [], 'method_name': 'rebootEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createScript(self,
                     environment_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /environment/{id}/script ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/script"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/script', 'form_params': [], 'method_name': 'createScript', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     environment_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /environment/{id}/export ]

        @param environment_id: environment_id
        @type environment_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/export"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariableXML(self,
                       environment_env_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{env_id}/variable/{variable_id} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(env_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'getVariableXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{env_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAlias(self,
                    environment_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /environment/{id}/alias ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/alias', 'form_params': [], 'method_name': 'createAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateVariable(self,
                       environment_env_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /environment/{env_id}/variable/{variable_id} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(env_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{env_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEnvironmentsXML(self,
                           **kwargs):
        """
        [ HTTP: GET /environment ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironmentsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environment', 'form_params': [], 'method_name': 'getEnvironmentsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVariable(self,
                       environment_env_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /environment/{env_id}/variable/{variable_id} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(env_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{env_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_env_id', 'kind': 'xs:int', 'required': True, 'name': 'env_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def cloneEnvironment(self,
                         environment_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /environment/{id}/clone ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/clone"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/clone', 'form_params': [], 'method_name': 'cloneEnvironment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTemplateAny(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/anyorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/anyorder/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplateAny.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/anyorder/template', 'form_params': [], 'method_name': 'createTemplateAny', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/anyorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUserGroup(self,
                                environment_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachPolicy(self,
                     environment_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /environment/{id}/policy/{policyid} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy/%(policyid)s"
        path_params = {"id": environment_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'environment/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createVariable(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/variable ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTemplatesXML(self,
                        environment_id,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplatesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/template', 'form_params': [], 'method_name': 'getTemplatesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurity(self,
                    environment_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /environment/{id}/security ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTopology(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/topology', 'form_params': [], 'method_name': 'createTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def releaseEnvironment(self,
                           environment_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /environment/{id}/release ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/release"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/release', 'form_params': [], 'method_name': 'releaseEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityRights(self,
                             environment_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUser(self,
                           environment_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/user/{user_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteEnvironment(self,
                          environment_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environment/%(id)s', 'form_params': [], 'method_name': 'deleteEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTopologyAnyOrder(self,
                               environment_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /environment/{id}/anyorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/anyorder/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopologyAnyOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/anyorder/topology', 'form_params': [], 'method_name': 'createTopologyAnyOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/anyorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurity(self,
                       environment_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUserGroup(self,
                             environment_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/usergroup ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTemplate(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/template', 'form_params': [], 'method_name': 'createTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchEnvironments(self,
                           **kwargs):
        """
        [ HTTP: GET /environment/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchEnvironments.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environment/search', 'form_params': [], 'method_name': 'searchEnvironments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def startEnvironment(self,
                         environment_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /environment/{id}/start ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/start"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/start', 'form_params': [], 'method_name': 'startEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAlias(self,
                 environment_id,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityRights(self,
                          environment_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/rights ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def upateEnvironment(self,
                         environment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    upateEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environment/%(id)s', 'form_params': [], 'method_name': 'upateEnvironment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def decryptVariable(self,
                        environment_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/variable/{variable_id}/decrypt ]

        @param environment_id: environment_id
        @type environment_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": environment_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'environment/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /environment/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environment/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEnvironment(self,
                       environment_id=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environment/%(id)s', 'form_params': [], 'method_name': 'getEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTopologyManualOrder(self,
                                  environment_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /environment/{id}/manualorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/manualorder/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopologyManualOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/manualorder/topology', 'form_params': [], 'method_name': 'createTopologyManualOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/manualorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityAccessRight(self,
                               environment_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTemplateManual(self,
                             environment_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /environment/{id}/manualorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/manualorder/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplateManual.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/manualorder/template', 'form_params': [], 'method_name': 'createTemplateManual', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/manualorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createPackage(self,
                      environment_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /environment/{id}/package ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/package"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/package', 'form_params': [], 'method_name': 'createPackage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAlias(self,
                    environment_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTemplateFixed(self,
                            environment_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /environment/{id}/fixedorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/fixedorder/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplateFixed.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/fixedorder/template', 'form_params': [], 'method_name': 'createTemplateFixed', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/fixedorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPackages(self,
                    environment_id,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/package ]

        @param environment_id: environment_id
        @type environment_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/package"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTopologiesXML(self,
                         environment_id,
                         **kwargs):
        """
        [ HTTP: GET /environment/{id}/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologiesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/topology', 'form_params': [], 'method_name': 'getTopologiesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScripts(self,
                   environment_id,
                   version=None,
                   **kwargs):
        """
        [ HTTP: GET /environment/{id}/script ]

        @param environment_id: environment_id
        @type environment_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/script"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScripts.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/script', 'form_params': [], 'method_name': 'getScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicies(self,
                    environment_id,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/policy ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityAccessRight(self,
                                  environment_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUser(self,
                        environment_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/user ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/user"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'environment/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDAction(self,
                       environment_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /environment/{id}/import ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/import"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environment/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def stopEnvironment(self,
                        environment_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/stop ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/stop"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/stop', 'form_params': [], 'method_name': 'stopEnvironment', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environment/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariablesXML(self,
                        environment_id,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/variable ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/variable', 'form_params': [], 'method_name': 'getVariablesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAliases(self,
                   environment_id,
                   **kwargs):
        """
        [ HTTP: GET /environment/{id}/alias ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environment/%(id)s/alias', 'form_params': [], 'method_name': 'getAliases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environment/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'environment_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class os:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createOperatingSystem(self,
                              os_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /os/{id}/child ]

        @param os_id: os_id
        @type os_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s/child"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'os/%(id)s/child', 'form_params': [], 'method_name': 'createOperatingSystem', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /os/{id}/child ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTaxonomy(self,
                    **kwargs):
        """
        [ HTTP: GET /os/taxonomy ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/taxonomy"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTaxonomy.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'os/taxonomy', 'form_params': [], 'method_name': 'getTaxonomy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os/taxonomy ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getOperatingSystems(self,
                            **kwargs):
        """
        [ HTTP: GET /os ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOperatingSystems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'os', 'form_params': [], 'method_name': 'getOperatingSystems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchOperatingSystems(self,
                               **kwargs):
        """
        [ HTTP: GET /os/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchOperatingSystems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'os/search', 'form_params': [], 'method_name': 'searchOperatingSystems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteOperatingSystem(self,
                              os_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'os/%(id)s', 'form_params': [], 'method_name': 'deleteOperatingSystem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /os/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getOperatingSystem(self,
                           os_id=None,
                           **kwargs):
        """
        [ HTTP: GET /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'os/%(id)s', 'form_params': [], 'method_name': 'getOperatingSystem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /os/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateOperatingSystem(self,
                              os_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateOperatingSystem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'os/%(id)s', 'form_params': [], 'method_name': 'updateOperatingSystem', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /os/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'os_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class network:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getNetworksXML(self,
                       **kwargs):
        """
        [ HTTP: GET /network ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworksXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network', 'form_params': [], 'method_name': 'getNetworksXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteNetwork(self,
                      network_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'network/%(id)s', 'form_params': [], 'method_name': 'deleteNetwork', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /network/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createNetwork(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /network ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network', 'form_params': [], 'method_name': 'createNetwork', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /network ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateNetwork(self,
                      network_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'network/%(id)s', 'form_params': [], 'method_name': 'updateNetwork', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /network/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     network_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /network/{id}/export ]

        @param network_id: network_id
        @type network_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/export"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'network/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /network/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'network/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getNetwork(self,
                   network_id=None,
                   **kwargs):
        """
        [ HTTP: GET /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetwork.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'network/%(id)s', 'form_params': [], 'method_name': 'getNetwork', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /network/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'network_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class cloud:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getEffectiveModels(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/model/effective ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/model/effective"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveModels.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/model/effective', 'form_params': [], 'method_name': 'getEffectiveModels', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/model/effective ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudImagesXML(self,
                             cloud_id,
                             **kwargs):
        """
        [ HTTP: GET /cloud/{id}/image/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/image/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudImagesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/image/search', 'form_params': [], 'method_name': 'searchCloudImagesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/image/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCloudKeysXML(self,
                        cloud_id,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudKeysXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/key', 'form_params': [], 'method_name': 'getCloudKeysXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/key ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     cloud_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /cloud/{id}/export ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/export"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariableXML(self,
                       cloud_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'getVariableXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateVariable(self,
                       cloud_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /cloud/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudVolumes(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/volume/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/volume/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudVolumes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/volume/search', 'form_params': [], 'method_name': 'searchCloudVolumes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/volume/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVariable(self,
                       cloud_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createVariable(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/variable ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateCloud(self,
                    cloud_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloud/%(id)s', 'form_params': [], 'method_name': 'updateCloud', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /cloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudNetworks(self,
                            cloud_id,
                            **kwargs):
        """
        [ HTTP: GET /cloud/{id}/network/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/network/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudNetworks.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/network/search', 'form_params': [], 'method_name': 'searchCloudNetworks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/network/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createRepository(self,
                         cloud_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /cloud/{id}/repository ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/repository"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/repository', 'form_params': [], 'method_name': 'createRepository', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/repository ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /cloud/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCloudKey(self,
                    cloud_id,
                    keyid=None,
                    **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key/{keyid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param keyid: keyid
        @type keyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/%(keyid)s"
        path_params = {"id": cloud_id,
                       "keyid": keyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudKey.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}], 'method_path': 'cloud/%(id)s/key/%(keyid)s', 'form_params': [], 'method_name': 'getCloudKey', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/key/{keyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getRepositories(self,
                        cloud_id,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/repository ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/repository"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositories.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/repository', 'form_params': [], 'method_name': 'getRepositories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/repository ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudNetworkServices(self,
                                   cloud_id,
                                   **kwargs):
        """
        [ HTTP: GET /cloud/{id}/networkservice/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudNetworkServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/networkservice/search', 'form_params': [], 'method_name': 'searchCloudNetworkServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/networkservice/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCloudsXML(self,
                     **kwargs):
        """
        [ HTTP: GET /cloud ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud', 'form_params': [], 'method_name': 'getCloudsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteCloud(self,
                    cloud_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloud/%(id)s', 'form_params': [], 'method_name': 'deleteCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createLocation(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/location ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/location', 'form_params': [], 'method_name': 'createLocation', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/location ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getNetworkServices(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/networkservice ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServices.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/networkservice', 'form_params': [], 'method_name': 'getNetworkServices', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/networkservice ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def syncCloud(self,
                  cloud_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /cloud/{id}/resync ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/resync"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/resync', 'form_params': [], 'method_name': 'syncCloud', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/resync ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getNetworks(self,
                    cloud_id,
                    **kwargs):
        """
        [ HTTP: GET /cloud/{id}/network ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/network"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworks.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/network', 'form_params': [], 'method_name': 'getNetworks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/network ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def decryptVariable(self,
                        cloud_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable/{variable_id}/decrypt ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchClouds(self,
                     **kwargs):
        """
        [ HTTP: GET /cloud/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchClouds.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud/search', 'form_params': [], 'method_name': 'searchClouds', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getLocations(self,
                     cloud_id,
                     **kwargs):
        """
        [ HTTP: GET /cloud/{id}/location ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocations.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/location', 'form_params': [], 'method_name': 'getLocations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/location ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudKeysXML(self,
                           cloud_id,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudKeysXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/key/search', 'form_params': [], 'method_name': 'searchCloudKeysXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/key/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createNetworkService(self,
                             cloud_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /cloud/{id}/networkservice ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetworkService.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/networkservice', 'form_params': [], 'method_name': 'createNetworkService', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/networkservice ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudLocations(self,
                             cloud_id,
                             **kwargs):
        """
        [ HTTP: GET /cloud/{id}/location/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudLocations.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/location/search', 'form_params': [], 'method_name': 'searchCloudLocations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/location/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createCloudKey(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/key ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCloudKey.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/key', 'form_params': [], 'method_name': 'createCloudKey', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud/{id}/key ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createCloudXML(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCloudXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloud', 'form_params': [], 'method_name': 'createCloudXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloud ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteLocation(self,
                       cloud_id,
                       location_locid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/location/{locid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param location_locid: location_locid
        @type location_locid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location/%(locid)s"
        path_params = {"id": cloud_id,
                       "locid": location_locid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteLocation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'location_locid', 'kind': 'xs:int', 'required': False, 'name': 'locid'}], 'method_path': 'cloud/%(id)s/location/%(locid)s', 'form_params': [], 'method_name': 'deleteLocation', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id}/location/{locid} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'location_locid', 'kind': 'xs:int', 'required': False, 'name': 'locid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteCloudKey(self,
                       cloud_id,
                       keyid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/key/{keyid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param keyid: keyid
        @type keyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/%(keyid)s"
        path_params = {"id": cloud_id,
                       "keyid": keyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCloudKey.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}], 'method_path': 'cloud/%(id)s/key/%(keyid)s', 'form_params': [], 'method_name': 'deleteCloudKey', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloud/{id}/key/{keyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'keyid', 'kind': 'xs:int', 'required': False, 'name': 'keyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariablesXML(self,
                        cloud_id,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloud/%(id)s/variable', 'form_params': [], 'method_name': 'getVariablesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCloud(self,
                 cloud_id=None,
                 **kwargs):
        """
        [ HTTP: GET /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloud/%(id)s', 'form_params': [], 'method_name': 'getCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class domain:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getDomain(self,
                  domain_id=None,
                  **kwargs):
        """
        [ HTTP: GET /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDomain.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'domain/%(id)s', 'form_params': [], 'method_name': 'getDomain', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createUserXML(self,
                      domain_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /domain/{id}/user ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/user"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createUserXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/user', 'form_params': [], 'method_name': 'createUserXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /domain/{id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getUsersXML(self,
                    domain_id,
                    **kwargs):
        """
        [ HTTP: GET /domain/{id}/user ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/user"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUsersXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/user', 'form_params': [], 'method_name': 'getUsersXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createRoleXML(self,
                      domain_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /domain/{id}/projectrole ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/projectrole"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRoleXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/projectrole', 'form_params': [], 'method_name': 'createRoleXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /domain/{id}/projectrole ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getDomainsXML(self,
                      **kwargs):
        """
        [ HTTP: GET /domain ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDomainsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'domain', 'form_params': [], 'method_name': 'getDomainsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getRolesXML(self,
                    domain_id,
                    **kwargs):
        """
        [ HTTP: GET /domain/{id}/projectrole ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/projectrole"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRolesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/projectrole', 'form_params': [], 'method_name': 'getRolesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id}/projectrole ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     domain_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /domain/{id}/export ]

        @param domain_id: domain_id
        @type domain_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/export"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'domain/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteDomain(self,
                     domain_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDomain.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'domain/%(id)s', 'form_params': [], 'method_name': 'deleteDomain', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /domain/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /domain/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'domain/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /domain/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createDomainXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /domain ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDomainXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'domain', 'form_params': [], 'method_name': 'createDomainXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /domain ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateDomain(self,
                     domain_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateDomain.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'domain/%(id)s', 'form_params': [], 'method_name': 'updateDomain', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /domain/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'domain_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class stack:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateStack(self,
                    stack_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'stack/%(id)s', 'form_params': [], 'method_name': 'updateStack', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /stack/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getStack(self,
                 stack_id=None,
                 **kwargs):
        """
        [ HTTP: GET /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'stack/%(id)s', 'form_params': [], 'method_name': 'getStack', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteTargetCloud(self,
                          stack_id,
                          targetcloud_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /stack/{id}/targetcloud/{targetcloud_id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param targetcloud_id: targetcloud_id
        @type targetcloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/targetcloud/%(targetcloud_id)s"
        path_params = {"id": stack_id,
                       "targetcloud_id": targetcloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteTargetCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'targetcloud_id'}], 'method_path': 'stack/%(id)s/targetcloud/%(targetcloud_id)s', 'form_params': [], 'method_name': 'deleteTargetCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /stack/{id}/targetcloud/{targetcloud_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'targetcloud_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkOut(self,
                 stack_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /stack/{id}/checkout ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/checkout"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkIn(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/checkin ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/checkin"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getStacksXML(self,
                     version=None,
                     **kwargs):
        """
        [ HTTP: GET /stack ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStacksXML.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'stack', 'form_params': [], 'method_name': 'getStacksXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchBaseStacks(self,
                         **kwargs):
        """
        [ HTTP: GET /stack/base/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/base/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchBaseStacks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack/base/search', 'form_params': [], 'method_name': 'searchBaseStacks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/base/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTargetCloud(self,
                          stack_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /stack/{id}/targetcloud ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/targetcloud"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTargetCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/targetcloud', 'form_params': [], 'method_name': 'createTargetCloud', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/targetcloud ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteStack(self,
                    stack_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'stack/%(id)s', 'form_params': [], 'method_name': 'deleteStack', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /stack/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def build(self,
              stack_id,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /stack/{id}/build ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/build"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    build.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/build', 'form_params': [], 'method_name': 'build', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/build ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def reject(self,
               stack_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /stack/{id}/reject ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/reject"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     stack_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /stack/{id}/export ]

        @param stack_id: stack_id
        @type stack_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/export"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteStackAllVersions(self,
                               stack_id,
                               **kwargs):
        """
        [ HTTP: DELETE /stack/{id}/all ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/all"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteStackAllVersions.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/all', 'form_params': [], 'method_name': 'deleteStackAllVersions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /stack/{id}/all ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /stack/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchStacks(self,
                     **kwargs):
        """
        [ HTTP: GET /stack/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchStacks.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack/search', 'form_params': [], 'method_name': 'searchStacks', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /stack/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def approve(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/approve ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/approve"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'stack/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'stack_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createStack(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /stack ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createStack.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'stack', 'form_params': [], 'method_name': 'createStack', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /stack ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class script:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def scriptVariables(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /script/variable ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/variable"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    scriptVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'script/variable', 'form_params': [], 'method_name': 'scriptVariables', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /script/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchScripts(self,
                      **kwargs):
        """
        [ HTTP: GET /script/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchScripts.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'script/search', 'form_params': [], 'method_name': 'searchScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkOut(self,
                 script_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /script/{id}/checkout ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/checkout"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkIn(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/checkin ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/checkin"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAttachmentMulti(self,
                              script_id,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: POST /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAttachmentMulti.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/attachment', 'form_params': [], 'method_name': 'createAttachmentMulti', 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScriptMulti(self,
                       script_id=None,
                       **kwargs):
        """
        [ HTTP: GET /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptMulti.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'getScriptMulti', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAttachmentsXML(self,
                          script_id,
                          **kwargs):
        """
        [ HTTP: GET /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/attachment', 'form_params': [], 'method_name': 'getAttachmentsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     script_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /script/{id}/export ]

        @param script_id: script_id
        @type script_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/export"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScriptsXML(self,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /script ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptsXML.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'script', 'form_params': [], 'method_name': 'getScriptsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScript(self,
                  script_id=None,
                  **kwargs):
        """
        [ HTTP: GET /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'getScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateScript(self,
                     script_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'updateScript', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def reject(self,
               script_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /script/{id}/reject ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/reject"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteScript(self,
                     script_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'script/%(id)s', 'form_params': [], 'method_name': 'deleteScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /script/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /script/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'script/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /script/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def approve(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/approve ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/approve"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAttachmentXML(self,
                            script_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAttachmentXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'script/%(id)s/attachment', 'form_params': [], 'method_name': 'createAttachmentXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /script/{id}/attachment ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAttachmentXML(self,
                            script_id,
                            attachment_id=None,
                            **kwargs):
        """
        [ HTTP: DELETE /script/{id}/attachment/{attachment_id} ]

        @param script_id: script_id
        @type script_id: str
        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment/%(attachment_id)s"
        path_params = {"id": script_id,
                       "attachment_id": attachment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAttachmentXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'attachment_id'}], 'method_path': 'script/%(id)s/attachment/%(attachment_id)s', 'form_params': [], 'method_name': 'deleteAttachmentXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /script/{id}/attachment/{attachment_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'script_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'attachment_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class environmenttype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchEnvironmentTypes(self,
                               **kwargs):
        """
        [ HTTP: GET /environmenttype/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchEnvironmentTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype/search', 'form_params': [], 'method_name': 'searchEnvironmentTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEnvironmentType(self,
                           environmenttype_id=None,
                           **kwargs):
        """
        [ HTTP: GET /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironmentType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s', 'form_params': [], 'method_name': 'getEnvironmentType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteEnvironmentType(self,
                              environmenttype_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteEnvironmentType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s', 'form_params': [], 'method_name': 'deleteEnvironmentType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /environmenttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createEnvironmentTypeXML(self,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /environmenttype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createEnvironmentTypeXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype', 'form_params': [], 'method_name': 'createEnvironmentTypeXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /environmenttype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEnvironmentTypesXML(self,
                               **kwargs):
        """
        [ HTTP: GET /environmenttype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironmentTypesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype', 'form_params': [], 'method_name': 'getEnvironmentTypesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateEnvironmentType(self,
                              environmenttype_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateEnvironmentType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s', 'form_params': [], 'method_name': 'updateEnvironmentType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /environmenttype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     environmenttype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /environmenttype/{id}/export ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s/export"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'environmenttype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'environmenttype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /environmenttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'environmenttype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /environmenttype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class topology:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTopologies(self,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /topology ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologies.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'topology', 'form_params': [], 'method_name': 'getTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDActionXML(self,
                          topology_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /topology/{id}/import ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/import"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def reject(self,
               topology_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /topology/{id}/reject ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/reject"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAlias(self,
                    topology_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     topology_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/export ]

        @param topology_id: topology_id
        @type topology_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/export"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAlias(self,
                    topology_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /topology/{id}/alias ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/alias"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/alias', 'form_params': [], 'method_name': 'createAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkOut(self,
                 topology_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/checkout ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/checkout"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateVariable(self,
                       topology_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/variable/{variable_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateTopology(self,
                       topology_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'topology/%(id)s', 'form_params': [], 'method_name': 'updateTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getChildTopologies(self,
                           topology_id,
                           **kwargs):
        """
        [ HTTP: GET /topology/{id}/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildTopologies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/topology', 'form_params': [], 'method_name': 'getChildTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteTopology(self,
                       topology_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'topology/%(id)s', 'form_params': [], 'method_name': 'deleteTopology', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVariable(self,
                       topology_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/variable/{variable_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDAction(self,
                       topology_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{id}/import ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/import"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkIn(self,
                topology_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /topology/{id}/checkin ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/checkin"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTemplateAny(self,
                               topology_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /topology/{id}/anyorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/anyorder/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplateAny.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/anyorder/template', 'form_params': [], 'method_name': 'createChildTemplateAny', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/anyorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTemplateManual(self,
                                  topology_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /topology/{id}/manualorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/manualorder/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplateManual.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/manualorder/template', 'form_params': [], 'method_name': 'createChildTemplateManual', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/manualorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariable(self,
                    topology_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/variable/{variable_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{topology_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def cloneTopology(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/clone ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/clone"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/clone', 'form_params': [], 'method_name': 'cloneTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /topology/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'topology/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTemplate(self,
                            topology_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{id}/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/template', 'form_params': [], 'method_name': 'createChildTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def rebootTopology(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/restart ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/restart"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/restart', 'form_params': [], 'method_name': 'rebootTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTopologyStats(self,
                         topology_id,
                         **kwargs):
        """
        [ HTTP: GET /topology/{id}/stats ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/stats"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologyStats.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/stats', 'form_params': [], 'method_name': 'getTopologyStats', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/stats ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def releaseTopology(self,
                        topology_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /topology/{id}/release ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/release"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/release', 'form_params': [], 'method_name': 'releaseTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTopologyAnyOrder(self,
                                    topology_id,
                                    data=None,
                                    **kwargs):
        """
        [ HTTP: POST /topology/{id}/anyorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/anyorder/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopologyAnyOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/anyorder/topology', 'form_params': [], 'method_name': 'createChildTopologyAnyOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/anyorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariables(self,
                     topology_id,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/variable ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/variable', 'form_params': [], 'method_name': 'getVariables', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getChildTemplates(self,
                          topology_id,
                          **kwargs):
        """
        [ HTTP: GET /topology/{id}/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/template', 'form_params': [], 'method_name': 'getChildTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAlias(self,
                 topology_id,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{topology_id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def decryptVariable(self,
                        topology_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /topology/{id}/variable/{variable_id}/decrypt ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'topology/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTopology(self,
                    topology_id=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'topology/%(id)s', 'form_params': [], 'method_name': 'getTopology', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def stopTopology(self,
                     topology_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /topology/{id}/stop ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/stop"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/stop', 'form_params': [], 'method_name': 'stopTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAlias(self,
                    topology_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'topology_id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTemplateFixed(self,
                                 topology_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/fixedorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/fixedorder/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplateFixed.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/fixedorder/template', 'form_params': [], 'method_name': 'createChildTemplateFixed', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/fixedorder/template ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTopology(self,
                            topology_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{id}/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/topology', 'form_params': [], 'method_name': 'createChildTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def startTopology(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/start ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/start"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/start', 'form_params': [], 'method_name': 'startTopology', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTopologyManualOrder(self,
                                       topology_id,
                                       data=None,
                                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/manualorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/manualorder/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopologyManualOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/manualorder/topology', 'form_params': [], 'method_name': 'createChildTopologyManualOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/manualorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createChildTopologyFixedOrder(self,
                                      topology_id,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/fixedorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/fixedorder/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopologyFixedOrder.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/fixedorder/topology', 'form_params': [], 'method_name': 'createChildTopologyFixedOrder', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/fixedorder/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def approve(self,
                topology_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /topology/{id}/approve ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/approve"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createVariable(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/variable ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /topology/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAliases(self,
                   topology_id,
                   **kwargs):
        """
        [ HTTP: GET /topology/{id}/alias ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/alias"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'topology/%(id)s/alias', 'form_params': [], 'method_name': 'getAliases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'topology_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchTopologies(self,
                         **kwargs):
        """
        [ HTTP: GET /topology/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTopologies.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'topology/search', 'form_params': [], 'method_name': 'searchTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /topology/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class propertytype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /propertytype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'propertytype/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertytype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createPropertyTypeXML(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /propertytype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPropertyTypeXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype', 'form_params': [], 'method_name': 'createPropertyTypeXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /propertytype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     propertytype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /propertytype/{id}/export ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s/export"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'propertytype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /propertytype/{id}/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype/%(id)s/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertytype/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deletePropertyType(self,
                           propertytype_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePropertyType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertytype/%(id)s', 'form_params': [], 'method_name': 'deletePropertyType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /propertytype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPropertyTypesXML(self,
                            **kwargs):
        """
        [ HTTP: GET /propertytype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyTypesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype', 'form_params': [], 'method_name': 'getPropertyTypesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPropertyType(self,
                        propertytype_id=None,
                        **kwargs):
        """
        [ HTTP: GET /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertytype/%(id)s', 'form_params': [], 'method_name': 'getPropertyType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /propertytype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertytype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertytype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updatePropertyType(self,
                           propertytype_id=None,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePropertyType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertytype/%(id)s', 'form_params': [], 'method_name': 'updatePropertyType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertytype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertytype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class storage:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteSnapshot(self,
                       storage_id,
                       snapshot_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /storage/{id}/snapshot/{snapshot_id} ]

        @param storage_id: storage_id
        @type storage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": storage_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'storage/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'deleteSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /storage/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getStoragesXML(self,
                       **kwargs):
        """
        [ HTTP: GET /storage ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStoragesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'storage', 'form_params': [], 'method_name': 'getStoragesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storage ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSnapshot(self,
                    storage_id,
                    snapshot_id=None,
                    **kwargs):
        """
        [ HTTP: GET /storage/{id}/snapshot/{snapshot_id} ]

        @param storage_id: storage_id
        @type storage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": storage_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'storage/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'getSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storage/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def revertSnapshot(self,
                       storage_id,
                       snapshot_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /storage/{id}/snapshot/{snapshot_id} ]

        @param storage_id: storage_id
        @type storage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": storage_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    revertSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'storage/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'revertSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /storage/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getStorage(self,
                   storage_id=None,
                   **kwargs):
        """
        [ HTTP: GET /storage/{id} ]

        @param storage_id: storage_id
        @type storage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s"
        path_params = {"id": storage_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStorage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'storage/%(id)s', 'form_params': [], 'method_name': 'getStorage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /storage/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createSnapshot(self,
                       storage_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /storage/{id}/snapshot ]

        @param storage_id: storage_id
        @type storage_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s/snapshot"
        path_params = {"id": storage_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'storage/%(id)s/snapshot', 'form_params': [], 'method_name': 'createSnapshot', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /storage/{id}/snapshot ]', 'method_params': [{'defaultValue': None, 'alias': 'storage_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class compute:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getInstancesXML(self,
                        **kwargs):
        """
        [ HTTP: GET /compute ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstancesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'compute', 'form_params': [], 'method_name': 'getInstancesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def releaseInstance(self,
                        compute_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /compute/{id}/release ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/release"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/release', 'form_params': [], 'method_name': 'releaseInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkAccess(self,
                    ip=None,
                    port=None,
                    auth=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/access ]

        @param ip: ip
        @type ip: str
        @param port: port
        @type port: str
        @param auth: auth
        @type auth: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/access"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"ip": ip,
                        "port": port,
                        "auth": auth}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkAccess.context = {'query_params': [{'defaultValue': None, 'alias': 'ip', 'kind': 'xs:string', 'required': False, 'name': 'ip'}, {'defaultValue': None, 'alias': 'port', 'kind': 'xs:int', 'required': False, 'name': 'port'}, {'defaultValue': None, 'alias': 'auth', 'kind': 'xs:string', 'required': False, 'name': 'auth'}], 'hasFiles': False, 'path_params': [], 'method_path': 'compute/access', 'form_params': [], 'method_name': 'checkAccess', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/access ]', 'method_params': [{'defaultValue': None, 'alias': 'ip', 'kind': 'xs:string', 'required': False, 'name': 'ip'}, {'defaultValue': None, 'alias': 'port', 'kind': 'xs:int', 'required': False, 'name': 'port'}, {'defaultValue': None, 'alias': 'auth', 'kind': 'xs:string', 'required': False, 'name': 'auth'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getInstance(self,
                    compute_id=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'compute/%(id)s', 'form_params': [], 'method_name': 'getInstance', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSnapshot(self,
                       compute_id,
                       snapshot_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'deleteSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /compute/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def executeScript(self,
                      compute_id,
                      execute_scriptid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/execute/{scriptid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param execute_scriptid: execute_scriptid
        @type execute_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/execute/%(scriptid)s"
        path_params = {"id": compute_id,
                       "scriptid": execute_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    executeScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'execute_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'compute/%(id)s/execute/%(scriptid)s', 'form_params': [], 'method_name': 'executeScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/execute/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'execute_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAlias(self,
                    compute_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /compute/{id}/alias/{alias_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/alias/%(alias_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'compute/%(id)s/alias/%(alias_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/alias/{alias_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def executeScriptTask(self,
                          compute_id,
                          queue_scriptid=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /compute/{id}/queue/{scriptid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param queue_scriptid: queue_scriptid
        @type queue_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/queue/%(scriptid)s"
        path_params = {"id": compute_id,
                       "scriptid": queue_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    executeScriptTask.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'queue_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'compute/%(id)s/queue/%(scriptid)s', 'form_params': [], 'method_name': 'executeScriptTask', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/queue/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'queue_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def startInstance(self,
                      compute_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/start ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/start"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/start', 'form_params': [], 'method_name': 'startInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSnapshot(self,
                    compute_id,
                    snapshot_id=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'getSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScriptStatus(self,
                        compute_id,
                        scriptstatusid=None,
                        **kwargs):
        """
        [ HTTP: GET /compute/{id}/scriptstatus/{scriptstatusid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param scriptstatusid: scriptstatusid
        @type scriptstatusid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/scriptstatus/%(scriptstatusid)s"
        path_params = {"id": compute_id,
                       "scriptstatusid": scriptstatusid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptStatus.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'scriptstatusid', 'kind': 'xs:int', 'required': False, 'name': 'scriptstatusid'}], 'method_path': 'compute/%(id)s/scriptstatus/%(scriptstatusid)s', 'form_params': [], 'method_name': 'getScriptStatus', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/scriptstatus/{scriptstatusid} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'scriptstatusid', 'kind': 'xs:int', 'required': False, 'name': 'scriptstatusid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScriptStatuses(self,
                          compute_id,
                          **kwargs):
        """
        [ HTTP: GET /compute/{id}/scriptstatus ]

        @param compute_id: compute_id
        @type compute_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/scriptstatus"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptStatuses.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/scriptstatus', 'form_params': [], 'method_name': 'getScriptStatuses', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/{id}/scriptstatus ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def revertSnapshot(self,
                       compute_id,
                       snapshot_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    revertSnapshot.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'form_params': [], 'method_name': 'revertSnapshot', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /compute/{id}/snapshot/{snapshot_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'snapshot_id', 'kind': 'xs:int', 'required': False, 'name': 'snapshot_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def rebootInstance(self,
                       compute_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /compute/{id}/restart ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/restart"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/restart', 'form_params': [], 'method_name': 'rebootInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchInstances(self,
                        **kwargs):
        """
        [ HTTP: GET /compute/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'compute/search', 'form_params': [], 'method_name': 'searchInstances', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /compute/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def acknowledgeDegrade(self,
                           compute_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /compute/{id}/ack ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/ack"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    acknowledgeDegrade.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/ack', 'form_params': [], 'method_name': 'acknowledgeDegrade', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /compute/{id}/ack ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def stopInstance(self,
                     compute_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /compute/{id}/stop ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/stop"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/stop', 'form_params': [], 'method_name': 'stopInstance', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAliasByName(self,
                          compute_id,
                          alias_name=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /compute/{id}/alias/{name: [a-zA-Z0-9_\-]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param alias_name: alias_name
        @type alias_name: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/alias/%(name: [a-zA-Z0-9_\-]+)s"
        path_params = {"id": compute_id,
                       "name": alias_name}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAliasByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}], 'method_path': 'compute/%(id)s/alias/%(name: [a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'updateAliasByName', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/alias/{name: [a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def snapshotInstance(self,
                         compute_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /compute/{id}/snapshot ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    snapshotInstance.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'compute/%(id)s/snapshot', 'form_params': [], 'method_name': 'snapshotInstance', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /compute/{id}/snapshot ]', 'method_params': [{'defaultValue': None, 'alias': 'compute_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class assettype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /assettype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'assettype/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /assettype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addPermissionType(self,
                          assettype_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /assettype/{id}/permissiontype ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/permissiontype"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addPermissionType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'assettype/%(id)s/permissiontype', 'form_params': [], 'method_name': 'addPermissionType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /assettype/{id}/permissiontype ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAssetType(self,
                     assettype_id=None,
                     **kwargs):
        """
        [ HTTP: GET /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'assettype/%(id)s', 'form_params': [], 'method_name': 'getAssetType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPermissionTypes(self,
                           assettype_id,
                           **kwargs):
        """
        [ HTTP: GET /assettype/{id}/permissiontype ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/permissiontype"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPermissionTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'assettype/%(id)s/permissiontype', 'form_params': [], 'method_name': 'getPermissionTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/{id}/permissiontype ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAssetType(self,
                        assettype_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAssetType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'assettype/%(id)s', 'form_params': [], 'method_name': 'deleteAssetType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /assettype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAssetType(self,
                        assettype_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAssetType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'assettype/%(id)s', 'form_params': [], 'method_name': 'updateAssetType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /assettype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /assettype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /assettype/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAssetTypeXML(self,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /assettype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAssetTypeXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype', 'form_params': [], 'method_name': 'createAssetTypeXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /assettype ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     assettype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /assettype/{id}/export ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/export"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'assettype/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'assettype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAssetTypesXML(self,
                         **kwargs):
        """
        [ HTTP: GET /assettype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetTypesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype', 'form_params': [], 'method_name': 'getAssetTypesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /assettype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'assettype/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /assettype/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class model:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getModel(self,
                 model_id=None,
                 **kwargs):
        """
        [ HTTP: GET /model/{id} ]

        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'model/%(id)s', 'form_params': [], 'method_name': 'getModel', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getModelsXML(self,
                     **kwargs):
        """
        [ HTTP: GET /model ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModelsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'model', 'form_params': [], 'method_name': 'getModelsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addResource(self,
                    model_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /model/{id}/resource ]

        @param model_id: model_id
        @type model_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'model/%(id)s/resource', 'form_params': [], 'method_name': 'addResource', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /model/{id}/resource ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteResource(self,
                       model_id,
                       resource_resid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /model/{id}/resource/{resid} ]

        @param model_id: model_id
        @type model_id: str
        @param resource_resid: resource_resid
        @type resource_resid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource/%(resid)s"
        path_params = {"id": model_id,
                       "resid": resource_resid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resource_resid', 'kind': 'xs:int', 'required': False, 'name': 'resid'}], 'method_path': 'model/%(id)s/resource/%(resid)s', 'form_params': [], 'method_name': 'deleteResource', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /model/{id}/resource/{resid} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resource_resid', 'kind': 'xs:int', 'required': False, 'name': 'resid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateResource(self,
                       model_id,
                       resourceId=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /model/{id}/resource/{resourceId} ]

        @param model_id: model_id
        @type model_id: str
        @param resourceId: resourceId
        @type resourceId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource/%(resourceId)s"
        path_params = {"id": model_id,
                       "resourceId": resourceId}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateResource.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resourceId', 'kind': 'xs:int', 'required': False, 'name': 'resourceId'}], 'method_path': 'model/%(id)s/resource/%(resourceId)s', 'form_params': [], 'method_name': 'updateResource', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /model/{id}/resource/{resourceId} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'resourceId', 'kind': 'xs:int', 'required': False, 'name': 'resourceId'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     model_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /model/{id}/export ]

        @param model_id: model_id
        @type model_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/export"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'model/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateModel(self,
                    model_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /model/{id} ]

        @param model_id: model_id
        @type model_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'model/%(id)s', 'form_params': [], 'method_name': 'updateModel', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /model/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /model/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'model/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /model/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class search:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getSearchFields(self,
                        field_type=None,
                        **kwargs):
        """
        [ HTTP: GET /search/field/{type} ]

        @param field_type: field_type
        @type field_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search/field/%(type)s"
        path_params = {"type": field_type}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSearchFields.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'field_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}], 'method_path': 'search/field/%(type)s', 'form_params': [], 'method_name': 'getSearchFields', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /search/field/{type} ]', 'method_params': [{'defaultValue': None, 'alias': 'field_type', 'kind': 'xs:string', 'required': False, 'name': 'type'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def search(self,
               **kwargs):
        """
        [ HTTP: GET /search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    search.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'search', 'form_params': [], 'method_name': 'search', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchAssets(self,
                     **kwargs):
        """
        [ HTTP: GET /search/asset ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search/asset"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchAssets.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'search/asset', 'form_params': [], 'method_name': 'searchAssets', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /search/asset ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class custom:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAsset(self,
                 custom_id=None,
                 **kwargs):
        """
        [ HTTP: GET /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAsset.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'custom/%(id)s', 'form_params': [], 'method_name': 'getAsset', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteCustomItem(self,
                         custom_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCustomItem.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'custom/%(id)s', 'form_params': [], 'method_name': 'deleteCustomItem', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /custom/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAsset(self,
                    custom_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAsset.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'custom/%(id)s', 'form_params': [], 'method_name': 'updateAsset', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /custom/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAssetXML(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /custom ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAssetXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom', 'form_params': [], 'method_name': 'createAssetXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /custom ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCustomItems(self,
                          **kwargs):
        """
        [ HTTP: GET /custom/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCustomItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom/search', 'form_params': [], 'method_name': 'searchCustomItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAssetsXML(self,
                     **kwargs):
        """
        [ HTTP: GET /custom ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom', 'form_params': [], 'method_name': 'getAssetsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     custom_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /custom/{id}/export ]

        @param custom_id: custom_id
        @type custom_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s/export"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'custom/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'custom_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /custom/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'custom/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /custom/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class customcontainer:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importIDActionXML(self,
                          customcontainer_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/import ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/import"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSecurity(self,
                    customcontainer_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/security/{security_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removePolicy(self,
                     customcontainer_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/policy/{policyid} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy/%(policyid)s"
        path_params = {"id": customcontainer_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'customcontainer/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPolicyAssignments(self,
                                customcontainer_id,
                                **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/policyassignment/search ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policyassignment/search"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     customcontainer_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/export ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/export"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getChildCustomContainers(self,
                                 customcontainer_id,
                                 **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/customcontainer ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customcontainer"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildCustomContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/customcontainer', 'form_params': [], 'method_name': 'getChildCustomContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/customcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchContainers(self,
                         **kwargs):
        """
        [ HTTP: GET /customcontainer/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer/search', 'form_params': [], 'method_name': 'searchContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCustomContainer(self,
                           customcontainer_id=None,
                           **kwargs):
        """
        [ HTTP: GET /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s', 'form_params': [], 'method_name': 'getCustomContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUserGroup(self,
                                customcontainer_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachPolicy(self,
                     customcontainer_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/policy/{policyid} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy/%(policyid)s"
        path_params = {"id": customcontainer_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'customcontainer/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurity(self,
                    customcontainer_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCustomItems(self,
                       customcontainer_id,
                       **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/customitems ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customitems"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCustomItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/customitems', 'form_params': [], 'method_name': 'getCustomItems', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/customitems ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteCustomContainer(self,
                              customcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s', 'form_params': [], 'method_name': 'deleteCustomContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityRights(self,
                             customcontainer_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUser(self,
                           customcontainer_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/user/{user_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurity(self,
                       customcontainer_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCustomContainers(self,
                            **kwargs):
        """
        [ HTTP: GET /customcontainer ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCustomContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer', 'form_params': [], 'method_name': 'getCustomContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUserGroup(self,
                             customcontainer_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/usergroup ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDAction(self,
                       customcontainer_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/import ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/import"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityAccessRight(self,
                               customcontainer_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateCustomContainer(self,
                              customcontainer_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s', 'form_params': [], 'method_name': 'updateCustomContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityRights(self,
                          customcontainer_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/rights ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /customcontainer/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /customcontainer/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'customcontainer/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateCustomItems(self,
                          customcontainer_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/customitems ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customitems"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCustomItems.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/customitems', 'form_params': [], 'method_name': 'updateCustomItems', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/customitems ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUser(self,
                        customcontainer_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/user ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/user"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicies(self,
                    customcontainer_id,
                    **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/policy ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'customcontainer/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /customcontainer/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /customcontainer/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /customcontainer/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityAccessRight(self,
                                  customcontainer_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'customcontainer_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createCustomContainer(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /customcontainer ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCustomContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'customcontainer', 'form_params': [], 'method_name': 'createCustomContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /customcontainer ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class container:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importIDActionXML(self,
                          container_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /container/{id}/import ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/import"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSecurity(self,
                    container_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/security/{security_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removePolicy(self,
                     container_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /container/{id}/policy/{policyid} ]

        @param container_id: container_id
        @type container_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy/%(policyid)s"
        path_params = {"id": container_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'container/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /container/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPolicyAssignments(self,
                                container_id,
                                **kwargs):
        """
        [ HTTP: GET /container/{id}/policyassignment/search ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policyassignment/search"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     container_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /container/{id}/export ]

        @param container_id: container_id
        @type container_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/export"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getProjects(self,
                    container_id,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/project ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/project"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/project', 'form_params': [], 'method_name': 'getProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/project ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteContainer(self,
                        container_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'container/%(id)s', 'form_params': [], 'method_name': 'deleteContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchContainers(self,
                         **kwargs):
        """
        [ HTTP: GET /container/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container/search', 'form_params': [], 'method_name': 'searchContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUserGroup(self,
                                container_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachPolicy(self,
                     container_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /container/{id}/policy/{policyid} ]

        @param container_id: container_id
        @type container_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy/%(policyid)s"
        path_params = {"id": container_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'container/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurity(self,
                    container_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /container/{id}/security ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getContainer(self,
                     container_id=None,
                     **kwargs):
        """
        [ HTTP: GET /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'container/%(id)s', 'form_params': [], 'method_name': 'getContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityRights(self,
                             container_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUser(self,
                           container_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/user/{user_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurity(self,
                       container_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUserGroup(self,
                             container_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/usergroup ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getContainersRecursive(self,
                               container_id,
                               **kwargs):
        """
        [ HTTP: GET /container/{id}/container ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/container"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainersRecursive.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/container', 'form_params': [], 'method_name': 'getContainersRecursive', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/container ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createProject(self,
                      container_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /container/{id}/project ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/project"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/project', 'form_params': [], 'method_name': 'createProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/project ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createContainer(self,
                        container_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /container/{id}/container ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/container"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/container', 'form_params': [], 'method_name': 'createContainer', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/container ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityRights(self,
                          container_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/rights ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getContainers(self,
                      **kwargs):
        """
        [ HTTP: GET /container ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container', 'form_params': [], 'method_name': 'getContainers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /container/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'container/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityAccessRight(self,
                               container_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUser(self,
                        container_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/user ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/user"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicies(self,
                    container_id,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/policy ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /container/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /container/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'container/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityAccessRight(self,
                                  container_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDAction(self,
                       container_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /container/{id}/import ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/import"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'container/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /container/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'container_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class ldapGroup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getMappings(self,
                    **kwargs):
        """
        [ HTTP: GET /ldapGroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapGroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMappings.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'ldapGroup', 'form_params': [], 'method_name': 'getMappings', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /ldapGroup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateMapping(self,
                      ldapGroup_id,
                      newAgilityGpName=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /ldapGroup/{id}/{newAgilityGpName} ]

        @param ldapGroup_id: ldapGroup_id
        @type ldapGroup_id: str
        @param newAgilityGpName: newAgilityGpName
        @type newAgilityGpName: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapGroup/%(id)s/%(newAgilityGpName)s"
        path_params = {"id": ldapGroup_id,
                       "newAgilityGpName": newAgilityGpName}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapGroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'newAgilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'newAgilityGpName'}], 'method_path': 'ldapGroup/%(id)s/%(newAgilityGpName)s', 'form_params': [], 'method_name': 'updateMapping', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /ldapGroup/{id}/{newAgilityGpName} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapGroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'newAgilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'newAgilityGpName'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteMapping(self,
                      ldapGroup_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /ldapGroup/{id} ]

        @param ldapGroup_id: ldapGroup_id
        @type ldapGroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapGroup/%(id)s"
        path_params = {"id": ldapGroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapGroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'ldapGroup/%(id)s', 'form_params': [], 'method_name': 'deleteMapping', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /ldapGroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapGroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createMapping(self,
                      ldapGroup_ldapGpName,
                      agilityGpName=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /ldapGroup/{ldapGpName}/{agilityGpName} ]

        @param ldapGroup_ldapGpName: ldapGroup_ldapGpName
        @type ldapGroup_ldapGpName: str
        @param agilityGpName: agilityGpName
        @type agilityGpName: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapGroup/%(ldapGpName)s/%(agilityGpName)s"
        path_params = {"ldapGpName": ldapGroup_ldapGpName,
                       "agilityGpName": agilityGpName}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapGroup_ldapGpName', 'kind': 'xs:string', 'required': True, 'name': 'ldapGpName'}, {'defaultValue': None, 'alias': 'agilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'agilityGpName'}], 'method_path': 'ldapGroup/%(ldapGpName)s/%(agilityGpName)s', 'form_params': [], 'method_name': 'createMapping', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /ldapGroup/{ldapGpName}/{agilityGpName} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapGroup_ldapGpName', 'kind': 'xs:string', 'required': True, 'name': 'ldapGpName'}, {'defaultValue': None, 'alias': 'agilityGpName', 'kind': 'xs:string', 'required': False, 'name': 'agilityGpName'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createMappings(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /ldapGroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapGroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMappings.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'ldapGroup', 'form_params': [], 'method_name': 'createMappings', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /ldapGroup ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getMapping(self,
                   ldapGroup_id=None,
                   **kwargs):
        """
        [ HTTP: GET /ldapGroup/{id} ]

        @param ldapGroup_id: ldapGroup_id
        @type ldapGroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapGroup/%(id)s"
        path_params = {"id": ldapGroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMapping.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'ldapGroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'ldapGroup/%(id)s', 'form_params': [], 'method_name': 'getMapping', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /ldapGroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'ldapGroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class attachment:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAttachmentsXML(self,
                          **kwargs):
        """
        [ HTTP: GET /attachment ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'attachment', 'form_params': [], 'method_name': 'getAttachmentsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /attachment ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAttachmentMulti(self,
                           attachment_id=None,
                           **kwargs):
        """
        [ HTTP: GET /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentMulti.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'attachment/%(id)s', 'form_params': [], 'method_name': 'getAttachmentMulti', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /attachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAttachment(self,
                         attachment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'attachment/%(id)s', 'form_params': [], 'method_name': 'deleteAttachment', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /attachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAttachment(self,
                         attachment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAttachment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'attachment/%(id)s', 'form_params': [], 'method_name': 'updateAttachment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /attachment/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'attachment_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class propertygroup:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deletePropertyDefinitionGroup(self,
                                      propertygroup_id=None,
                                      **kwargs):
        """
        [ HTTP: DELETE /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePropertyDefinitionGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s', 'form_params': [], 'method_name': 'deletePropertyDefinitionGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /propertygroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /propertygroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'propertygroup/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertygroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPropertyDefinitionGroup(self,
                                   propertygroup_id=None,
                                   **kwargs):
        """
        [ HTTP: GET /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyDefinitionGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s', 'form_params': [], 'method_name': 'getPropertyDefinitionGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPropertyDefinitionGroupsXML(self,
                                       **kwargs):
        """
        [ HTTP: GET /propertygroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyDefinitionGroupsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup', 'form_params': [], 'method_name': 'getPropertyDefinitionGroupsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     propertygroup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /propertygroup/{id}/export ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s/export"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /propertygroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertygroup/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createPropertyDefinitionGroupXML(self,
                                         data=None,
                                         **kwargs):
        """
        [ HTTP: POST /propertygroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPropertyDefinitionGroupXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup', 'form_params': [], 'method_name': 'createPropertyDefinitionGroupXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /propertygroup ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updatePropertyDefinitionGroup(self,
                                      propertygroup_id=None,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: PUT /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePropertyDefinitionGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'propertygroup/%(id)s', 'form_params': [], 'method_name': 'updatePropertyDefinitionGroup', 'custom_headers': {'Content-Type': 'application/x-www-form-urlencoded'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /propertygroup/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'propertygroup_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /propertygroup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'propertygroup/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /propertygroup/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class alias:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAlias(self,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'alias/%(id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /alias/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAliasesXML(self,
                      **kwargs):
        """
        [ HTTP: GET /alias ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliasesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'alias', 'form_params': [], 'method_name': 'getAliasesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /alias ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAlias(self,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'alias/%(id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /alias/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAlias(self,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'alias/%(id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /alias/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class user:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateUser(self,
                   user_id=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'user/%(id)s', 'form_params': [], 'method_name': 'updateUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /user/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /user/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'user/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /user/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteUser(self,
                   user_id=None,
                   **kwargs):
        """
        [ HTTP: DELETE /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'user/%(id)s', 'form_params': [], 'method_name': 'deleteUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /user/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addUser(self,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /user ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user', 'form_params': [], 'method_name': 'addUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /user ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchUsers(self,
                    **kwargs):
        """
        [ HTTP: GET /user/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchUsers.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user/search', 'form_params': [], 'method_name': 'searchUsers', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getUsersXML(self,
                    **kwargs):
        """
        [ HTTP: GET /user ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUsersXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user', 'form_params': [], 'method_name': 'getUsersXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getUser(self,
                user_id=None,
                **kwargs):
        """
        [ HTTP: GET /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'user/%(id)s', 'form_params': [], 'method_name': 'getUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /user/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /user/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     user_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /user/{id}/export ]

        @param user_id: user_id
        @type user_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s/export"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'user/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /user/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'user/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /user/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class tree:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTreeProjects(self,
                        **kwargs):
        """
        [ HTTP: GET /tree/project ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "tree/project"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTreeProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'tree/project', 'form_params': [], 'method_name': 'getTreeProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /tree/project ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getDesignTreeNode(self,
                          design_type,
                          id=None,
                          **kwargs):
        """
        [ HTTP: GET /tree/design/{type}/{id} ]

        @param design_type: design_type
        @type design_type: str
        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "tree/design/%(type)s/%(id)s"
        path_params = {"type": design_type,
                       "id": id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDesignTreeNode.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'design_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'tree/design/%(type)s/%(id)s', 'form_params': [], 'method_name': 'getDesignTreeNode', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /tree/design/{type}/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'design_type', 'kind': 'xs:string', 'required': True, 'name': 'type'}, {'defaultValue': None, 'alias': 'id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class image:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def exportAction(self,
                     image_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /image/{id}/export ]

        @param image_id: image_id
        @type image_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s/export"
        path_params = {"id": image_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'image/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /image/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'image/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getImage(self,
                 image_id=None,
                 **kwargs):
        """
        [ HTTP: GET /image/{id} ]

        @param image_id: image_id
        @type image_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s"
        path_params = {"id": image_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getImage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'image/%(id)s', 'form_params': [], 'method_name': 'getImage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'image_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getImagesXML(self,
                     **kwargs):
        """
        [ HTTP: GET /image ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getImagesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'image', 'form_params': [], 'method_name': 'getImagesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchImages(self,
                     **kwargs):
        """
        [ HTTP: GET /image/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchImages.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'image/search', 'form_params': [], 'method_name': 'searchImages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /image/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class package:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def removeShutdownScript(self,
                             package_id,
                             shutdown_scriptid=None,
                             **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/shutdown/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param shutdown_scriptid: shutdown_scriptid
        @type shutdown_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/shutdown/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": shutdown_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeShutdownScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/shutdown/%(scriptid)s', 'form_params': [], 'method_name': 'removeShutdownScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/shutdown/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removeOperationalScript(self,
                                package_id,
                                operational_scriptid=None,
                                **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/operational/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param operational_scriptid: operational_scriptid
        @type operational_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/operational/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": operational_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeOperationalScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/operational/%(scriptid)s', 'form_params': [], 'method_name': 'removeOperationalScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/operational/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkOut(self,
                 package_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /package/{id}/checkout ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/checkout"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/checkout', 'form_params': [], 'method_name': 'checkOut', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/checkout ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removeStartupScript(self,
                            package_id,
                            startup_scriptid=None,
                            **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/startup/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param startup_scriptid: startup_scriptid
        @type startup_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/startup/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": startup_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeStartupScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/startup/%(scriptid)s', 'form_params': [], 'method_name': 'removeStartupScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/startup/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachInstallScript(self,
                            package_id,
                            install_scriptid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/install/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param install_scriptid: install_scriptid
        @type install_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/install/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": install_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachInstallScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/install/%(scriptid)s', 'form_params': [], 'method_name': 'attachInstallScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/install/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createPackage(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /package ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'package', 'form_params': [], 'method_name': 'createPackage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def checkIn(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/checkin ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/checkin"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/checkin', 'form_params': [], 'method_name': 'checkIn', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/checkin ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removeInstallScript(self,
                            package_id,
                            install_scriptid=None,
                            **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/install/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param install_scriptid: install_scriptid
        @type install_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/install/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": install_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeInstallScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/install/%(scriptid)s', 'form_params': [], 'method_name': 'removeInstallScript', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id}/script/install/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'install_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPackages(self,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /package ]

        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [], 'method_path': 'package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package ]', 'method_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPackageScripts(self,
                          package_id,
                          **kwargs):
        """
        [ HTTP: GET /package/{id}/script ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackageScripts.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/script', 'form_params': [], 'method_name': 'getPackageScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deletePackage(self,
                      package_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'package/%(id)s', 'form_params': [], 'method_name': 'deletePackage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /package/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachShutdownScript(self,
                             package_id,
                             shutdown_scriptid=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/shutdown/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param shutdown_scriptid: shutdown_scriptid
        @type shutdown_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/shutdown/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": shutdown_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachShutdownScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/shutdown/%(scriptid)s', 'form_params': [], 'method_name': 'attachShutdownScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/shutdown/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'shutdown_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachStartupScript(self,
                            package_id,
                            startup_scriptid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/startup/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param startup_scriptid: startup_scriptid
        @type startup_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/startup/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": startup_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachStartupScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/startup/%(scriptid)s', 'form_params': [], 'method_name': 'attachStartupScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/startup/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'startup_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPackages(self,
                       **kwargs):
        """
        [ HTTP: GET /package/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPackages.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'package/search', 'form_params': [], 'method_name': 'searchPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachOperationalScript(self,
                                package_id,
                                operational_scriptid=None,
                                data=None,
                                **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/operational/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param operational_scriptid: operational_scriptid
        @type operational_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/operational/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": operational_scriptid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachOperationalScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}], 'method_path': 'package/%(id)s/script/operational/%(scriptid)s', 'form_params': [], 'method_name': 'attachOperationalScript', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /package/{id}/script/operational/{scriptid} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'operational_scriptid', 'kind': 'xs:int', 'required': False, 'name': 'scriptid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPackage(self,
                   package_id=None,
                   **kwargs):
        """
        [ HTTP: GET /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'package/%(id)s', 'form_params': [], 'method_name': 'getPackage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def reject(self,
               package_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /package/{id}/reject ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/reject"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/reject', 'form_params': [], 'method_name': 'reject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/reject ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     package_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /package/{id}/export ]

        @param package_id: package_id
        @type package_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/export"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /package/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'package/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /package/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def approve(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/approve ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/approve"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'package/%(id)s/approve', 'form_params': [], 'method_name': 'approve', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /package/{id}/approve ]', 'method_params': [{'defaultValue': None, 'alias': 'package_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class volume:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getVolumesXML(self,
                      **kwargs):
        """
        [ HTTP: GET /volume ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'volume', 'form_params': [], 'method_name': 'getVolumesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volume ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVolume(self,
                  volume_id=None,
                  **kwargs):
        """
        [ HTTP: GET /volume/{id} ]

        @param volume_id: volume_id
        @type volume_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume/%(id)s"
        path_params = {"id": volume_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'volume/%(id)s', 'form_params': [], 'method_name': 'getVolume', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /volume/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVolume(self,
                     volume_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /volume/{id} ]

        @param volume_id: volume_id
        @type volume_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume/%(id)s"
        path_params = {"id": volume_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'volume/%(id)s', 'form_params': [], 'method_name': 'deleteVolume', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /volume/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'volume_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class globals:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteSecurity(self,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id} ]

        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUserGroup(self,
                             security_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/usergroup ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/usergroup"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSecurity(self,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /global/security/{security_id} ]

        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /global/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUserGroup(self,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/usergroup/{usergroup_id} ]

        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'global/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUser(self,
                        security_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/user ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/user"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurity(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /global/security ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'global/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityAccessRight(self,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/rights/{rights_id}/accessright ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityAccessRight(self,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def clearStatsCache(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /global/cache/statsclear ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/cache/statsclear"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clearStatsCache.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'global/cache/statsclear', 'form_params': [], 'method_name': 'clearStatsCache', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/cache/statsclear ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityRights(self,
                          security_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/rights ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}], 'method_path': 'global/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /global/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getGlobalContainer(self,
                           **kwargs):
        """
        [ HTTP: GET /global/container ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/container"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getGlobalContainer.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'global/container', 'form_params': [], 'method_name': 'getGlobalContainer', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /global/container ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityRights(self,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/rights/{rights_id} ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUser(self,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/user/{user_id} ]

        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/user/%(user_id)s"
        path_params = {"security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'global/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class resources:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getCategoriesXML(self,
                         **kwargs):
        """
        [ HTTP: GET /resources ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "resources"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCategoriesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'resources', 'form_params': [], 'method_name': 'getCategoriesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /resources ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class configuration:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /configuration/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'configuration/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getProperty(self,
                    configuration_id,
                    property_propid=None,
                    **kwargs):
        """
        [ HTTP: GET /configuration/{id}/property/{propid} ]

        @param configuration_id: configuration_id
        @type configuration_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/%(id)s/property/%(propid)s"
        path_params = {"id": configuration_id,
                       "propid": property_propid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProperty.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}], 'method_path': 'configuration/%(id)s/property/%(propid)s', 'form_params': [], 'method_name': 'getProperty', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/{id}/property/{propid} ]', 'method_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getConfiguation(self,
                        configuration_id=None,
                        **kwargs):
        """
        [ HTTP: GET /configuration/{id} ]

        @param configuration_id: configuration_id
        @type configuration_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/%(id)s"
        path_params = {"id": configuration_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getConfiguation.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'configuration/%(id)s', 'form_params': [], 'method_name': 'getConfiguation', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     configuration_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/{id}/export ]

        @param configuration_id: configuration_id
        @type configuration_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/%(id)s/export"
        path_params = {"id": configuration_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /configuration/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getConfigurations(self,
                          **kwargs):
        """
        [ HTTP: GET /configuration ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getConfigurations.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration', 'form_params': [], 'method_name': 'getConfigurations', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getProperties(self,
                      configuration_id,
                      **kwargs):
        """
        [ HTTP: GET /configuration/{id}/property ]

        @param configuration_id: configuration_id
        @type configuration_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/%(id)s/property"
        path_params = {"id": configuration_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProperties.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'configuration/%(id)s/property', 'form_params': [], 'method_name': 'getProperties', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/{id}/property ]', 'method_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def setProperty(self,
                    configuration_id,
                    property_propid=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /configuration/{id}/property/{propid} ]

        @param configuration_id: configuration_id
        @type configuration_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/%(id)s/property/%(propid)s"
        path_params = {"id": configuration_id,
                       "propid": property_propid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setProperty.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}], 'method_path': 'configuration/%(id)s/property/%(propid)s', 'form_params': [], 'method_name': 'setProperty', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/{id}/property/{propid} ]', 'method_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'configuration/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /configuration/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def setPropertyHtmlForm(self,
                            configuration_id,
                            property_propid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /configuration/{id}/property/{propid} ]

        @param configuration_id: configuration_id
        @type configuration_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/%(id)s/property/%(propid)s"
        path_params = {"id": configuration_id,
                       "propid": property_propid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setPropertyHtmlForm.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}], 'method_path': 'configuration/%(id)s/property/%(propid)s', 'form_params': [], 'method_name': 'setPropertyHtmlForm', 'custom_headers': {'Content-Type': 'application/x-www-form-urlencoded'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /configuration/{id}/property/{propid} ]', 'method_params': [{'defaultValue': None, 'alias': 'configuration_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'property_propid', 'kind': 'xs:int', 'required': False, 'name': 'propid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class targetcloud:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTargetCloud(self,
                       targetcloud_id=None,
                       **kwargs):
        """
        [ HTTP: GET /targetcloud/{id} ]

        @param targetcloud_id: targetcloud_id
        @type targetcloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "targetcloud/%(id)s"
        path_params = {"id": targetcloud_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTargetCloud.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'targetcloud/%(id)s', 'form_params': [], 'method_name': 'getTargetCloud', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /targetcloud/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'targetcloud_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTargetCloudsXML(self,
                           **kwargs):
        """
        [ HTTP: GET /targetcloud ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "targetcloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTargetCloudsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'targetcloud', 'form_params': [], 'method_name': 'getTargetCloudsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /targetcloud ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class cloudtype:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createModel(self,
                    cloudtype_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /cloudtype/{id}/model ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s/model', 'form_params': [], 'method_name': 'createModel', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /cloudtype/{id}/model ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCloudType(self,
                     cloudtype_id=None,
                     **kwargs):
        """
        [ HTTP: GET /cloudtype/{id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s', 'form_params': [], 'method_name': 'getCloudType', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteModel(self,
                    cloudtype_id,
                    model_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /cloudtype/{id}/model/{model_id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/%(model_id)s"
        path_params = {"id": cloudtype_id,
                       "model_id": model_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}], 'method_path': 'cloudtype/%(id)s/model/%(model_id)s', 'form_params': [], 'method_name': 'deleteModel', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /cloudtype/{id}/model/{model_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateCloudType(self,
                        cloudtype_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /cloudtype/{id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCloudType.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s', 'form_params': [], 'method_name': 'updateCloudType', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /cloudtype/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getModel(self,
                 cloudtype_id,
                 model_id=None,
                 **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model/{model_id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/%(model_id)s"
        path_params = {"id": cloudtype_id,
                       "model_id": model_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModel.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}], 'method_path': 'cloudtype/%(id)s/model/%(model_id)s', 'form_params': [], 'method_name': 'getModel', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model/{model_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'model_id', 'kind': 'xs:int', 'required': False, 'name': 'model_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchCloudTypeModelsXML(self,
                                 cloudtype_id,
                                 **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model/search ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/search"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudTypeModelsXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s/model/search', 'form_params': [], 'method_name': 'searchCloudTypeModelsXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model/search ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getModels(self,
                  cloudtype_id,
                  **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModels.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'cloudtype/%(id)s/model', 'form_params': [], 'method_name': 'getModels', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model ]', 'method_params': [{'defaultValue': None, 'alias': 'cloudtype_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getCloudTypes(self,
                      **kwargs):
        """
        [ HTTP: GET /cloudtype ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudTypes.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'cloudtype', 'form_params': [], 'method_name': 'getCloudTypes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /cloudtype ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class dhcpoptions:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def exportAction(self,
                     dhcpoptions_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /dhcpoptions/{id}/export ]

        @param dhcpoptions_id: dhcpoptions_id
        @type dhcpoptions_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/%(id)s/export"
        path_params = {"id": dhcpoptions_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'dhcpoptions/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /dhcpoptions/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'dhcpoptions/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getDhcpOptions(self,
                       dhcpoptions_id=None,
                       **kwargs):
        """
        [ HTTP: GET /dhcpoptions/{id} ]

        @param dhcpoptions_id: dhcpoptions_id
        @type dhcpoptions_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/%(id)s"
        path_params = {"id": dhcpoptions_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDhcpOptions.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'dhcpoptions/%(id)s', 'form_params': [], 'method_name': 'getDhcpOptions', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'dhcpoptions_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getDhcpOptionsList(self,
                           **kwargs):
        """
        [ HTTP: GET /dhcpoptions ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDhcpOptionsList.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'dhcpoptions', 'form_params': [], 'method_name': 'getDhcpOptionsList', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /dhcpoptions ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class projectrole:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getProjectRole(self,
                       projectrole_id=None,
                       **kwargs):
        """
        [ HTTP: GET /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'projectrole/%(id)s', 'form_params': [], 'method_name': 'getProjectRole', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /projectrole/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'projectrole/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /projectrole/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchRoles(self,
                    **kwargs):
        """
        [ HTTP: GET /projectrole/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchRoles.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole/search', 'form_params': [], 'method_name': 'searchRoles', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateProjectRole(self,
                          projectrole_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'projectrole/%(id)s', 'form_params': [], 'method_name': 'updateProjectRole', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /projectrole/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /projectrole/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /projectrole/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createProjectRole(self,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /projectrole ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole', 'form_params': [], 'method_name': 'createProjectRole', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /projectrole ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     projectrole_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /projectrole/{id}/export ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s/export"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'projectrole/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteProjectRole(self,
                          projectrole_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteProjectRole.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'projectrole/%(id)s', 'form_params': [], 'method_name': 'deleteProjectRole', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /projectrole/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'projectrole_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /projectrole/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getProjectRolesXML(self,
                           **kwargs):
        """
        [ HTTP: GET /projectrole ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjectRolesXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'projectrole', 'form_params': [], 'method_name': 'getProjectRolesXML', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /projectrole ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class template:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def attachPackage(self,
                      template_id,
                      package_pkgid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /template/{id}/package/{pkgid} ]

        @param template_id: template_id
        @type template_id: str
        @param package_pkgid: package_pkgid
        @type package_pkgid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package/%(pkgid)s"
        path_params = {"id": template_id,
                       "pkgid": package_pkgid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'package_pkgid', 'kind': 'xs:int', 'required': False, 'name': 'pkgid'}], 'method_path': 'template/%(id)s/package/%(pkgid)s', 'form_params': [], 'method_name': 'attachPackage', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/package/{pkgid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'package_pkgid', 'kind': 'xs:int', 'required': False, 'name': 'pkgid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removePolicy(self,
                     template_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /template/{id}/policy/{policyid} ]

        @param template_id: template_id
        @type template_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy/%(policyid)s"
        path_params = {"id": template_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'template/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteTemplate(self,
                       template_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'template/%(id)s', 'form_params': [], 'method_name': 'deleteTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScaleUpPolicy(self,
                         template_id,
                         **kwargs):
        """
        [ HTTP: GET /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'getScaleUpPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createScaleUpPolicy(self,
                            template_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'createScaleUpPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPolicyAssignments(self,
                                template_id,
                                **kwargs):
        """
        [ HTTP: GET /template/{id}/policyassignment/search ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policyassignment/search"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     template_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/export ]

        @param template_id: template_id
        @type template_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/export"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTemplates(self,
                     **kwargs):
        """
        [ HTTP: GET /template ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'template', 'form_params': [], 'method_name': 'getTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVolume(self,
                     template_id,
                     volume_volid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /template/{id}/volume/{volid} ]

        @param template_id: template_id
        @type template_id: str
        @param volume_volid: volume_volid
        @type volume_volid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume/%(volid)s"
        path_params = {"id": template_id,
                       "volid": volume_volid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'volume_volid', 'kind': 'xs:int', 'required': False, 'name': 'volid'}], 'method_path': 'template/%(id)s/volume/%(volid)s', 'form_params': [], 'method_name': 'deleteVolume', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/volume/{volid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'volume_volid', 'kind': 'xs:int', 'required': False, 'name': 'volid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateVariable(self,
                       template_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /template/{id}/variable/{variable_id} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAliasByName(self,
                          template_id,
                          alias_name=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /template/{id}/alias/{name: [a-zA-Z0-9_\-]+} ]

        @param template_id: template_id
        @type template_id: str
        @param alias_name: alias_name
        @type alias_name: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/alias/%(name: [a-zA-Z0-9_\-]+)s"
        path_params = {"id": template_id,
                       "name": alias_name}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAliasByName.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}], 'method_path': 'template/%(id)s/alias/%(name: [a-zA-Z0-9_\\-]+)s', 'form_params': [], 'method_name': 'updateAliasByName', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/alias/{name: [a-zA-Z0-9_\\-]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_name', 'kind': 'xs:string', 'required': False, 'name': 'name'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updatescaleDownPolicy(self,
                              template_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatescaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'updatescaleDownPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVariable(self,
                       template_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /template/{id}/variable/{variable_id} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removePackage(self,
                      template_id,
                      packageid=None,
                      **kwargs):
        """
        [ HTTP: DELETE /template/{id}/package/{packageid} ]

        @param template_id: template_id
        @type template_id: str
        @param packageid: packageid
        @type packageid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package/%(packageid)s"
        path_params = {"id": template_id,
                       "packageid": packageid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'packageid', 'kind': 'xs:int', 'required': False, 'name': 'packageid'}], 'method_path': 'template/%(id)s/package/%(packageid)s', 'form_params': [], 'method_name': 'removePackage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/package/{packageid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'packageid', 'kind': 'xs:int', 'required': False, 'name': 'packageid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addPackage(self,
                   template_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /template/{id}/package ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/package', 'form_params': [], 'method_name': 'addPackage', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachPolicy(self,
                     template_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /template/{id}/policy/{policyid} ]

        @param template_id: template_id
        @type template_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy/%(policyid)s"
        path_params = {"id": template_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'template/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createVariable(self,
                       template_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /template/{id}/variable ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteScaleUpPolicy(self,
                            template_id,
                            **kwargs):
        """
        [ HTTP: DELETE /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'deleteScaleUpPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def waitForInstances(self,
                         template_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /template/{id}/compute/wait ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/compute/wait"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    waitForInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/compute/wait', 'form_params': [], 'method_name': 'waitForInstances', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/compute/wait ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createscaleDownPolicy(self,
                              template_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createscaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'createscaleDownPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getscaleDownPolicy(self,
                           template_id,
                           **kwargs):
        """
        [ HTTP: GET /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getscaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'getscaleDownPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariable(self,
                    template_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/variable/{variable_id} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getInstances(self,
                     template_id,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/compute ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/compute"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstances.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/compute', 'form_params': [], 'method_name': 'getInstances', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/compute ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /template/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'template/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateScaleUpPolicy(self,
                            template_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateScaleUpPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleUp', 'form_params': [], 'method_name': 'updateScaleUpPolicy', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id}/scaleUp ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariables(self,
                     template_id,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/variable ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/variable', 'form_params': [], 'method_name': 'getVariables', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateTemplate(self,
                       template_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'template/%(id)s', 'form_params': [], 'method_name': 'updateTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /template/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def decryptVariable(self,
                        template_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /template/{id}/variable/{variable_id}/decrypt ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'template/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def releaseTemplate(self,
                        template_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /template/{id}/release ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/release"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/release', 'form_params': [], 'method_name': 'releaseTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVolumes(self,
                   template_id,
                   **kwargs):
        """
        [ HTTP: GET /template/{id}/volume ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumes.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/volume', 'form_params': [], 'method_name': 'getVolumes', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/volume ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAlias(self,
                    template_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /template/{id}/alias/{alias_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/alias/%(alias_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'template/%(id)s/alias/%(alias_id: [0-9]+)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/alias/{alias_id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPackages(self,
                    template_id,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/package ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deletescaleDownPolicy(self,
                              template_id,
                              **kwargs):
        """
        [ HTTP: DELETE /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletescaleDownPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/scaleDown', 'form_params': [], 'method_name': 'deletescaleDownPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /template/{id}/scaleDown ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicies(self,
                    template_id,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/policy ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def rebootTemplate(self,
                       template_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /template/{id}/restart ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/restart"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/restart', 'form_params': [], 'method_name': 'rebootTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addVolume(self,
                  template_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /template/{id}/volume ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addVolume.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/volume', 'form_params': [], 'method_name': 'addVolume', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/volume ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTemplate(self,
                    template_id=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'template/%(id)s', 'form_params': [], 'method_name': 'getTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchTemplates(self,
                        **kwargs):
        """
        [ HTTP: GET /template/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'template/search', 'form_params': [], 'method_name': 'searchTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /template/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def stopTemplate(self,
                     template_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /template/{id}/stop ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/stop"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/stop', 'form_params': [], 'method_name': 'stopTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def startTemplate(self,
                      template_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /template/{id}/start ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/start"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'template/%(id)s/start', 'form_params': [], 'method_name': 'startTemplate', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /template/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'template_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class project:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getProject(self,
                   project_id=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'project/%(id)s', 'form_params': [], 'method_name': 'getProject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTopologies(self,
                      project_id,
                      **kwargs):
        """
        [ HTTP: GET /project/{id}/topology ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/topology"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/topology', 'form_params': [], 'method_name': 'getTopologies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDActionXML(self,
                          project_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /project/{id}/import ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/import"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/import', 'form_params': [], 'method_name': 'importIDActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getSecurity(self,
                    project_id,
                    security_id=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/security/{security_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'getSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def releaseProject(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/release ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/release"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/release', 'form_params': [], 'method_name': 'releaseProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/release ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def removePolicy(self,
                     project_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /project/{id}/policy/{policyid} ]

        @param project_id: project_id
        @type project_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy/%(policyid)s"
        path_params = {"id": project_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'project/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'removePolicy', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchPolicyAssignments(self,
                                project_id,
                                **kwargs):
        """
        [ HTTP: GET /project/{id}/policyassignment/search ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policyassignment/search"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/policyassignment/search', 'form_params': [], 'method_name': 'searchPolicyAssignments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/policyassignment/search ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteAlias(self,
                    project_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'deleteAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getTemplates(self,
                     project_id,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/template ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/template"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplates.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/template', 'form_params': [], 'method_name': 'getTemplates', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     project_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/export ]

        @param project_id: project_id
        @type project_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/export"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getProjects(self,
                    **kwargs):
        """
        [ HTTP: GET /project ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project', 'form_params': [], 'method_name': 'getProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createAlias(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/alias ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/alias', 'form_params': [], 'method_name': 'createAlias', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateVariable(self,
                       project_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/{project_id}/variable/{variable_id} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(project_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'updateVariable', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{project_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def startProject(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/start ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/start"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/start', 'form_params': [], 'method_name': 'startProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/start ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteVariable(self,
                       project_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /project/{project_id}/variable/{variable_id} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(project_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'deleteVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{project_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPolicies(self,
                    project_id,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/policy ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/policy', 'form_params': [], 'method_name': 'getPolicies', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/policy ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUserGroup(self,
                                project_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'form_params': [], 'method_name': 'deleteSecurityUserGroup', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'usergroup_id', 'kind': 'xs:int', 'required': False, 'name': 'usergroup_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def attachPolicy(self,
                     project_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /project/{id}/policy/{policyid} ]

        @param project_id: project_id
        @type project_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy/%(policyid)s"
        path_params = {"id": project_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}], 'method_path': 'project/%(id)s/policy/%(policyid)s', 'form_params': [], 'method_name': 'attachPolicy', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/policy/{policyid} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'policyid', 'kind': 'xs:int', 'required': False, 'name': 'policyid'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createVariable(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/variable ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/variable', 'form_params': [], 'method_name': 'createVariable', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurity(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/security ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/security', 'form_params': [], 'method_name': 'addSecurity', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTopology(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/topology ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/topology"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopology.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/topology', 'form_params': [], 'method_name': 'createTopology', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/topology ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createEnvironment(self,
                          project_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /project/{id}/environment ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/environment"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createEnvironment.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/environment', 'form_params': [], 'method_name': 'createEnvironment', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/environment ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariable(self,
                    project_id,
                    variable_id=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{project_id}/variable/{variable_id} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(project_id)s/variable/%(variable_id)s', 'form_params': [], 'method_name': 'getVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{project_id}/variable/{variable_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'project_id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityAccessRight(self,
                                  project_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'form_params': [], 'method_name': 'deleteSecurityAccessRight', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': True, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'accessright_id', 'kind': 'xs:int', 'required': False, 'name': 'accessright_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityRights(self,
                             project_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'form_params': [], 'method_name': 'deleteSecurityRights', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurityUser(self,
                           project_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/user/{user_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/user/%(user_id)s', 'form_params': [], 'method_name': 'deleteSecurityUser', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/user/{user_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'user_id', 'kind': 'xs:int', 'required': False, 'name': 'user_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteSecurity(self,
                       project_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s', 'form_params': [], 'method_name': 'deleteSecurity', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUserGroup(self,
                             project_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/usergroup ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/usergroup', 'form_params': [], 'method_name': 'addSecurityUserGroup', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/usergroup ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createTemplate(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/template ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/template"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplate.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/template', 'form_params': [], 'method_name': 'createTemplate', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/template ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getVariables(self,
                     project_id,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/variable ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/variable', 'form_params': [], 'method_name': 'getVariables', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/variable ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def cloneProject(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/clone ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/clone"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/clone', 'form_params': [], 'method_name': 'cloneProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/clone ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createProject(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /project ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project', 'form_params': [], 'method_name': 'createProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAlias(self,
                 project_id,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'getAlias', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateProject(self,
                      project_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'project/%(id)s', 'form_params': [], 'method_name': 'updateProject', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteProject(self,
                      project_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'project/%(id)s', 'form_params': [], 'method_name': 'deleteProject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /project/{id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def stopProject(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/stop ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/stop"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/stop', 'form_params': [], 'method_name': 'stopProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/stop ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityRights(self,
                          project_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/rights ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights', 'form_params': [], 'method_name': 'addSecurityRights', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/rights ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def decryptVariable(self,
                        project_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /project/{id}/variable/{variable_id}/decrypt ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}], 'method_path': 'project/%(id)s/variable/%(variable_id)s/decrypt', 'form_params': [], 'method_name': 'decryptVariable', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/variable/{variable_id}/decrypt ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'variable_id', 'kind': 'xs:int', 'required': False, 'name': 'variable_id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /project/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /project/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'project/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityAccessRight(self,
                               project_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'form_params': [], 'method_name': 'addSecurityAccessRight', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': True, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'rights_id', 'kind': 'xs:int', 'required': False, 'name': 'rights_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createPackage(self,
                      project_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /project/{id}/package ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/package"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPackage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/package', 'form_params': [], 'method_name': 'createPackage', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateAlias(self,
                    project_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'form_params': [], 'method_name': 'updateAlias', 'custom_headers': {'Content-Type': '*/*'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/alias/{alias_id} ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'alias_id', 'kind': 'xs:int', 'required': False, 'name': 'alias_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getPackages(self,
                    project_id,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/package ]

        @param project_id: project_id
        @type project_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/package"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/package', 'form_params': [], 'method_name': 'getPackages', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/package ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getScripts(self,
                   project_id,
                   version=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id}/script ]

        @param project_id: project_id
        @type project_id: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/script"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScripts.context = {'query_params': [{'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/script', 'form_params': [], 'method_name': 'getScripts', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'version', 'kind': 'xs:string', 'required': False, 'name': 'version'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getEnvironments(self,
                        project_id,
                        **kwargs):
        """
        [ HTTP: GET /project/{id}/environment ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/environment"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironments.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/environment', 'form_params': [], 'method_name': 'getEnvironments', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/environment ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /project/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def createScript(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/script ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/script"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScript.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/script', 'form_params': [], 'method_name': 'createScript', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/script ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def restartProject(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/restart ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/restart"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    restartProject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/restart', 'form_params': [], 'method_name': 'restartProject', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/restart ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def addSecurityUser(self,
                        project_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/user ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/user"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}], 'method_path': 'project/%(id)s/security/%(security_id)s/user', 'form_params': [], 'method_name': 'addSecurityUser', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'POST', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/user ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'security_id', 'kind': 'xs:int', 'required': False, 'name': 'security_id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importIDAction(self,
                       project_id,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/{id}/import ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/import"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/import', 'form_params': [], 'method_name': 'importIDAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /project/{id}/import ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def searchProjects(self,
                       **kwargs):
        """
        [ HTTP: GET /project/search ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProjects.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'project/search', 'form_params': [], 'method_name': 'searchProjects', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/search ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getAliases(self,
                   project_id,
                   **kwargs):
        """
        [ HTTP: GET /project/{id}/alias ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'project/%(id)s/alias', 'form_params': [], 'method_name': 'getAliases', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /project/{id}/alias ]', 'method_params': [{'defaultValue': None, 'alias': 'project_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

class repository:
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction(self,
                     data=None,
                     files=None,
                     **kwargs):
        """
        [ HTTP: PUT /repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction.context = {'query_params': [], 'hasFiles': True, 'path_params': [], 'method_path': 'repository/import', 'form_params': [], 'method_name': 'importAction', 'custom_headers': {'Content-Type': 'application/x-zip'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': 'files', 'kind': 'str', 'required': False, 'name': 'files'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def putObject(self,
                  repository_id,
                  path=None,
                  Content_Length=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: PUT /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param Content_Length: Content_Length
        @type Content_Length: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"Content_Length": Content_Length}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/octet-stream'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    putObject.context = {'query_params': [{'defaultValue': None, 'alias': 'Content_Length', 'kind': 'xs:long', 'required': False, 'name': 'Content_Length'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'putObject', 'custom_headers': {'Content-Type': 'application/octet-stream'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': 'Content_Length', 'kind': 'xs:long', 'required': False, 'name': 'Content_Length'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def importActionXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importActionXML.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'repository/import', 'form_params': [], 'method_name': 'importActionXML', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/import ]', 'method_params': [{'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteRepository(self,
                         repository_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'deleteRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateRepositoryUsage(self,
                              repository_id=None,
                              usage=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param usage: usage
        @type usage: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRepositoryUsage.context = {'query_params': [{'defaultValue': None, 'alias': 'usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'updateRepositoryUsage', 'custom_headers': {}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def updateRepository(self,
                         repository_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'updateRepository', 'custom_headers': {'Content-Type': 'application/xml'}, 'result': 'result', 'hasData': True, 'method_kind': 'PUT', 'method_docs': '[ HTTP: PUT /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': 'data', 'kind': 'str', 'required': False, 'name': 'data'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getRepository(self,
                      repository_id=None,
                      **kwargs):
        """
        [ HTTP: GET /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepository.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}], 'method_path': 'repository/%(id: [0-9]+)s', 'form_params': [], 'method_name': 'getRepository', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id: [0-9]+} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': False, 'name': 'id'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getObject(self,
                  repository_id,
                  path=None,
                  **kwargs):
        """
        [ HTTP: GET /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getObject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'getObject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getRepositories(self,
                        **kwargs):
        """
        [ HTTP: GET /repository ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositories.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'repository', 'form_params': [], 'method_name': 'getRepositories', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getListing(self,
                   repository_id,
                   path=None,
                   **kwargs):
        """
        [ HTTP: GET /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getListing.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'getListing', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAction(self,
                     repository_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /repository/{id}/export ]

        @param repository_id: repository_id
        @type repository_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/export"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}], 'method_path': 'repository/%(id)s/export', 'form_params': [], 'method_name': 'exportAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{id}/export ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'recursive', 'kind': 'xs:boolean', 'required': False, 'name': 'recursive'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def getRepositoriesByUsage(self,
                               repository_usage=None,
                               **kwargs):
        """
        [ HTTP: GET /repository/{usage: (templates)|(instances)|(storage)|(attachments)|(backups)} ]

        @param repository_usage: repository_usage
        @type repository_usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(usage: (templates)|(instances)|(storage)|(attachments)|(backups))s"
        path_params = {"usage": repository_usage}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositoriesByUsage.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}], 'method_path': 'repository/%(usage: (templates)|(instances)|(storage)|(attachments)|(backups))s', 'form_params': [], 'method_name': 'getRepositoriesByUsage', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/{usage: (templates)|(instances)|(storage)|(attachments)|(backups)} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_usage', 'kind': 'xs:string', 'required': False, 'name': 'usage'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def deleteObject(self,
                     repository_id,
                     path=None,
                     **kwargs):
        """
        [ HTTP: DELETE /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteObject.context = {'query_params': [], 'hasFiles': False, 'path_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}], 'method_path': 'repository/%(id)s/%(path:.*)s', 'form_params': [], 'method_name': 'deleteObject', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'DELETE', 'method_docs': '[ HTTP: DELETE /repository/{id}/{path:.*} ]', 'method_params': [{'defaultValue': None, 'alias': 'repository_id', 'kind': 'xs:int', 'required': True, 'name': 'id'}, {'defaultValue': None, 'alias': 'path', 'kind': 'xs:string', 'required': False, 'name': 'path'}, {'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /repository/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in list(path_params.items()):
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'hasFiles': False, 'path_params': [], 'method_path': 'repository/export', 'form_params': [], 'method_name': 'exportAllAction', 'custom_headers': {}, 'result': 'result', 'hasData': False, 'method_kind': 'GET', 'method_docs': '[ HTTP: GET /repository/export ]', 'method_params': [{'defaultValue': None, 'alias': '**kwargs', 'kind': 'str', 'required': False, 'name': '**kwargs'}]}
