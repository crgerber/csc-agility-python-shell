# === AUTO-GENERATED - DO NOT EDIT ===

# --------------------------------------------------------------------------
# -------------------------------------------------------------------
#           ***********************************************
#           ***  THIS IS GENERATED CODE: DO NOT MODIFY  ***
#           ***********************************************
#
#             Copyright (c) 2009-2014 CSC, Incorporated
#                      All Rights Reserved
#   THIS WORK CONTAINS CONFIDENTIAL PROPPRIETARY INFORMATION AND
#   TRADE SECRETS WHICH ARE THE PROPERTY OF CSC.  ALL USE,
#   DISCLOSURE AND/OR REPRODUCTION NOT EXPRESSLY AUTHORIZED BY
#   CSC IS PROHIBITED.
# -------------------------------------------------------------------
# --------------------------------------------------------------------------

"""
Web service API methods. This module is fully auto-generated
"""
import os
import logging
COMPONENT_NAME = 'agility-client'
from logger import getLogger
logger = getLogger(COMPONENT_NAME)
from core.restclient.connection import RESTException
from core.http.decorators import download
from core.agility.common.service import Endpoint

class launchitem(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deployment_1(self,
                     launchitem_id,
                     start=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/deployment ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param start: start
        @type start: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/deployment"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"start": start}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deployment_1.context = {'query_params': [{'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}], 'method_name': 'deployment_1', 'method_docs': '[ HTTP: POST /launchitem/{id}/deployment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitem/%(id)s/deployment', 'method_kind': 'POST'}

    @download
    def deployment_2(self,
                     launchitem_id,
                     deployment_locationId=None,
                     start=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/deployment/{locationId} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param deployment_locationId: deployment_locationId
        @type deployment_locationId: str
        @param start: start
        @type start: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/deployment/%(locationId)s"
        path_params = {"id": launchitem_id,
                       "locationId": deployment_locationId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"start": start}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deployment_2.context = {'query_params': [{'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}], 'method_name': 'deployment_2', 'method_docs': '[ HTTP: POST /launchitem/{id}/deployment/{locationId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployment_locationId'}, {'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployment_locationId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/deployment/%(locationId)s', 'method_kind': 'POST'}

    @download
    def reject(self,
               launchitem_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /launchitem/{id}/reject ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/reject"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: PUT /launchitem/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitem/%(id)s/reject', 'method_kind': 'PUT'}

    @download
    def deploy_2(self,
                 launchitem_id,
                 start=None,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/deploy ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param start: start
        @type start: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/deploy"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"start": start}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deploy_2.context = {'query_params': [{'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}], 'method_name': 'deploy_2', 'method_docs': '[ HTTP: POST /launchitem/{id}/deploy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitem/%(id)s/deploy', 'method_kind': 'POST'}

    @download
    def approval(self,
                 launchitem_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/approval ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/approval"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /launchitem/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitem/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def rejection(self,
                  launchitem_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/rejection ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/rejection"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /launchitem/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitem/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def deploy_1(self,
                 launchitem_id,
                 deploy_locationId=None,
                 start=None,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/deploy/{locationId} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param deploy_locationId: deploy_locationId
        @type deploy_locationId: str
        @param start: start
        @type start: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/deploy/%(locationId)s"
        path_params = {"id": launchitem_id,
                       "locationId": deploy_locationId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"start": start}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deploy_1.context = {'query_params': [{'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}], 'method_name': 'deploy_1', 'method_docs': '[ HTTP: POST /launchitem/{id}/deploy/{locationId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploy_locationId'}, {'name': 'start', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'start'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploy_locationId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/deploy/%(locationId)s', 'method_kind': 'POST'}

    @download
    def deleteLaunchItem(self,
                         launchitem_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /launchitem/{id} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteLaunchItem.context = {'query_params': [], 'method_name': 'deleteLaunchItem', 'method_docs': '[ HTTP: DELETE /launchitem/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitem_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s', 'method_kind': 'DELETE'}

    @download
    def startLaunchItem(self,
                        launchitem_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/start ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/start"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startLaunchItem.context = {'query_params': [], 'method_name': 'startLaunchItem', 'method_docs': '[ HTTP: POST /launchitem/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/start', 'method_kind': 'POST'}

    @download
    def searchLaunchItems(self,
                          forLaunchpad=None,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /launchitem/search ]

        @param forLaunchpad: forLaunchpad
        @type forLaunchpad: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"forLaunchpad": forLaunchpad,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchLaunchItems.context = {'query_params': [{'name': 'forLaunchpad', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'forLaunchpad'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchLaunchItems', 'method_docs': '[ HTTP: GET /launchitem/search ]', 'result': 'result', 'method_params': [{'name': 'forLaunchpad', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'forLaunchpad'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/search', 'method_kind': 'GET'}

    @download
    def stopLaunchItem(self,
                       launchitem_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/stop ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/stop"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopLaunchItem.context = {'query_params': [], 'method_name': 'stopLaunchItem', 'method_docs': '[ HTTP: POST /launchitem/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def approve(self,
                launchitem_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /launchitem/{id}/approve ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/approve"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: PUT /launchitem/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitem/%(id)s/approve', 'method_kind': 'PUT'}

    @download
    def getLaunchItem(self,
                      launchitem_id=None,
                      fields=None,
                      filterGroup=None,
                      limit=None,
                      offset=None,
                      orderBy=None,
                      usage=None,
                      _select=None,
                      _top=None,
                      _skip=None,
                      _orderby=None,
                      **kwargs):
        """
        [ HTTP: GET /launchitem/{id} ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param _select: _select
        @type _select: str
        @param _top: _top
        @type _top: str
        @param _skip: _skip
        @type _skip: str
        @param _orderby: _orderby
        @type _orderby: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage,
                        "_select": _select,
                        "_top": _top,
                        "_skip": _skip,
                        "_orderby": _orderby}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLaunchItem.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '_select', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_select'}, {'name': '_top', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_top'}, {'name': '_skip', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_skip'}, {'name': '_orderby', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_orderby'}], 'method_name': 'getLaunchItem', 'method_docs': '[ HTTP: GET /launchitem/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitem_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '_select', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_select'}, {'name': '_top', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_top'}, {'name': '_skip', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_skip'}, {'name': '_orderby', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_orderby'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s', 'method_kind': 'GET'}

    @download
    def getServiceInstances(self,
                            launchitem_id,
                            fields=None,
                            **kwargs):
        """
        [ HTTP: GET /launchitem/{id}/serviceinstances ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/serviceinstances"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getServiceInstances', 'method_docs': '[ HTTP: GET /launchitem/{id}/serviceinstances ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/serviceinstances', 'method_kind': 'GET'}

    @download
    def restartLaunchItem(self,
                          launchitem_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/restart ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/restart"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    restartLaunchItem.context = {'query_params': [], 'method_name': 'restartLaunchItem', 'method_docs': '[ HTTP: POST /launchitem/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def releaseLaunchItem(self,
                          launchitem_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /launchitem/{id}/release ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/release"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseLaunchItem.context = {'query_params': [], 'method_name': 'releaseLaunchItem', 'method_docs': '[ HTTP: POST /launchitem/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/release', 'method_kind': 'POST'}

    @download
    def getLaunchItems(self,
                       forLaunchpad=None,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /launchitem ]

        @param forLaunchpad: forLaunchpad
        @type forLaunchpad: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"forLaunchpad": forLaunchpad,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLaunchItems.context = {'query_params': [{'name': 'forLaunchpad', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'forLaunchpad'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'getLaunchItems', 'method_docs': '[ HTTP: GET /launchitem ]', 'result': 'result', 'method_params': [{'name': 'forLaunchpad', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'forLaunchpad'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem', 'method_kind': 'GET'}

    @download
    def getInstances(self,
                     launchitem_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /launchitem/{id}/instances ]

        @param launchitem_id: launchitem_id
        @type launchitem_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitem/%(id)s/instances"
        path_params = {"id": launchitem_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getInstances', 'method_docs': '[ HTTP: GET /launchitem/{id}/instances ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitem_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitem/%(id)s/instances', 'method_kind': 'GET'}

class dhcpoptions(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getDhcpOptionsList(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /dhcpoptions ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDhcpOptionsList.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDhcpOptionsList', 'method_docs': '[ HTTP: GET /dhcpoptions ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'dhcpoptions', 'method_kind': 'GET'}

    @download
    def getDhcpOptions(self,
                       dhcpoptions_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /dhcpoptions/{id} ]

        @param dhcpoptions_id: dhcpoptions_id
        @type dhcpoptions_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/%(id)s"
        path_params = {"id": dhcpoptions_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDhcpOptions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDhcpOptions', 'method_docs': '[ HTTP: GET /dhcpoptions/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'dhcpoptions_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'dhcpoptions_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'dhcpoptions/%(id)s', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     dhcpoptions_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /dhcpoptions/{id}/export ]

        @param dhcpoptions_id: dhcpoptions_id
        @type dhcpoptions_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/%(id)s/export"
        path_params = {"id": dhcpoptions_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /dhcpoptions/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'dhcpoptions_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'dhcpoptions_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'dhcpoptions/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /dhcpoptions/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "dhcpoptions/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /dhcpoptions/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'dhcpoptions/export', 'method_kind': 'GET'}

class blueprint(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getBlueprints(self,
                      version=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /blueprint ]

        @param version: version
        @type version: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getBlueprints.context = {'query_params': [{'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getBlueprints', 'method_docs': '[ HTTP: GET /blueprint ]', 'result': 'result', 'method_params': [{'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint', 'method_kind': 'GET'}

    @download
    def searchBlueprints(self,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /blueprint/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchBlueprints.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchBlueprints', 'method_docs': '[ HTTP: GET /blueprint/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/search', 'method_kind': 'GET'}

    @download
    def approval(self,
                 blueprint_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/approval ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/approval"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /blueprint/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def checkOut(self,
                 blueprint_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/checkout ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/checkout"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'method_name': 'checkOut', 'method_docs': '[ HTTP: POST /blueprint/{id}/checkout ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/checkout', 'method_kind': 'POST'}

    @download
    def deploy_2(self,
                 blueprint_id,
                 deploy_containerId=None,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deploy/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploy_containerId: deploy_containerId
        @type deploy_containerId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploy/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploy_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deploy_2.context = {'query_params': [], 'method_name': 'deploy_2', 'method_docs': '[ HTTP: POST /blueprint/{id}/deploy/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploy_containerId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploy_containerId'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/deploy/%(containerId)s', 'method_kind': 'POST'}

    @download
    def updateBlueprint(self,
                        blueprint_id=None,
                        force=None,
                        fields=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /blueprint/{id} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param force: force
        @type force: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"force": force,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateBlueprint.context = {'query_params': [{'name': 'force', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'force'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateBlueprint', 'method_docs': '[ HTTP: PUT /blueprint/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'blueprint_id'}, {'name': 'force', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'force'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s', 'method_kind': 'PUT'}

    @download
    def validateBlueprint(self,
                          randomize=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /blueprint/validate ]

        @param randomize: randomize
        @type randomize: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/validate"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"randomize": randomize}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    validateBlueprint.context = {'query_params': [{'name': 'randomize', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'randomize'}], 'method_name': 'validateBlueprint', 'method_docs': '[ HTTP: POST /blueprint/validate ]', 'result': 'result', 'method_params': [{'name': 'randomize', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'randomize'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/validate', 'method_kind': 'POST'}

    @download
    def clone(self,
              blueprint_id,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/clone ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/clone"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clone.context = {'query_params': [], 'method_name': 'clone', 'method_docs': '[ HTTP: POST /blueprint/{id}/clone ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/clone', 'method_kind': 'POST'}

    @download
    def approve(self,
                blueprint_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/approve ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/approve"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: POST /blueprint/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def checkIn_2(self,
                  blueprint_id,
                  checkin_locationId=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/checkin/{locationId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param checkin_locationId: checkin_locationId
        @type checkin_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/checkin/%(locationId)s"
        path_params = {"id": blueprint_id,
                       "locationId": checkin_locationId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn_2.context = {'query_params': [], 'method_name': 'checkIn_2', 'method_docs': '[ HTTP: POST /blueprint/{id}/checkin/{locationId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'checkin_locationId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'checkin_locationId'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/checkin/%(locationId)s', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     blueprint_id,
                     recursive=None,
                     multiEnvelope=None,
                     **kwargs):
        """
        [ HTTP: GET /blueprint/{id}/export ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param recursive: recursive
        @type recursive: str
        @param multiEnvelope: multiEnvelope
        @type multiEnvelope: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/export"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive,
                        "multiEnvelope": multiEnvelope}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': 'multiEnvelope', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'multiEnvelope'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /blueprint/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': 'multiEnvelope', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'multiEnvelope'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s/export', 'method_kind': 'GET'}

    @download
    def deleteSlot(self,
                   blueprint_slotId,
                   **kwargs):
        """
        [ HTTP: DELETE /blueprint/{slotId}/slot ]

        @param blueprint_slotId: blueprint_slotId
        @type blueprint_slotId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(slotId)s/slot"
        path_params = {"slotId": blueprint_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSlot.context = {'query_params': [], 'method_name': 'deleteSlot', 'method_docs': '[ HTTP: DELETE /blueprint/{slotId}/slot ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_slotId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(slotId)s/slot', 'method_kind': 'DELETE'}

    @download
    def deployDeprecated(self,
                         blueprint_id,
                         deploy_containerId=None,
                         policyIds=None,
                         logLevel=None,
                         **kwargs):
        """
        [ HTTP: GET /blueprint/{id}/deploy/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploy_containerId: deploy_containerId
        @type deploy_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploy/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploy_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deployDeprecated.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'deployDeprecated', 'method_docs': '[ HTTP: GET /blueprint/{id}/deploy/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploy_containerId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploy_containerId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s/deploy/%(containerId)s', 'method_kind': 'GET'}

    @download
    def getDeploymentPlan(self,
                          blueprint_id,
                          deploymentplan_containerId=None,
                          policyIds=None,
                          logLevel=None,
                          **kwargs):
        """
        [ HTTP: GET /blueprint/{id}/deploymentplan/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploymentplan/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploymentplan_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeploymentPlan.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'getDeploymentPlan', 'method_docs': '[ HTTP: GET /blueprint/{id}/deploymentplan/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploymentplan_containerId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploymentplan_containerId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s/deploymentplan/%(containerId)s', 'method_kind': 'GET'}

    @download
    def createDeployer(self,
                       blueprint_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deployer ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deployer"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDeployer.context = {'query_params': [], 'method_name': 'createDeployer', 'method_docs': '[ HTTP: POST /blueprint/{id}/deployer ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/deployer', 'method_kind': 'POST'}

    @download
    def reject(self,
               blueprint_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/reject ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/reject"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: POST /blueprint/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/reject', 'method_kind': 'POST'}

    @download
    def deleteBlueprint(self,
                        blueprint_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /blueprint/{id} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteBlueprint.context = {'query_params': [], 'method_name': 'deleteBlueprint', 'method_docs': '[ HTTP: DELETE /blueprint/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'blueprint_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s', 'method_kind': 'DELETE'}

    @download
    def exportAllAction(self,
                        multiEnvelope=None,
                        **kwargs):
        """
        [ HTTP: GET /blueprint/export ]

        @param multiEnvelope: multiEnvelope
        @type multiEnvelope: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"multiEnvelope": multiEnvelope}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'multiEnvelope', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'multiEnvelope'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /blueprint/export ]', 'result': 'result', 'method_params': [{'name': 'multiEnvelope', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'multiEnvelope'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/export', 'method_kind': 'GET'}

    @download
    def validateDeploymentPlan(self,
                               blueprint_id,
                               deploymentplan_containerId=None,
                               policyIds=None,
                               logLevel=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deploymentplan/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deploymentplan/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deploymentplan_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    validateDeploymentPlan.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'validateDeploymentPlan', 'method_docs': '[ HTTP: POST /blueprint/{id}/deploymentplan/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploymentplan_containerId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploymentplan_containerId'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/deploymentplan/%(containerId)s', 'method_kind': 'POST'}

    @download
    def rejection(self,
                  blueprint_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/rejection ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/rejection"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /blueprint/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def deploy_1(self,
                 blueprint_id,
                 simpledeploy_containerId=None,
                 policyIds=None,
                 logLevel=None,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/simpledeploy/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param simpledeploy_containerId: simpledeploy_containerId
        @type simpledeploy_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/simpledeploy/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": simpledeploy_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deploy_1.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'deploy_1', 'method_docs': '[ HTTP: POST /blueprint/{id}/simpledeploy/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'simpledeploy_containerId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'simpledeploy_containerId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s/simpledeploy/%(containerId)s', 'method_kind': 'POST'}

    @download
    def getAllVersions(self,
                       blueprint_slotId,
                       fields=None,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /blueprint/{slotId}/version ]

        @param blueprint_slotId: blueprint_slotId
        @type blueprint_slotId: str
        @param fields: fields
        @type fields: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(slotId)s/version"
        path_params = {"slotId": blueprint_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "includeHead": includeHead}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /blueprint/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_slotId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(slotId)s/version', 'method_kind': 'GET'}

    @download
    def setHead(self,
                blueprint_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/head ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/head"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setHead.context = {'query_params': [], 'method_name': 'setHead', 'method_docs': '[ HTTP: POST /blueprint/{id}/head ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s/head', 'method_kind': 'POST'}

    @download
    def checkIn_1(self,
                  blueprint_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/checkin ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/checkin"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn_1.context = {'query_params': [], 'method_name': 'checkIn_1', 'method_docs': '[ HTTP: POST /blueprint/{id}/checkin ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/checkin', 'method_kind': 'POST'}

    @download
    def deployRequest(self,
                      blueprint_id,
                      deployrequest_containerId=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /blueprint/{id}/deployrequest/{containerId} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param deployrequest_containerId: deployrequest_containerId
        @type deployrequest_containerId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s/deployrequest/%(containerId)s"
        path_params = {"id": blueprint_id,
                       "containerId": deployrequest_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deployRequest.context = {'query_params': [], 'method_name': 'deployRequest', 'method_docs': '[ HTTP: POST /blueprint/{id}/deployrequest/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployrequest_containerId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployrequest_containerId'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'blueprint/%(id)s/deployrequest/%(containerId)s', 'method_kind': 'POST'}

    @download
    def getBlueprint(self,
                     blueprint_id=None,
                     validate=None,
                     **kwargs):
        """
        [ HTTP: GET /blueprint/{id} ]

        @param blueprint_id: blueprint_id
        @type blueprint_id: str
        @param validate: validate
        @type validate: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(id)s"
        path_params = {"id": blueprint_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"validate": validate}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getBlueprint.context = {'query_params': [{'name': 'validate', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'validate'}], 'method_name': 'getBlueprint', 'method_docs': '[ HTTP: GET /blueprint/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'blueprint_id'}, {'name': 'validate', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'validate'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'blueprint_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(id)s', 'method_kind': 'GET'}

class storage(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getStoragesXML(self,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /storage ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStoragesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getStoragesXML', 'method_docs': '[ HTTP: GET /storage ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storage', 'method_kind': 'GET'}

    @download
    def getStorage(self,
                   storage_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /storage/{id} ]

        @param storage_id: storage_id
        @type storage_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storage/%(id)s"
        path_params = {"id": storage_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStorage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getStorage', 'method_docs': '[ HTTP: GET /storage/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storage_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storage_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storage/%(id)s', 'method_kind': 'GET'}

class authtype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchTypes(self,
                    fields=None,
                    filterGroup=None,
                    limit=None,
                    offset=None,
                    orderBy=None,
                    usage=None,
                    **kwargs):
        """
        [ HTTP: GET /authtype/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authtype/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchTypes', 'method_docs': '[ HTTP: GET /authtype/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authtype/search', 'method_kind': 'GET'}

    @download
    def getAuthenticationType(self,
                              authtype_id=None,
                              fields=None,
                              **kwargs):
        """
        [ HTTP: GET /authtype/{id} ]

        @param authtype_id: authtype_id
        @type authtype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authtype/%(id)s"
        path_params = {"id": authtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAuthenticationType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAuthenticationType', 'method_docs': '[ HTTP: GET /authtype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authtype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authtype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authtype/%(id)s', 'method_kind': 'GET'}

    @download
    def getTypes(self,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /authtype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authtype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTypes', 'method_docs': '[ HTTP: GET /authtype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authtype', 'method_kind': 'GET'}

class serviceprovidertype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /serviceprovidertype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /serviceprovidertype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'serviceprovidertype/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     serviceprovidertype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /serviceprovidertype/{id}/export ]

        @param serviceprovidertype_id: serviceprovidertype_id
        @type serviceprovidertype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/%(id)s/export"
        path_params = {"id": serviceprovidertype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /serviceprovidertype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovidertype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovidertype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovidertype/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /serviceprovidertype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /serviceprovidertype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceprovidertype/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /serviceprovidertype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /serviceprovidertype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovidertype/export', 'method_kind': 'GET'}

    @download
    def createServiceProviderType(self,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /serviceprovidertype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createServiceProviderType.context = {'query_params': [], 'method_name': 'createServiceProviderType', 'method_docs': '[ HTTP: POST /serviceprovidertype ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceprovidertype', 'method_kind': 'POST'}

    @download
    def updateServiceProviderType(self,
                                  serviceprovidertype_id=None,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: PUT /serviceprovidertype/{id: \d+} ]

        @param serviceprovidertype_id: serviceprovidertype_id
        @type serviceprovidertype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/%(id: \d+)s"
        path_params = {"id": serviceprovidertype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateServiceProviderType.context = {'query_params': [], 'method_name': 'updateServiceProviderType', 'method_docs': '[ HTTP: PUT /serviceprovidertype/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovidertype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovidertype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceprovidertype/%(id: \\d+)s', 'method_kind': 'PUT'}

    @download
    def getServiceProviderType(self,
                               serviceprovidertype_id=None,
                               fields=None,
                               **kwargs):
        """
        [ HTTP: GET /serviceprovidertype/{id: \d+} ]

        @param serviceprovidertype_id: serviceprovidertype_id
        @type serviceprovidertype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/%(id: \d+)s"
        path_params = {"id": serviceprovidertype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceProviderType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getServiceProviderType', 'method_docs': '[ HTTP: GET /serviceprovidertype/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovidertype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovidertype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovidertype/%(id: \\d+)s', 'method_kind': 'GET'}

    @download
    def deleteServiceProviderType(self,
                                  serviceprovidertype_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /serviceprovidertype/{id: \d+} ]

        @param serviceprovidertype_id: serviceprovidertype_id
        @type serviceprovidertype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype/%(id: \d+)s"
        path_params = {"id": serviceprovidertype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteServiceProviderType.context = {'query_params': [], 'method_name': 'deleteServiceProviderType', 'method_docs': '[ HTTP: DELETE /serviceprovidertype/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovidertype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovidertype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovidertype/%(id: \\d+)s', 'method_kind': 'DELETE'}

    @download
    def getServiceProviderTypes(self,
                                fields=None,
                                serviceTypeId=None,
                                superTypeId=None,
                                **kwargs):
        """
        [ HTTP: GET /serviceprovidertype ]

        @param fields: fields
        @type fields: str
        @param serviceTypeId: serviceTypeId
        @type serviceTypeId: str
        @param superTypeId: superTypeId
        @type superTypeId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovidertype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "serviceTypeId": serviceTypeId,
                        "superTypeId": superTypeId}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceProviderTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'serviceTypeId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceTypeId'}, {'name': 'superTypeId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'superTypeId'}], 'method_name': 'getServiceProviderTypes', 'method_docs': '[ HTTP: GET /serviceprovidertype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'serviceTypeId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceTypeId'}, {'name': 'superTypeId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'superTypeId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovidertype', 'method_kind': 'GET'}

class os(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateOperatingSystem(self,
                              os_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateOperatingSystem.context = {'query_params': [], 'method_name': 'updateOperatingSystem', 'method_docs': '[ HTTP: PUT /os/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'os_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'os_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'os/%(id)s', 'method_kind': 'PUT'}

    @download
    def getOperatingSystem(self,
                           os_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOperatingSystem.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getOperatingSystem', 'method_docs': '[ HTTP: GET /os/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'os_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'os_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'os/%(id)s', 'method_kind': 'GET'}

    @download
    def getOperatingSystems(self,
                            fields=None,
                            **kwargs):
        """
        [ HTTP: GET /os ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOperatingSystems.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getOperatingSystems', 'method_docs': '[ HTTP: GET /os ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'os', 'method_kind': 'GET'}

    @download
    def getTaxonomy(self,
                    **kwargs):
        """
        [ HTTP: GET /os/taxonomy ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/taxonomy"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTaxonomy.context = {'query_params': [], 'method_name': 'getTaxonomy', 'method_docs': '[ HTTP: GET /os/taxonomy ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'os/taxonomy', 'method_kind': 'GET'}

    @download
    def createOperatingSystem(self,
                              os_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /os/{id}/child ]

        @param os_id: os_id
        @type os_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s/child"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createOperatingSystem.context = {'query_params': [], 'method_name': 'createOperatingSystem', 'method_docs': '[ HTTP: POST /os/{id}/child ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'os_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'os_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'os/%(id)s/child', 'method_kind': 'POST'}

    @download
    def getMgmtScriptGroup(self,
                           os_id,
                           mgmtscriptgroup_msgid=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /os/{id}/mgmtscriptgroup/{msgid} ]

        @param os_id: os_id
        @type os_id: str
        @param mgmtscriptgroup_msgid: mgmtscriptgroup_msgid
        @type mgmtscriptgroup_msgid: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s/mgmtscriptgroup/%(msgid)s"
        path_params = {"id": os_id,
                       "msgid": mgmtscriptgroup_msgid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMgmtScriptGroup.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getMgmtScriptGroup', 'method_docs': '[ HTTP: GET /os/{id}/mgmtscriptgroup/{msgid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'os_id'}, {'name': 'msgid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'mgmtscriptgroup_msgid'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'os_id'}, {'name': 'msgid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'mgmtscriptgroup_msgid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'os/%(id)s/mgmtscriptgroup/%(msgid)s', 'method_kind': 'GET'}

    @download
    def deleteOperatingSystem(self,
                              os_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /os/{id} ]

        @param os_id: os_id
        @type os_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/%(id)s"
        path_params = {"id": os_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteOperatingSystem.context = {'query_params': [], 'method_name': 'deleteOperatingSystem', 'method_docs': '[ HTTP: DELETE /os/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'os_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'os_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'os/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchOperatingSystems(self,
                               fields=None,
                               filterGroup=None,
                               limit=None,
                               offset=None,
                               orderBy=None,
                               usage=None,
                               **kwargs):
        """
        [ HTTP: GET /os/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "os/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchOperatingSystems.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchOperatingSystems', 'method_docs': '[ HTTP: GET /os/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'os/search', 'method_kind': 'GET'}

class propertydefinitionref(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getType(self,
                propertydefinitionref_id=None,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /propertydefinitionref/{id} ]

        @param propertydefinitionref_id: propertydefinitionref_id
        @type propertydefinitionref_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertydefinitionref/%(id)s"
        path_params = {"id": propertydefinitionref_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getType', 'method_docs': '[ HTTP: GET /propertydefinitionref/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertydefinitionref_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertydefinitionref_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertydefinitionref/%(id)s', 'method_kind': 'GET'}

class environment(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getScripts(self,
                   environment_id,
                   version=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /environment/{id}/script ]

        @param environment_id: environment_id
        @type environment_id: str
        @param version: version
        @type version: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/script"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScripts.context = {'query_params': [{'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getScripts', 'method_docs': '[ HTTP: GET /environment/{id}/script ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/script', 'method_kind': 'GET'}

    @download
    def addSecurityUser(self,
                        environment_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/user ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/user"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'method_name': 'addSecurityUser', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/user', 'method_kind': 'POST'}

    @download
    def getEnvironmentsXML(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /environment ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironmentsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEnvironmentsXML', 'method_docs': '[ HTTP: GET /environment ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment', 'method_kind': 'GET'}

    @download
    def createPackage(self,
                      environment_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /environment/{id}/package ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/package"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPackage.context = {'query_params': [], 'method_name': 'createPackage', 'method_docs': '[ HTTP: POST /environment/{id}/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/package', 'method_kind': 'POST'}

    @download
    def upateEnvironment(self,
                         environment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    upateEnvironment.context = {'query_params': [], 'method_name': 'upateEnvironment', 'method_docs': '[ HTTP: PUT /environment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s', 'method_kind': 'PUT'}

    @download
    def deleteSecurityRights(self,
                             environment_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'method_name': 'deleteSecurityRights', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'method_kind': 'DELETE'}

    @download
    def importIDAction_2(self,
                         environment_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /environment/{id}/import ]

        @param environment_id: environment_id
        @type environment_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/import"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_2', 'method_docs': '[ HTTP: PUT /environment/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getTemplatesXML(self,
                        environment_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplatesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTemplatesXML', 'method_docs': '[ HTTP: GET /environment/{id}/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/template', 'method_kind': 'GET'}

    @download
    def updateAlias(self,
                    environment_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'method_name': 'updateAlias', 'method_docs': '[ HTTP: PUT /environment/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'method_kind': 'PUT'}

    @download
    def createRuntime(self,
                      environment_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /environment/{id}/runtime ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/runtime"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRuntime.context = {'query_params': [], 'method_name': 'createRuntime', 'method_docs': '[ HTTP: POST /environment/{id}/runtime ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/runtime', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     environment_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /environment/{id}/export ]

        @param environment_id: environment_id
        @type environment_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/export"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /environment/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/export', 'method_kind': 'GET'}

    @download
    def createTopology(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopology.context = {'query_params': [], 'method_name': 'createTopology', 'method_docs': '[ HTTP: POST /environment/{id}/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/topology', 'method_kind': 'POST'}

    @download
    def getTopologiesXML(self,
                         environment_id,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /environment/{id}/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologiesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTopologiesXML', 'method_docs': '[ HTTP: GET /environment/{id}/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/topology', 'method_kind': 'GET'}

    @download
    def getVariablesByName(self,
                           environment_env_id,
                           variable_vname=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /environment/{env_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"env_id": environment_env_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesByName.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariablesByName', 'method_docs': '[ HTTP: GET /environment/{env_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(env_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'GET'}

    @download
    def getVariableXML(self,
                       environment_env_id,
                       variable_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{env_id}/variable/{variable_id: [0-9]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariableXML', 'method_docs': '[ HTTP: GET /environment/{env_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(env_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def createTemplateManual(self,
                             environment_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /environment/{id}/manualorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/manualorder/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplateManual.context = {'query_params': [], 'method_name': 'createTemplateManual', 'method_docs': '[ HTTP: POST /environment/{id}/manualorder/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/manualorder/template', 'method_kind': 'POST'}

    @download
    def getEnvironment(self,
                       environment_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironment.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEnvironment', 'method_docs': '[ HTTP: GET /environment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s', 'method_kind': 'GET'}

    @download
    def addSecurityAccessRight(self,
                               environment_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'method_name': 'addSecurityAccessRight', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'method_kind': 'POST'}

    @download
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /environment/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /environment/export ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/export', 'method_kind': 'GET'}

    @download
    def createMultiVariable(self,
                            environment_env_id,
                            variable_vname=None,
                            fields=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /environment/{env_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"env_id": environment_env_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMultiVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createMultiVariable', 'method_docs': '[ HTTP: POST /environment/{env_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(env_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def searchPolicyAssignments(self,
                                environment_id,
                                containerId=None,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /environment/{id}/policyassignment/search ]

        @param environment_id: environment_id
        @type environment_id: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policyassignment/search"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /environment/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def searchEnvironments(self,
                           containerId=None,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           qterm=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /environment/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchEnvironments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchEnvironments', 'method_docs': '[ HTTP: GET /environment/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/search', 'method_kind': 'GET'}

    @download
    def cloneEnvironment(self,
                         environment_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /environment/{id}/clone ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/clone"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneEnvironment.context = {'query_params': [], 'method_name': 'cloneEnvironment', 'method_docs': '[ HTTP: POST /environment/{id}/clone ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/clone', 'method_kind': 'POST'}

    @download
    def stopEnvironment(self,
                        environment_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/stop ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/stop"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopEnvironment.context = {'query_params': [], 'method_name': 'stopEnvironment', 'method_docs': '[ HTTP: POST /environment/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def getAlias(self,
                 environment_id,
                 alias_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAlias', 'method_docs': '[ HTTP: GET /environment/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'method_kind': 'GET'}

    @download
    def createTemplate(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplate.context = {'query_params': [], 'method_name': 'createTemplate', 'method_docs': '[ HTTP: POST /environment/{id}/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/template', 'method_kind': 'POST'}

    @download
    def getVariablesXML(self,
                        environment_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/variable ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariablesXML', 'method_docs': '[ HTTP: GET /environment/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def deleteEnvironment(self,
                          environment_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /environment/{id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteEnvironment.context = {'query_params': [], 'method_name': 'deleteEnvironment', 'method_docs': '[ HTTP: DELETE /environment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s', 'method_kind': 'DELETE'}

    @download
    def decryptVariable(self,
                        environment_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /environment/{id}/variable/{variable_id}/decrypt ]

        @param environment_id: environment_id
        @type environment_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": environment_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'method_name': 'decryptVariable', 'method_docs': '[ HTTP: GET /environment/{id}/variable/{variable_id}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/variable/%(variable_id)s/decrypt', 'method_kind': 'GET'}

    @download
    def getBlueprints(self,
                      environment_id,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /environment/{id}/blueprint ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/blueprint"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getBlueprints.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getBlueprints', 'method_docs': '[ HTTP: GET /environment/{id}/blueprint ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/blueprint', 'method_kind': 'GET'}

    @download
    def addSecurity(self,
                    environment_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /environment/{id}/security ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'method_name': 'addSecurity', 'method_docs': '[ HTTP: POST /environment/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/security', 'method_kind': 'POST'}

    @download
    def getPackages(self,
                    environment_id,
                    version=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/package ]

        @param environment_id: environment_id
        @type environment_id: str
        @param version: version
        @type version: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/package"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPackages', 'method_docs': '[ HTTP: GET /environment/{id}/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/package', 'method_kind': 'GET'}

    @download
    def getRuntimes(self,
                    environment_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/runtime ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/runtime"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRuntimes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRuntimes', 'method_docs': '[ HTTP: GET /environment/{id}/runtime ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/runtime', 'method_kind': 'GET'}

    @download
    def getPolicies(self,
                    environment_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/policy ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /environment/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def getDeployments(self,
                       environment_id,
                       ready=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /environment/{id}/solutiondeployment ]

        @param environment_id: environment_id
        @type environment_id: str
        @param ready: ready
        @type ready: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/solutiondeployment"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"ready": ready,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployments.context = {'query_params': [{'name': 'ready', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ready'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployments', 'method_docs': '[ HTTP: GET /environment/{id}/solutiondeployment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'ready', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ready'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/solutiondeployment', 'method_kind': 'GET'}

    @download
    def createTemplateAny(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/anyorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/anyorder/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplateAny.context = {'query_params': [], 'method_name': 'createTemplateAny', 'method_docs': '[ HTTP: POST /environment/{id}/anyorder/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/anyorder/template', 'method_kind': 'POST'}

    @download
    def createScript(self,
                     environment_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /environment/{id}/script ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/script"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScript.context = {'query_params': [], 'method_name': 'createScript', 'method_docs': '[ HTTP: POST /environment/{id}/script ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/script', 'method_kind': 'POST'}

    @download
    def createAlias(self,
                    environment_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /environment/{id}/alias ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'method_name': 'createAlias', 'method_docs': '[ HTTP: POST /environment/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/alias', 'method_kind': 'POST'}

    @download
    def createTopologyManualOrder(self,
                                  environment_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /environment/{id}/manualorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/manualorder/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopologyManualOrder.context = {'query_params': [], 'method_name': 'createTopologyManualOrder', 'method_docs': '[ HTTP: POST /environment/{id}/manualorder/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/manualorder/topology', 'method_kind': 'POST'}

    @download
    def importIDAction_1(self,
                         environment_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         files=None,
                         **kwargs):
        """
        [ HTTP: PUT /environment/{id}/import ]

        @param environment_id: environment_id
        @type environment_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/import"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_1', 'method_docs': '[ HTTP: PUT /environment/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'environment/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getSecurity(self,
                    environment_id,
                    security_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /environment/{id}/security/{security_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSecurity', 'method_docs': '[ HTTP: GET /environment/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s', 'method_kind': 'GET'}

    @download
    def attachPolicy(self,
                     environment_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /environment/{id}/policy/{policyid} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy/%(policyid)s"
        path_params = {"id": environment_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /environment/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def createBlueprint(self,
                        environment_id,
                        force=None,
                        fields=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /environment/{id}/blueprint ]

        @param environment_id: environment_id
        @type environment_id: str
        @param force: force
        @type force: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/blueprint"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"force": force,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createBlueprint.context = {'query_params': [{'name': 'force', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'force'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createBlueprint', 'method_docs': '[ HTTP: POST /environment/{id}/blueprint ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'force', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'force'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/blueprint', 'method_kind': 'POST'}

    @download
    def addSecurityUserGroup(self,
                             environment_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/usergroup ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'method_name': 'addSecurityUserGroup', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/usergroup ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/usergroup', 'method_kind': 'POST'}

    @download
    def createTemplateFixed(self,
                            environment_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /environment/{id}/fixedorder/template ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/fixedorder/template"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplateFixed.context = {'query_params': [], 'method_name': 'createTemplateFixed', 'method_docs': '[ HTTP: POST /environment/{id}/fixedorder/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/fixedorder/template', 'method_kind': 'POST'}

    @download
    def deleteVariable(self,
                       environment_env_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /environment/{env_id}/variable/{variable_id: [0-9]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /environment/{env_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(env_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def getAliases(self,
                   environment_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /environment/{id}/alias ]

        @param environment_id: environment_id
        @type environment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAliases', 'method_docs': '[ HTTP: GET /environment/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/alias', 'method_kind': 'GET'}

    @download
    def startEnvironment(self,
                         environment_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /environment/{id}/start ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/start"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startEnvironment.context = {'query_params': [], 'method_name': 'startEnvironment', 'method_docs': '[ HTTP: POST /environment/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/start', 'method_kind': 'POST'}

    @download
    def removePolicy(self,
                     environment_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/policy/{policyid} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/policy/%(policyid)s"
        path_params = {"id": environment_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /environment/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurityUserGroup(self,
                                environment_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'method_name': 'deleteSecurityUserGroup', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurity(self,
                       environment_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'method_name': 'deleteSecurity', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteAlias(self,
                    environment_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/alias/{alias_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/alias/%(alias_id)s"
        path_params = {"id": environment_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'method_name': 'deleteAlias', 'method_docs': '[ HTTP: DELETE /environment/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/alias/%(alias_id)s', 'method_kind': 'DELETE'}

    @download
    def createTopologyAnyOrder(self,
                               environment_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /environment/{id}/anyorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/anyorder/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopologyAnyOrder.context = {'query_params': [], 'method_name': 'createTopologyAnyOrder', 'method_docs': '[ HTTP: POST /environment/{id}/anyorder/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/anyorder/topology', 'method_kind': 'POST'}

    @download
    def addSecurityRights(self,
                          environment_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/security/{security_id}/rights ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": environment_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'method_name': 'addSecurityRights', 'method_docs': '[ HTTP: POST /environment/{id}/security/{security_id}/rights ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights', 'method_kind': 'POST'}

    @download
    def createVariable(self,
                       environment_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /environment/{id}/variable ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/variable"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /environment/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def deleteSecurityUser(self,
                           environment_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/user/{user_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'method_name': 'deleteSecurityUser', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/user/{user_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/user/%(user_id)s', 'method_kind': 'DELETE'}

    @download
    def createTopologyFixedOrder(self,
                                 environment_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /environment/{id}/fixedorder/topology ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/fixedorder/topology"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopologyFixedOrder.context = {'query_params': [], 'method_name': 'createTopologyFixedOrder', 'method_docs': '[ HTTP: POST /environment/{id}/fixedorder/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environment/%(id)s/fixedorder/topology', 'method_kind': 'POST'}

    @download
    def updateVariable(self,
                       environment_env_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /environment/{env_id}/variable/{variable_id: [0-9]+} ]

        @param environment_env_id: environment_env_id
        @type environment_env_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(env_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"env_id": environment_env_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /environment/{env_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'env_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_env_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'environment/%(env_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def rebootEnvironment(self,
                          environment_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /environment/{id}/restart ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/restart"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootEnvironment.context = {'query_params': [], 'method_name': 'rebootEnvironment', 'method_docs': '[ HTTP: POST /environment/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def releaseEnvironment(self,
                           environment_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /environment/{id}/release ]

        @param environment_id: environment_id
        @type environment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/release"
        path_params = {"id": environment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseEnvironment.context = {'query_params': [], 'method_name': 'releaseEnvironment', 'method_docs': '[ HTTP: POST /environment/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/release', 'method_kind': 'POST'}

    @download
    def deleteSecurityAccessRight(self,
                                  environment_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param environment_id: environment_id
        @type environment_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": environment_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'method_name': 'deleteSecurityAccessRight', 'method_docs': '[ HTTP: DELETE /environment/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environment_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environment/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'method_kind': 'DELETE'}

class stack(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteTargetCloud(self,
                          stack_id,
                          targetcloud_id=None,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: DELETE /stack/{id}/targetcloud/{targetcloud_id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param targetcloud_id: targetcloud_id
        @type targetcloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/targetcloud/%(targetcloud_id)s"
        path_params = {"id": stack_id,
                       "targetcloud_id": targetcloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteTargetCloud.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'deleteTargetCloud', 'method_docs': '[ HTTP: DELETE /stack/{id}/targetcloud/{targetcloud_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'targetcloud_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'targetcloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'targetcloud_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'targetcloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s/targetcloud/%(targetcloud_id)s', 'method_kind': 'DELETE'}

    @download
    def approval(self,
                 stack_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /stack/{id}/approval ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/approval"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /stack/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def getStacksXML(self,
                     fields=None,
                     version=None,
                     **kwargs):
        """
        [ HTTP: GET /stack ]

        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStacksXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}], 'method_name': 'getStacksXML', 'method_docs': '[ HTTP: GET /stack ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack', 'method_kind': 'GET'}

    @download
    def createTargetCloud(self,
                          stack_id,
                          fields=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /stack/{id}/targetcloud ]

        @param stack_id: stack_id
        @type stack_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/targetcloud"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTargetCloud.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createTargetCloud', 'method_docs': '[ HTTP: POST /stack/{id}/targetcloud ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/targetcloud', 'method_kind': 'POST'}

    @download
    def checkOut(self,
                 stack_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /stack/{id}/checkout ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/checkout"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'method_name': 'checkOut', 'method_docs': '[ HTTP: POST /stack/{id}/checkout ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/checkout', 'method_kind': 'POST'}

    @download
    def approve(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/approve ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/approve"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: POST /stack/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def searchStacks(self,
                     stackType=None,
                     containerId=None,
                     fields=None,
                     filterGroup=None,
                     limit=None,
                     offset=None,
                     orderBy=None,
                     qterm=None,
                     usage=None,
                     **kwargs):
        """
        [ HTTP: GET /stack/search ]

        @param stackType: stackType
        @type stackType: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"stackType": stackType,
                        "containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchStacks.context = {'query_params': [{'name': 'stackType', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stackType'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchStacks', 'method_docs': '[ HTTP: GET /stack/search ]', 'result': 'result', 'method_params': [{'name': 'stackType', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stackType'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/search', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     stack_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /stack/{id}/export ]

        @param stack_id: stack_id
        @type stack_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/export"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /stack/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s/export', 'method_kind': 'GET'}

    @download
    def deleteStackAllVersions(self,
                               stack_id,
                               **kwargs):
        """
        [ HTTP: DELETE /stack/{id}/all ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/all"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteStackAllVersions.context = {'query_params': [], 'method_name': 'deleteStackAllVersions', 'method_docs': '[ HTTP: DELETE /stack/{id}/all ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s/all', 'method_kind': 'DELETE'}

    @download
    def getStackPolicyAssignments(self,
                                  stack_id,
                                  fields=None,
                                  containerId=None,
                                  policyTypeName=None,
                                  baseStacks=None,
                                  **kwargs):
        """
        [ HTTP: GET /stack/{id}/policyassignments ]

        @param stack_id: stack_id
        @type stack_id: str
        @param fields: fields
        @type fields: str
        @param containerId: containerId
        @type containerId: str
        @param policyTypeName: policyTypeName
        @type policyTypeName: str
        @param baseStacks: baseStacks
        @type baseStacks: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/policyassignments"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "containerId": containerId,
                        "policyTypeName": policyTypeName,
                        "baseStacks": baseStacks}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStackPolicyAssignments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'policyTypeName', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyTypeName'}, {'name': 'baseStacks', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'baseStacks'}], 'method_name': 'getStackPolicyAssignments', 'method_docs': '[ HTTP: GET /stack/{id}/policyassignments ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'policyTypeName', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyTypeName'}, {'name': 'baseStacks', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'baseStacks'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s/policyassignments', 'method_kind': 'GET'}

    @download
    def deleteStack(self,
                    stack_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteStack.context = {'query_params': [], 'method_name': 'deleteStack', 'method_docs': '[ HTTP: DELETE /stack/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stack_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s', 'method_kind': 'DELETE'}

    @download
    def reject(self,
               stack_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /stack/{id}/reject ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/reject"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: POST /stack/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/reject', 'method_kind': 'POST'}

    @download
    def createStack(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /stack ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createStack.context = {'query_params': [], 'method_name': 'createStack', 'method_docs': '[ HTTP: POST /stack ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack', 'method_kind': 'POST'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /stack/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /stack/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/export', 'method_kind': 'GET'}

    @download
    def rejection(self,
                  stack_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /stack/{id}/rejection ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/rejection"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /stack/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def updateStack(self,
                    stack_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateStack.context = {'query_params': [], 'method_name': 'updateStack', 'method_docs': '[ HTTP: PUT /stack/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s', 'method_kind': 'PUT'}

    @download
    def getAllVersions(self,
                       stack_slotId,
                       fields=None,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /stack/{slotId}/version ]

        @param stack_slotId: stack_slotId
        @type stack_slotId: str
        @param fields: fields
        @type fields: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(slotId)s/version"
        path_params = {"slotId": stack_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "includeHead": includeHead}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /stack/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_slotId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(slotId)s/version', 'method_kind': 'GET'}

    @download
    def getStack(self,
                 stack_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /stack/{id} ]

        @param stack_id: stack_id
        @type stack_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getStack.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getStack', 'method_docs': '[ HTTP: GET /stack/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stack_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s', 'method_kind': 'GET'}

    @download
    def setHead(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/head ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/head"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setHead.context = {'query_params': [], 'method_name': 'setHead', 'method_docs': '[ HTTP: POST /stack/{id}/head ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s/head', 'method_kind': 'POST'}

    @download
    def searchBaseStacks(self,
                         containerId=None,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         qterm=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /stack/base/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/base/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchBaseStacks.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchBaseStacks', 'method_docs': '[ HTTP: GET /stack/base/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/base/search', 'method_kind': 'GET'}

    @download
    def checkIn(self,
                stack_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /stack/{id}/checkin ]

        @param stack_id: stack_id
        @type stack_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/checkin"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'method_name': 'checkIn', 'method_docs': '[ HTTP: POST /stack/{id}/checkin ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'stack/%(id)s/checkin', 'method_kind': 'POST'}

    @download
    def build(self,
              stack_id,
              fields=None,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /stack/{id}/build ]

        @param stack_id: stack_id
        @type stack_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "stack/%(id)s/build"
        path_params = {"id": stack_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    build.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'build', 'method_docs': '[ HTTP: POST /stack/{id}/build ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'stack_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'stack/%(id)s/build', 'method_kind': 'POST'}

class blueprint_service(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getServices(self,
                    blueprint_bp_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /blueprint/{bp_id}/service ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/service"
        path_params = {"bp_id": blueprint_bp_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServices.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getServices', 'method_docs': '[ HTTP: GET /blueprint/{bp_id}/service ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/service', 'method_kind': 'GET'}

    @download
    def createService(self,
                      blueprint_bp_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /blueprint/{bp_id}/service ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/service"
        path_params = {"bp_id": blueprint_bp_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createService.context = {'query_params': [], 'method_name': 'createService', 'method_docs': '[ HTTP: POST /blueprint/{bp_id}/service ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/service', 'method_kind': 'POST'}

    @download
    def updateService(self,
                      blueprint_bp_id,
                      service_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /blueprint/{bp_id}/service/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param service_id: service_id
        @type service_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/service/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": service_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateService.context = {'query_params': [], 'method_name': 'updateService', 'method_docs': '[ HTTP: PUT /blueprint/{bp_id}/service/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'service_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'service_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/service/%(id)s', 'method_kind': 'PUT'}

    @download
    def getService(self,
                   blueprint_bp_id,
                   service_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /blueprint/{bp_id}/service/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param service_id: service_id
        @type service_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/service/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": service_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getService.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getService', 'method_docs': '[ HTTP: GET /blueprint/{bp_id}/service/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'service_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'service_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/service/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteService(self,
                      blueprint_bp_id,
                      service_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /blueprint/{bp_id}/service/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param service_id: service_id
        @type service_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/service/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": service_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteService.context = {'query_params': [], 'method_name': 'deleteService', 'method_docs': '[ HTTP: DELETE /blueprint/{bp_id}/service/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'service_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'service_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/service/%(id)s', 'method_kind': 'DELETE'}

class package(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getPackage(self,
                   package_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPackage', 'method_docs': '[ HTTP: GET /package/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s', 'method_kind': 'GET'}

    @download
    def getPackages(self,
                    fields=None,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /package ]

        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}], 'method_name': 'getPackages', 'method_docs': '[ HTTP: GET /package ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package', 'method_kind': 'GET'}

    @download
    def removeInstallScript(self,
                            package_id,
                            install_scriptid=None,
                            **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/install/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param install_scriptid: install_scriptid
        @type install_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/install/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": install_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeInstallScript.context = {'query_params': [], 'method_name': 'removeInstallScript', 'method_docs': '[ HTTP: DELETE /package/{id}/script/install/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'install_scriptid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'install_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/install/%(scriptid)s', 'method_kind': 'DELETE'}

    @download
    def removeOperationalScript(self,
                                package_id,
                                operational_scriptid=None,
                                **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/operational/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param operational_scriptid: operational_scriptid
        @type operational_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/operational/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": operational_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeOperationalScript.context = {'query_params': [], 'method_name': 'removeOperationalScript', 'method_docs': '[ HTTP: DELETE /package/{id}/script/operational/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'operational_scriptid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'operational_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/operational/%(scriptid)s', 'method_kind': 'DELETE'}

    @download
    def createPackage(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /package ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPackage.context = {'query_params': [], 'method_name': 'createPackage', 'method_docs': '[ HTTP: POST /package ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package', 'method_kind': 'POST'}

    @download
    def checkOut(self,
                 package_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /package/{id}/checkout ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/checkout"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'method_name': 'checkOut', 'method_docs': '[ HTTP: POST /package/{id}/checkout ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s/checkout', 'method_kind': 'POST'}

    @download
    def deletePackage(self,
                      package_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePackage.context = {'query_params': [], 'method_name': 'deletePackage', 'method_docs': '[ HTTP: DELETE /package/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s', 'method_kind': 'DELETE'}

    @download
    def attachInstallScript(self,
                            package_id,
                            install_scriptid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/install/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param install_scriptid: install_scriptid
        @type install_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/install/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": install_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachInstallScript.context = {'query_params': [], 'method_name': 'attachInstallScript', 'method_docs': '[ HTTP: PUT /package/{id}/script/install/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'install_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'install_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/install/%(scriptid)s', 'method_kind': 'PUT'}

    @download
    def approve(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/approve ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/approve"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: POST /package/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def attachShutdownScript(self,
                             package_id,
                             shutdown_scriptid=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/shutdown/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param shutdown_scriptid: shutdown_scriptid
        @type shutdown_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/shutdown/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": shutdown_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachShutdownScript.context = {'query_params': [], 'method_name': 'attachShutdownScript', 'method_docs': '[ HTTP: PUT /package/{id}/script/shutdown/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'shutdown_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'shutdown_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/shutdown/%(scriptid)s', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     package_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /package/{id}/export ]

        @param package_id: package_id
        @type package_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/export"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /package/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/export', 'method_kind': 'GET'}

    @download
    def attachStartupScript(self,
                            package_id,
                            startup_scriptid=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/startup/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param startup_scriptid: startup_scriptid
        @type startup_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/startup/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": startup_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachStartupScript.context = {'query_params': [], 'method_name': 'attachStartupScript', 'method_docs': '[ HTTP: PUT /package/{id}/script/startup/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'startup_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'startup_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/startup/%(scriptid)s', 'method_kind': 'PUT'}

    @download
    def removeShutdownScript(self,
                             package_id,
                             shutdown_scriptid=None,
                             **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/shutdown/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param shutdown_scriptid: shutdown_scriptid
        @type shutdown_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/shutdown/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": shutdown_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeShutdownScript.context = {'query_params': [], 'method_name': 'removeShutdownScript', 'method_docs': '[ HTTP: DELETE /package/{id}/script/shutdown/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'shutdown_scriptid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'shutdown_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/shutdown/%(scriptid)s', 'method_kind': 'DELETE'}

    @download
    def attachReconfigureScript(self,
                                package_id,
                                reconfigure_scriptid=None,
                                data=None,
                                **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/reconfigure/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param reconfigure_scriptid: reconfigure_scriptid
        @type reconfigure_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/reconfigure/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": reconfigure_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachReconfigureScript.context = {'query_params': [], 'method_name': 'attachReconfigureScript', 'method_docs': '[ HTTP: PUT /package/{id}/script/reconfigure/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'reconfigure_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'reconfigure_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/reconfigure/%(scriptid)s', 'method_kind': 'PUT'}

    @download
    def approval(self,
                 package_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /package/{id}/approval ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/approval"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /package/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def attachOperationalScript(self,
                                package_id,
                                operational_scriptid=None,
                                data=None,
                                **kwargs):
        """
        [ HTTP: PUT /package/{id}/script/operational/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param operational_scriptid: operational_scriptid
        @type operational_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/operational/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": operational_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachOperationalScript.context = {'query_params': [], 'method_name': 'attachOperationalScript', 'method_docs': '[ HTTP: PUT /package/{id}/script/operational/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'operational_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'operational_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/operational/%(scriptid)s', 'method_kind': 'PUT'}

    @download
    def reject(self,
               package_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /package/{id}/reject ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/reject"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: POST /package/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s/reject', 'method_kind': 'POST'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /package/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /package/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/export', 'method_kind': 'GET'}

    @download
    def updatePackage(self,
                      package_id=None,
                      fields=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /package/{id} ]

        @param package_id: package_id
        @type package_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePackage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updatePackage', 'method_docs': '[ HTTP: PUT /package/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s', 'method_kind': 'PUT'}

    @download
    def rejection(self,
                  package_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /package/{id}/rejection ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/rejection"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /package/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def getPackageScripts(self,
                          package_id,
                          **kwargs):
        """
        [ HTTP: GET /package/{id}/script ]

        @param package_id: package_id
        @type package_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackageScripts.context = {'query_params': [], 'method_name': 'getPackageScripts', 'method_docs': '[ HTTP: GET /package/{id}/script ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script', 'method_kind': 'GET'}

    @download
    def removeReconfigureScript(self,
                                package_id,
                                reconfigure_scriptid=None,
                                **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/reconfigure/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param reconfigure_scriptid: reconfigure_scriptid
        @type reconfigure_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/reconfigure/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": reconfigure_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeReconfigureScript.context = {'query_params': [], 'method_name': 'removeReconfigureScript', 'method_docs': '[ HTTP: DELETE /package/{id}/script/reconfigure/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'reconfigure_scriptid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'reconfigure_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/reconfigure/%(scriptid)s', 'method_kind': 'DELETE'}

    @download
    def searchPackages(self,
                       containerId=None,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       qterm=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /package/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPackages.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchPackages', 'method_docs': '[ HTTP: GET /package/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/search', 'method_kind': 'GET'}

    @download
    def getAllVersions(self,
                       package_slotId,
                       fields=None,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /package/{slotId}/version ]

        @param package_slotId: package_slotId
        @type package_slotId: str
        @param fields: fields
        @type fields: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(slotId)s/version"
        path_params = {"slotId": package_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "includeHead": includeHead}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /package/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_slotId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(slotId)s/version', 'method_kind': 'GET'}

    @download
    def setHead(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/head ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/head"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setHead.context = {'query_params': [], 'method_name': 'setHead', 'method_docs': '[ HTTP: POST /package/{id}/head ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/head', 'method_kind': 'POST'}

    @download
    def checkIn(self,
                package_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /package/{id}/checkin ]

        @param package_id: package_id
        @type package_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/checkin"
        path_params = {"id": package_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'method_name': 'checkIn', 'method_docs': '[ HTTP: POST /package/{id}/checkin ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'package/%(id)s/checkin', 'method_kind': 'POST'}

    @download
    def removeStartupScript(self,
                            package_id,
                            startup_scriptid=None,
                            **kwargs):
        """
        [ HTTP: DELETE /package/{id}/script/startup/{scriptid} ]

        @param package_id: package_id
        @type package_id: str
        @param startup_scriptid: startup_scriptid
        @type startup_scriptid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "package/%(id)s/script/startup/%(scriptid)s"
        path_params = {"id": package_id,
                       "scriptid": startup_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removeStartupScript.context = {'query_params': [], 'method_name': 'removeStartupScript', 'method_docs': '[ HTTP: DELETE /package/{id}/script/startup/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'startup_scriptid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'package_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'startup_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'package/%(id)s/script/startup/%(scriptid)s', 'method_kind': 'DELETE'}

class solutiondeployment(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateName(self,
                   solutiondeployment_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/name ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/name"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateName.context = {'query_params': [], 'method_name': 'updateName', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/name ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/name', 'method_kind': 'PUT'}

    @download
    def submit(self,
               solutiondeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/submit ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/submit"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    submit.context = {'query_params': [], 'method_name': 'submit', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/submit ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/submit', 'method_kind': 'PUT'}

    @download
    def reject(self,
               solutiondeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/reject ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/reject"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/reject', 'method_kind': 'PUT'}

    @download
    def searchDeployments(self,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /solutiondeployment/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchDeployments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchDeployments', 'method_docs': '[ HTTP: GET /solutiondeployment/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/search', 'method_kind': 'GET'}

    @download
    def setDeploymentReady(self,
                           solutiondeployment_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/setready ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/setready"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setDeploymentReady.context = {'query_params': [], 'method_name': 'setDeploymentReady', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/setready ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/setready', 'method_kind': 'PUT'}

    @download
    def deploy(self,
               solutiondeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/deploy ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/deploy"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deploy.context = {'query_params': [], 'method_name': 'deploy', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/deploy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/deploy', 'method_kind': 'PUT'}

    @download
    def deleteSolutionDeployment(self,
                                 solutiondeployment_id=None,
                                 **kwargs):
        """
        [ HTTP: DELETE /solutiondeployment/{id} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSolutionDeployment.context = {'query_params': [], 'method_name': 'deleteSolutionDeployment', 'method_docs': '[ HTTP: DELETE /solutiondeployment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solutiondeployment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s', 'method_kind': 'DELETE'}

    @download
    def rejection(self,
                  solutiondeployment_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /solutiondeployment/{id}/rejection ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/rejection"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /solutiondeployment/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def approval(self,
                 solutiondeployment_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /solutiondeployment/{id}/approval ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/approval"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /solutiondeployment/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def promote(self,
                solutiondeployment_id,
                promote_locationId=None,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/promote/{locationId} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param promote_locationId: promote_locationId
        @type promote_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/promote/%(locationId)s"
        path_params = {"id": solutiondeployment_id,
                       "locationId": promote_locationId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    promote.context = {'query_params': [], 'method_name': 'promote', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/promote/{locationId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'promote_locationId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'promote_locationId'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/promote/%(locationId)s', 'method_kind': 'PUT'}

    @download
    def stop(self,
             solutiondeployment_id,
             data=None,
             **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/stop ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/stop"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stop.context = {'query_params': [], 'method_name': 'stop', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/stop', 'method_kind': 'PUT'}

    @download
    def updateSolutionDeployment(self,
                                 solutiondeployment_id=None,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateSolutionDeployment.context = {'query_params': [], 'method_name': 'updateSolutionDeployment', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s', 'method_kind': 'PUT'}

    @download
    def release(self,
                solutiondeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/release ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/release"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    release.context = {'query_params': [], 'method_name': 'release', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/release', 'method_kind': 'PUT'}

    @download
    def getSolutionDeployments(self,
                               ready=None,
                               fields=None,
                               **kwargs):
        """
        [ HTTP: GET /solutiondeployment ]

        @param ready: ready
        @type ready: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"ready": ready,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSolutionDeployments.context = {'query_params': [{'name': 'ready', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ready'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSolutionDeployments', 'method_docs': '[ HTTP: GET /solutiondeployment ]', 'result': 'result', 'method_params': [{'name': 'ready', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ready'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment', 'method_kind': 'GET'}

    @download
    def start(self,
              solutiondeployment_id,
              data=None,
              **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/start ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/start"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    start.context = {'query_params': [], 'method_name': 'start', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/start', 'method_kind': 'PUT'}

    @download
    def approve(self,
                solutiondeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/approve ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/approve"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/approve', 'method_kind': 'PUT'}

    @download
    def unsetDeploymentReady(self,
                             solutiondeployment_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/unsetready ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/unsetready"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    unsetDeploymentReady.context = {'query_params': [], 'method_name': 'unsetDeploymentReady', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/unsetready ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/unsetready', 'method_kind': 'PUT'}

    @download
    def restart(self,
                solutiondeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /solutiondeployment/{id}/restart ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s/restart"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    restart.context = {'query_params': [], 'method_name': 'restart', 'method_docs': '[ HTTP: PUT /solutiondeployment/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s/restart', 'method_kind': 'PUT'}

    @download
    def getSolutionDeployment(self,
                              solutiondeployment_id=None,
                              fields=None,
                              **kwargs):
        """
        [ HTTP: GET /solutiondeployment/{id} ]

        @param solutiondeployment_id: solutiondeployment_id
        @type solutiondeployment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solutiondeployment/%(id)s"
        path_params = {"id": solutiondeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSolutionDeployment.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSolutionDeployment', 'method_docs': '[ HTTP: GET /solutiondeployment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solutiondeployment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solutiondeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solutiondeployment/%(id)s', 'method_kind': 'GET'}

class setup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getConfigurations(self,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /setup ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getConfigurations.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getConfigurations', 'method_docs': '[ HTTP: GET /setup ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup', 'method_kind': 'GET'}

    @download
    def checkBadRequestFilterEnabled(self,
                                     **kwargs):
        """
        [ HTTP: GET /setup/badrequest ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/badrequest"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkBadRequestFilterEnabled.context = {'query_params': [], 'method_name': 'checkBadRequestFilterEnabled', 'method_docs': '[ HTTP: GET /setup/badrequest ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/badrequest', 'method_kind': 'GET'}

    @download
    def getProperty(self,
                    setup_id,
                    property_propid=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /setup/{id}/property/{propid} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property/%(propid)s"
        path_params = {"id": setup_id,
                       "propid": property_propid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProperty.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProperty', 'method_docs': '[ HTTP: GET /setup/{id}/property/{propid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'propid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'property_propid'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'propid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'property_propid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/%(id)s/property/%(propid)s', 'method_kind': 'GET'}

    @download
    def getProperties(self,
                      setup_id,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /setup/{id}/property ]

        @param setup_id: setup_id
        @type setup_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property"
        path_params = {"id": setup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProperties.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProperties', 'method_docs': '[ HTTP: GET /setup/{id}/property ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/%(id)s/property', 'method_kind': 'GET'}

    @download
    def enableCleanupTask(self,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /setup/cleanupTask ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupTask"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    enableCleanupTask.context = {'query_params': [], 'method_name': 'enableCleanupTask', 'method_docs': '[ HTTP: PUT /setup/cleanupTask ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupTask', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     setup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /setup/{id}/export ]

        @param setup_id: setup_id
        @type setup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/export"
        path_params = {"id": setup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /setup/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/%(id)s/export', 'method_kind': 'GET'}

    @download
    def checkCleanupScriptStatusEnabled(self,
                                        **kwargs):
        """
        [ HTTP: GET /setup/cleanupScriptStatus ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupScriptStatus"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkCleanupScriptStatusEnabled.context = {'query_params': [], 'method_name': 'checkCleanupScriptStatusEnabled', 'method_docs': '[ HTTP: GET /setup/cleanupScriptStatus ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupScriptStatus', 'method_kind': 'GET'}

    @download
    def disableCleanupScriptStatus(self,
                                   **kwargs):
        """
        [ HTTP: DELETE /setup/cleanupScriptStatus ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupScriptStatus"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    disableCleanupScriptStatus.context = {'query_params': [], 'method_name': 'disableCleanupScriptStatus', 'method_docs': '[ HTTP: DELETE /setup/cleanupScriptStatus ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupScriptStatus', 'method_kind': 'DELETE'}

    @download
    def setCleanupScriptStatusDaysOfDataToSave(self,
                                               data=None,
                                               **kwargs):
        """
        [ HTTP: PUT /setup/cleanupScriptStatus/daysToSave ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupScriptStatus/daysToSave"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setCleanupScriptStatusDaysOfDataToSave.context = {'query_params': [], 'method_name': 'setCleanupScriptStatusDaysOfDataToSave', 'method_docs': '[ HTTP: PUT /setup/cleanupScriptStatus/daysToSave ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'text/plain'}, 'form_params': [], 'method_path': 'setup/cleanupScriptStatus/daysToSave', 'method_kind': 'PUT'}

    @download
    def setProperty_1(self,
                      setup_id,
                      property_propid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /setup/{id}/property/{propid} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property/%(propid)s"
        path_params = {"id": setup_id,
                       "propid": property_propid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setProperty_1.context = {'query_params': [], 'method_name': 'setProperty_1', 'method_docs': '[ HTTP: PUT /setup/{id}/property/{propid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'propid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'property_propid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'propid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'property_propid'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/x-www-form-urlencoded'}, 'form_params': [], 'method_path': 'setup/%(id)s/property/%(propid)s', 'method_kind': 'PUT'}

    @download
    def getCleanupScriptStatusDaysOfDataToSave(self,
                                               **kwargs):
        """
        [ HTTP: GET /setup/cleanupScriptStatus/daysToSave ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupScriptStatus/daysToSave"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCleanupScriptStatusDaysOfDataToSave.context = {'query_params': [], 'method_name': 'getCleanupScriptStatusDaysOfDataToSave', 'method_docs': '[ HTTP: GET /setup/cleanupScriptStatus/daysToSave ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupScriptStatus/daysToSave', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /setup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /setup/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'setup/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /setup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /setup/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/export', 'method_kind': 'GET'}

    @download
    def setCleanupTaskDaysOfDataToSave(self,
                                       data=None,
                                       **kwargs):
        """
        [ HTTP: PUT /setup/cleanupTask/daysToSave ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupTask/daysToSave"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setCleanupTaskDaysOfDataToSave.context = {'query_params': [], 'method_name': 'setCleanupTaskDaysOfDataToSave', 'method_docs': '[ HTTP: PUT /setup/cleanupTask/daysToSave ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'text/plain'}, 'form_params': [], 'method_path': 'setup/cleanupTask/daysToSave', 'method_kind': 'PUT'}

    @download
    def enableBadRequestFilter(self,
                               data=None,
                               **kwargs):
        """
        [ HTTP: PUT /setup/badrequest ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/badrequest"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    enableBadRequestFilter.context = {'query_params': [], 'method_name': 'enableBadRequestFilter', 'method_docs': '[ HTTP: PUT /setup/badrequest ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/badrequest', 'method_kind': 'PUT'}

    @download
    def setProperty_2(self,
                      setup_id,
                      property_propid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /setup/{id}/property/{propid} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param property_propid: property_propid
        @type property_propid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s/property/%(propid)s"
        path_params = {"id": setup_id,
                       "propid": property_propid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setProperty_2.context = {'query_params': [], 'method_name': 'setProperty_2', 'method_docs': '[ HTTP: PUT /setup/{id}/property/{propid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'propid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'property_propid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'setup_id'}, {'name': 'propid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'property_propid'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'setup/%(id)s/property/%(propid)s', 'method_kind': 'PUT'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /setup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /setup/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'setup/import', 'method_kind': 'PUT'}

    @download
    def disableBadRequestFilter(self,
                                **kwargs):
        """
        [ HTTP: DELETE /setup/badrequest ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/badrequest"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    disableBadRequestFilter.context = {'query_params': [], 'method_name': 'disableBadRequestFilter', 'method_docs': '[ HTTP: DELETE /setup/badrequest ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/badrequest', 'method_kind': 'DELETE'}

    @download
    def getCleanupTaskDaysOfDataToSave(self,
                                       **kwargs):
        """
        [ HTTP: GET /setup/cleanupTask/daysToSave ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupTask/daysToSave"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCleanupTaskDaysOfDataToSave.context = {'query_params': [], 'method_name': 'getCleanupTaskDaysOfDataToSave', 'method_docs': '[ HTTP: GET /setup/cleanupTask/daysToSave ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupTask/daysToSave', 'method_kind': 'GET'}

    @download
    def disableCleanupTask(self,
                           **kwargs):
        """
        [ HTTP: DELETE /setup/cleanupTask ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupTask"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    disableCleanupTask.context = {'query_params': [], 'method_name': 'disableCleanupTask', 'method_docs': '[ HTTP: DELETE /setup/cleanupTask ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupTask', 'method_kind': 'DELETE'}

    @download
    def getConfiguation(self,
                        setup_id=None,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /setup/{id} ]

        @param setup_id: setup_id
        @type setup_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/%(id)s"
        path_params = {"id": setup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getConfiguation.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getConfiguation', 'method_docs': '[ HTTP: GET /setup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'setup_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'setup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/%(id)s', 'method_kind': 'GET'}

    @download
    def checkCleanupTaskEnabled(self,
                                **kwargs):
        """
        [ HTTP: GET /setup/cleanupTask ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupTask"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkCleanupTaskEnabled.context = {'query_params': [], 'method_name': 'checkCleanupTaskEnabled', 'method_docs': '[ HTTP: GET /setup/cleanupTask ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupTask', 'method_kind': 'GET'}

    @download
    def enableCleanupScriptStatus(self,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: PUT /setup/cleanupScriptStatus ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "setup/cleanupScriptStatus"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    enableCleanupScriptStatus.context = {'query_params': [], 'method_name': 'enableCleanupScriptStatus', 'method_docs': '[ HTTP: PUT /setup/cleanupScriptStatus ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'setup/cleanupScriptStatus', 'method_kind': 'PUT'}

class theme(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTheme(self,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /theme ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "theme"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTheme.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTheme', 'method_docs': '[ HTTP: GET /theme ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'theme', 'method_kind': 'GET'}

class subnet(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getSubnetsXML(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /subnet ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "subnet"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSubnetsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSubnetsXML', 'method_docs': '[ HTTP: GET /subnet ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'subnet', 'method_kind': 'GET'}

    @download
    def deleteSubnet(self,
                     subnet_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /subnet/{id} ]

        @param subnet_id: subnet_id
        @type subnet_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "subnet/%(id)s"
        path_params = {"id": subnet_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSubnet.context = {'query_params': [], 'method_name': 'deleteSubnet', 'method_docs': '[ HTTP: DELETE /subnet/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'subnet_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'subnet_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'subnet/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getSubnet(self,
                  subnet_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /subnet/{id} ]

        @param subnet_id: subnet_id
        @type subnet_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "subnet/%(id)s"
        path_params = {"id": subnet_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSubnet.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSubnet', 'method_docs': '[ HTTP: GET /subnet/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'subnet_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'subnet_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'subnet/%(id)s', 'method_kind': 'GET'}

    @download
    def updateSubnet(self,
                     subnet_id=None,
                     fields=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /subnet/{id} ]

        @param subnet_id: subnet_id
        @type subnet_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "subnet/%(id)s"
        path_params = {"id": subnet_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateSubnet.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateSubnet', 'method_docs': '[ HTTP: PUT /subnet/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'subnet_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'subnet_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'subnet/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchSubnets(self,
                      containerId=None,
                      fields=None,
                      filterGroup=None,
                      limit=None,
                      offset=None,
                      orderBy=None,
                      qterm=None,
                      usage=None,
                      **kwargs):
        """
        [ HTTP: GET /subnet/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "subnet/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchSubnets.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchSubnets', 'method_docs': '[ HTTP: GET /subnet/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'subnet/search', 'method_kind': 'GET'}

    @download
    def syncSubnet(self,
                   subnet_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /subnet/{id}/sync ]

        @param subnet_id: subnet_id
        @type subnet_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "subnet/%(id)s/sync"
        path_params = {"id": subnet_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncSubnet.context = {'query_params': [], 'method_name': 'syncSubnet', 'method_docs': '[ HTTP: POST /subnet/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'subnet_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'subnet_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'subnet/%(id)s/sync', 'method_kind': 'POST'}

class designcontainer_designcontainer(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getDesignContainer(self,
                           designcontainer_dc_id,
                           designcontainer_id=None,
                           **kwargs):
        """
        [ HTTP: GET /designcontainer/{dc_id}/designcontainer/{id} ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer/%(id)s"
        path_params = {"dc_id": designcontainer_dc_id,
                       "id": designcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDesignContainer.context = {'query_params': [], 'method_name': 'getDesignContainer', 'method_docs': '[ HTTP: GET /designcontainer/{dc_id}/designcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'dc_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'designcontainer_dc_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'dc_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'designcontainer_dc_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'designcontainer/%(dc_id)s/designcontainer/%(id)s', 'method_kind': 'GET'}

    @download
    def createSubDesignContainer(self,
                                 designcontainer_dc_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /designcontainer/{dc_id}/designcontainer ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer"
        path_params = {"dc_id": designcontainer_dc_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createSubDesignContainer.context = {'query_params': [], 'method_name': 'createSubDesignContainer', 'method_docs': '[ HTTP: POST /designcontainer/{dc_id}/designcontainer ]', 'result': 'result', 'method_params': [{'name': 'dc_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'designcontainer_dc_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'dc_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'designcontainer_dc_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'designcontainer/%(dc_id)s/designcontainer', 'method_kind': 'POST'}

    @download
    def deleteDesignContainer(self,
                              designcontainer_dc_id,
                              designcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /designcontainer/{dc_id}/designcontainer/{id} ]

        @param designcontainer_dc_id: designcontainer_dc_id
        @type designcontainer_dc_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designcontainer/%(dc_id)s/designcontainer/%(id)s"
        path_params = {"dc_id": designcontainer_dc_id,
                       "id": designcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDesignContainer.context = {'query_params': [], 'method_name': 'deleteDesignContainer', 'method_docs': '[ HTTP: DELETE /designcontainer/{dc_id}/designcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'dc_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'designcontainer_dc_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'dc_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'designcontainer_dc_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'designcontainer/%(dc_id)s/designcontainer/%(id)s', 'method_kind': 'DELETE'}

class scriptlanguage(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getScriptLanguagesXML(self,
                              **kwargs):
        """
        [ HTTP: GET /scriptlanguage ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptLanguagesXML.context = {'query_params': [], 'method_name': 'getScriptLanguagesXML', 'method_docs': '[ HTTP: GET /scriptlanguage ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'scriptlanguage', 'method_kind': 'GET'}

    @download
    def updateScriptLanguage(self,
                             scriptlanguage_id=None,
                             fields=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /scriptlanguage/{id} ]

        @param scriptlanguage_id: scriptlanguage_id
        @type scriptlanguage_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/%(id)s"
        path_params = {"id": scriptlanguage_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateScriptLanguage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateScriptLanguage', 'method_docs': '[ HTTP: PUT /scriptlanguage/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptlanguage_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptlanguage_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'scriptlanguage/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchScriptLanguages(self,
                              fields=None,
                              filterGroup=None,
                              limit=None,
                              offset=None,
                              orderBy=None,
                              usage=None,
                              **kwargs):
        """
        [ HTTP: GET /scriptlanguage/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchScriptLanguages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchScriptLanguages', 'method_docs': '[ HTTP: GET /scriptlanguage/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'scriptlanguage/search', 'method_kind': 'GET'}

    @download
    def getScriptLanguage(self,
                          scriptlanguage_id=None,
                          **kwargs):
        """
        [ HTTP: GET /scriptlanguage/{id} ]

        @param scriptlanguage_id: scriptlanguage_id
        @type scriptlanguage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/%(id)s"
        path_params = {"id": scriptlanguage_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptLanguage.context = {'query_params': [], 'method_name': 'getScriptLanguage', 'method_docs': '[ HTTP: GET /scriptlanguage/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptlanguage_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptlanguage_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'scriptlanguage/%(id)s', 'method_kind': 'GET'}

    @download
    def createScriptLanguage(self,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /scriptlanguage ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScriptLanguage.context = {'query_params': [], 'method_name': 'createScriptLanguage', 'method_docs': '[ HTTP: POST /scriptlanguage ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'scriptlanguage', 'method_kind': 'POST'}

    @download
    def deleteScriptLanguage(self,
                             scriptlanguage_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /scriptlanguage/{id} ]

        @param scriptlanguage_id: scriptlanguage_id
        @type scriptlanguage_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "scriptlanguage/%(id)s"
        path_params = {"id": scriptlanguage_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteScriptLanguage.context = {'query_params': [], 'method_name': 'deleteScriptLanguage', 'method_docs': '[ HTTP: DELETE /scriptlanguage/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptlanguage_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptlanguage_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'scriptlanguage/%(id)s', 'method_kind': 'DELETE'}

class globalvariable(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteGlobalVariable(self,
                             globalVariable_key=None,
                             parent=None,
                             **kwargs):
        """
        [ HTTP: DELETE /globalVariable/{key} ]

        @param globalVariable_key: globalVariable_key
        @type globalVariable_key: str
        @param parent: parent
        @type parent: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "globalVariable/%(key)s"
        path_params = {"key": globalVariable_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"parent": parent}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteGlobalVariable.context = {'query_params': [{'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}], 'method_name': 'deleteGlobalVariable', 'method_docs': '[ HTTP: DELETE /globalVariable/{key} ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'globalVariable_key'}, {'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'globalVariable_key'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'globalVariable/%(key)s', 'method_kind': 'DELETE'}

    @download
    def updateGlobalVariable(self,
                             globalVariable_key,
                             parent=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /globalVariable/{key}/value ]

        @param globalVariable_key: globalVariable_key
        @type globalVariable_key: str
        @param parent: parent
        @type parent: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "globalVariable/%(key)s/value"
        path_params = {"key": globalVariable_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"parent": parent}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateGlobalVariable.context = {'query_params': [{'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}], 'method_name': 'updateGlobalVariable', 'method_docs': '[ HTTP: PUT /globalVariable/{key}/value ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'globalVariable_key'}, {'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'globalVariable_key'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'globalVariable/%(key)s/value', 'method_kind': 'PUT'}

    @download
    def getGlobalVariable(self,
                          globalVariable_key=None,
                          parent=None,
                          **kwargs):
        """
        [ HTTP: GET /globalVariable/{key} ]

        @param globalVariable_key: globalVariable_key
        @type globalVariable_key: str
        @param parent: parent
        @type parent: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "globalVariable/%(key)s"
        path_params = {"key": globalVariable_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"parent": parent}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getGlobalVariable.context = {'query_params': [{'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}], 'method_name': 'getGlobalVariable', 'method_docs': '[ HTTP: GET /globalVariable/{key} ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'globalVariable_key'}, {'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'globalVariable_key'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'globalVariable/%(key)s', 'method_kind': 'GET'}

    @download
    def addGlobalVariable(self,
                          globalVariable_key,
                          parent=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /globalVariable/{key}/value ]

        @param globalVariable_key: globalVariable_key
        @type globalVariable_key: str
        @param parent: parent
        @type parent: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "globalVariable/%(key)s/value"
        path_params = {"key": globalVariable_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"parent": parent}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addGlobalVariable.context = {'query_params': [{'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}], 'method_name': 'addGlobalVariable', 'method_docs': '[ HTTP: POST /globalVariable/{key}/value ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'globalVariable_key'}, {'name': 'parent', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'parent'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'globalVariable_key'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'globalVariable/%(key)s/value', 'method_kind': 'POST'}

class attachment(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAttachmentMulti(self,
                           attachment_id=None,
                           **kwargs):
        """
        [ HTTP: GET /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentMulti.context = {'query_params': [], 'method_name': 'getAttachmentMulti', 'method_docs': '[ HTTP: GET /attachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'attachment/%(id)s', 'method_kind': 'GET'}

    @download
    def getAttachmentsXML(self,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /attachment ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAttachmentsXML', 'method_docs': '[ HTTP: GET /attachment ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'attachment', 'method_kind': 'GET'}

    @download
    def updateAttachment(self,
                         attachment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAttachment.context = {'query_params': [], 'method_name': 'updateAttachment', 'method_docs': '[ HTTP: PUT /attachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'attachment/%(id)s', 'method_kind': 'PUT'}

    @download
    def deleteAttachment(self,
                         attachment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /attachment/{id} ]

        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "attachment/%(id)s"
        path_params = {"id": attachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAttachment.context = {'query_params': [], 'method_name': 'deleteAttachment', 'method_docs': '[ HTTP: DELETE /attachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'attachment/%(id)s', 'method_kind': 'DELETE'}

class storecategory(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchCatgories(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /storecategory/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCatgories.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCatgories', 'method_docs': '[ HTTP: GET /storecategory/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecategory/search', 'method_kind': 'GET'}

    @download
    def getCategory(self,
                    storecategory_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /storecategory/{id} ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s"
        path_params = {"id": storecategory_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCategory.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCategory', 'method_docs': '[ HTTP: GET /storecategory/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecategory_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecategory_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecategory/%(id)s', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     storecategory_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storecategory/{id}/export ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s/export"
        path_params = {"id": storecategory_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /storecategory/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecategory_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecategory_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecategory/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storecategory/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /storecategory/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecategory/export', 'method_kind': 'GET'}

    @download
    def updateCategory(self,
                       storecategory_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /storecategory/{id} ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s"
        path_params = {"id": storecategory_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCategory.context = {'query_params': [], 'method_name': 'updateCategory', 'method_docs': '[ HTTP: PUT /storecategory/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecategory_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecategory_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storecategory/%(id)s', 'method_kind': 'PUT'}

    @download
    def deleteCategory(self,
                       storecategory_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /storecategory/{id} ]

        @param storecategory_id: storecategory_id
        @type storecategory_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory/%(id)s"
        path_params = {"id": storecategory_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCategory.context = {'query_params': [], 'method_name': 'deleteCategory', 'method_docs': '[ HTTP: DELETE /storecategory/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecategory_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecategory_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecategory/%(id)s', 'method_kind': 'DELETE'}

    @download
    def createCategory(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /storecategory ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCategory.context = {'query_params': [], 'method_name': 'createCategory', 'method_docs': '[ HTTP: POST /storecategory ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storecategory', 'method_kind': 'POST'}

    @download
    def getCategories(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /storecategory ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecategory"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCategories.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCategories', 'method_docs': '[ HTTP: GET /storecategory ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecategory', 'method_kind': 'GET'}

class script(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getScriptMulti(self,
                       script_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptMulti.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getScriptMulti', 'method_docs': '[ HTTP: GET /script/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s', 'method_kind': 'GET'}

    @download
    def reject(self,
               script_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /script/{id}/reject ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/reject"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: POST /script/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/reject', 'method_kind': 'POST'}

    @download
    def createAttachmentXML(self,
                            script_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAttachmentXML.context = {'query_params': [], 'method_name': 'createAttachmentXML', 'method_docs': '[ HTTP: POST /script/{id}/attachment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/attachment', 'method_kind': 'POST'}

    @download
    def approval(self,
                 script_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /script/{id}/approval ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/approval"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /script/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def exportAllAction(self,
                        exportOpts=None,
                        recursive=None,
                        **kwargs):
        """
        [ HTTP: GET /script/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /script/export ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/export', 'method_kind': 'GET'}

    @download
    def getAttachmentsXML(self,
                          script_id,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAttachmentsXML', 'method_docs': '[ HTTP: GET /script/{id}/attachment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s/attachment', 'method_kind': 'GET'}

    @download
    def createAttachmentMulti(self,
                              script_id,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: POST /script/{id}/attachment ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAttachmentMulti.context = {'query_params': [], 'method_name': 'createAttachmentMulti', 'method_docs': '[ HTTP: POST /script/{id}/attachment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'form_params': [], 'method_path': 'script/%(id)s/attachment', 'method_kind': 'POST'}

    @download
    def updateScript(self,
                     script_id=None,
                     fields=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateScript.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateScript', 'method_docs': '[ HTTP: PUT /script/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s', 'method_kind': 'PUT'}

    @download
    def checkOut(self,
                 script_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /script/{id}/checkout ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/checkout"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'method_name': 'checkOut', 'method_docs': '[ HTTP: POST /script/{id}/checkout ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/checkout', 'method_kind': 'POST'}

    @download
    def searchScripts(self,
                      containerId=None,
                      fields=None,
                      filterGroup=None,
                      limit=None,
                      offset=None,
                      orderBy=None,
                      qterm=None,
                      usage=None,
                      **kwargs):
        """
        [ HTTP: GET /script/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchScripts.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchScripts', 'method_docs': '[ HTTP: GET /script/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/search', 'method_kind': 'GET'}

    @download
    def updateScriptBody(self,
                         script_id,
                         fields=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /script/{id}/body ]

        @param script_id: script_id
        @type script_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/body"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateScriptBody.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateScriptBody', 'method_docs': '[ HTTP: PUT /script/{id}/body ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'text/plain'}, 'form_params': [], 'method_path': 'script/%(id)s/body', 'method_kind': 'PUT'}

    @download
    def approve(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/approve ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/approve"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: POST /script/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def getScriptsXML(self,
                      fields=None,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /script ]

        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}], 'method_name': 'getScriptsXML', 'method_docs': '[ HTTP: GET /script ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script', 'method_kind': 'GET'}

    @download
    def setHead(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/head ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/head"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setHead.context = {'query_params': [], 'method_name': 'setHead', 'method_docs': '[ HTTP: POST /script/{id}/head ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s/head', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     script_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /script/{id}/export ]

        @param script_id: script_id
        @type script_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/export"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /script/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getScript(self,
                  script_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScript.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getScript', 'method_docs': '[ HTTP: GET /script/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s', 'method_kind': 'GET'}

    @download
    def rejection(self,
                  script_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /script/{id}/rejection ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/rejection"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /script/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def deleteAttachmentXML(self,
                            script_id,
                            attachment_id=None,
                            **kwargs):
        """
        [ HTTP: DELETE /script/{id}/attachment/{attachment_id} ]

        @param script_id: script_id
        @type script_id: str
        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/attachment/%(attachment_id)s"
        path_params = {"id": script_id,
                       "attachment_id": attachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAttachmentXML.context = {'query_params': [], 'method_name': 'deleteAttachmentXML', 'method_docs': '[ HTTP: DELETE /script/{id}/attachment/{attachment_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'attachment_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'attachment_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s/attachment/%(attachment_id)s', 'method_kind': 'DELETE'}

    @download
    def getAllVersions(self,
                       script_slotId,
                       fields=None,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /script/{slotId}/version ]

        @param script_slotId: script_slotId
        @type script_slotId: str
        @param fields: fields
        @type fields: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(slotId)s/version"
        path_params = {"slotId": script_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "includeHead": includeHead}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /script/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_slotId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(slotId)s/version', 'method_kind': 'GET'}

    @download
    def checkIn(self,
                script_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /script/{id}/checkin ]

        @param script_id: script_id
        @type script_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s/checkin"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'method_name': 'checkIn', 'method_docs': '[ HTTP: POST /script/{id}/checkin ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'script/%(id)s/checkin', 'method_kind': 'POST'}

    @download
    def deleteScript(self,
                     script_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /script/{id} ]

        @param script_id: script_id
        @type script_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "script/%(id)s"
        path_params = {"id": script_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteScript.context = {'query_params': [], 'method_name': 'deleteScript', 'method_docs': '[ HTTP: DELETE /script/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'script_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'script/%(id)s', 'method_kind': 'DELETE'}

class artifactattachment(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAttachmentMulti(self,
                           artifactattachment_id=None,
                           **kwargs):
        """
        [ HTTP: GET /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachmentMulti.context = {'query_params': [], 'method_name': 'getAttachmentMulti', 'method_docs': '[ HTTP: GET /artifactattachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifactattachment/%(id)s', 'method_kind': 'GET'}

    @download
    def updateAttachment(self,
                         artifactattachment_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAttachment.context = {'query_params': [], 'method_name': 'updateAttachment', 'method_docs': '[ HTTP: PUT /artifactattachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'artifactattachment/%(id)s', 'method_kind': 'PUT'}

    @download
    def deleteAttachment(self,
                         artifactattachment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAttachment.context = {'query_params': [], 'method_name': 'deleteAttachment', 'method_docs': '[ HTTP: DELETE /artifactattachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifactattachment/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getAttachment(self,
                      artifactattachment_id=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /artifactattachment/{id} ]

        @param artifactattachment_id: artifactattachment_id
        @type artifactattachment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment/%(id)s"
        path_params = {"id": artifactattachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachment.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAttachment', 'method_docs': '[ HTTP: GET /artifactattachment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifactattachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifactattachment/%(id)s', 'method_kind': 'GET'}

    @download
    def getAttachments(self,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /artifactattachment ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifactattachment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAttachments', 'method_docs': '[ HTTP: GET /artifactattachment ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifactattachment', 'method_kind': 'GET'}

class mgmtscriptgroup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getMgmtScriptGroup(self,
                           mgmtscriptgroup_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /mgmtscriptgroup/{id} ]

        @param mgmtscriptgroup_id: mgmtscriptgroup_id
        @type mgmtscriptgroup_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "mgmtscriptgroup/%(id)s"
        path_params = {"id": mgmtscriptgroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMgmtScriptGroup.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getMgmtScriptGroup', 'method_docs': '[ HTTP: GET /mgmtscriptgroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'mgmtscriptgroup_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'mgmtscriptgroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'mgmtscriptgroup/%(id)s', 'method_kind': 'GET'}

    @download
    def searchMgmtScriptGroups(self,
                               fields=None,
                               filterGroup=None,
                               limit=None,
                               offset=None,
                               orderBy=None,
                               qterm=None,
                               usage=None,
                               **kwargs):
        """
        [ HTTP: GET /mgmtscriptgroup/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "mgmtscriptgroup/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchMgmtScriptGroups.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchMgmtScriptGroups', 'method_docs': '[ HTTP: GET /mgmtscriptgroup/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'mgmtscriptgroup/search', 'method_kind': 'GET'}

    @download
    def getMgmtScriptGroups(self,
                            fields=None,
                            **kwargs):
        """
        [ HTTP: GET /mgmtscriptgroup ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "mgmtscriptgroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMgmtScriptGroups.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getMgmtScriptGroups', 'method_docs': '[ HTTP: GET /mgmtscriptgroup ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'mgmtscriptgroup', 'method_kind': 'GET'}

class servicebindingtype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getType(self,
                servicebindingtype_id=None,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /servicebindingtype/{id} ]

        @param servicebindingtype_id: servicebindingtype_id
        @type servicebindingtype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "servicebindingtype/%(id)s"
        path_params = {"id": servicebindingtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getType', 'method_docs': '[ HTTP: GET /servicebindingtype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'servicebindingtype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'servicebindingtype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'servicebindingtype/%(id)s', 'method_kind': 'GET'}

class platform(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def executeScriptOnNode(self,
                            platform_id,
                            execute_scriptname=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /platform/{id}/execute/{scriptname} ]

        @param platform_id: platform_id
        @type platform_id: str
        @param execute_scriptname: execute_scriptname
        @type execute_scriptname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/%(id)s/execute/%(scriptname)s"
        path_params = {"id": platform_id,
                       "scriptname": execute_scriptname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    executeScriptOnNode.context = {'query_params': [], 'method_name': 'executeScriptOnNode', 'method_docs': '[ HTTP: POST /platform/{id}/execute/{scriptname} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}, {'name': 'scriptname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'execute_scriptname'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}, {'name': 'scriptname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'execute_scriptname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/%(id)s/execute/%(scriptname)s', 'method_kind': 'POST'}

    @download
    def stopAgilityOnNode(self,
                          platform_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /platform/{id}/agility/stop ]

        @param platform_id: platform_id
        @type platform_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/%(id)s/agility/stop"
        path_params = {"id": platform_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopAgilityOnNode.context = {'query_params': [], 'method_name': 'stopAgilityOnNode', 'method_docs': '[ HTTP: POST /platform/{id}/agility/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/%(id)s/agility/stop', 'method_kind': 'POST'}

    @download
    def getAllNodes(self,
                    **kwargs):
        """
        [ HTTP: GET /platform ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllNodes.context = {'query_params': [], 'method_name': 'getAllNodes', 'method_docs': '[ HTTP: GET /platform ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform', 'method_kind': 'GET'}

    @download
    def executeOnAllNodes(self,
                          executeonall_scriptname=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /platform/executeonall/{scriptname} ]

        @param executeonall_scriptname: executeonall_scriptname
        @type executeonall_scriptname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/executeonall/%(scriptname)s"
        path_params = {"scriptname": executeonall_scriptname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    executeOnAllNodes.context = {'query_params': [], 'method_name': 'executeOnAllNodes', 'method_docs': '[ HTTP: POST /platform/executeonall/{scriptname} ]', 'result': 'result', 'method_params': [{'name': 'scriptname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'executeonall_scriptname'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'scriptname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'executeonall_scriptname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/executeonall/%(scriptname)s', 'method_kind': 'POST'}

    @download
    def getNode(self,
                platform_id=None,
                **kwargs):
        """
        [ HTTP: GET /platform/{id} ]

        @param platform_id: platform_id
        @type platform_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/%(id)s"
        path_params = {"id": platform_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNode.context = {'query_params': [], 'method_name': 'getNode', 'method_docs': '[ HTTP: GET /platform/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'platform_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'platform_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/%(id)s', 'method_kind': 'GET'}

    @download
    def getDistSyncConfigParams(self,
                                **kwargs):
        """
        [ HTTP: GET /platform/sync/params ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/sync/params"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDistSyncConfigParams.context = {'query_params': [], 'method_name': 'getDistSyncConfigParams', 'method_docs': '[ HTTP: GET /platform/sync/params ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/sync/params', 'method_kind': 'GET'}

    @download
    def startAgilityOnAllNodes(self,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /platform/agility/startall ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/agility/startall"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startAgilityOnAllNodes.context = {'query_params': [], 'method_name': 'startAgilityOnAllNodes', 'method_docs': '[ HTTP: POST /platform/agility/startall ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/agility/startall', 'method_kind': 'POST'}

    @download
    def getNodeByUuid(self,
                      uuid=None,
                      **kwargs):
        """
        [ HTTP: GET /platform/uuid/{uuid} ]

        @param uuid: uuid
        @type uuid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/uuid/%(uuid)s"
        path_params = {"uuid": uuid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNodeByUuid.context = {'query_params': [], 'method_name': 'getNodeByUuid', 'method_docs': '[ HTTP: GET /platform/uuid/{uuid} ]', 'result': 'result', 'method_params': [{'name': 'uuid', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'uuid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'uuid', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'uuid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/uuid/%(uuid)s', 'method_kind': 'GET'}

    @download
    def getAgilityNodeTypes(self,
                            **kwargs):
        """
        [ HTTP: GET /platform/nodetypes ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/nodetypes"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAgilityNodeTypes.context = {'query_params': [], 'method_name': 'getAgilityNodeTypes', 'method_docs': '[ HTTP: GET /platform/nodetypes ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/nodetypes', 'method_kind': 'GET'}

    @download
    def startAgilityOnNode(self,
                           platform_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /platform/{id}/agility/start ]

        @param platform_id: platform_id
        @type platform_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/%(id)s/agility/start"
        path_params = {"id": platform_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startAgilityOnNode.context = {'query_params': [], 'method_name': 'startAgilityOnNode', 'method_docs': '[ HTTP: POST /platform/{id}/agility/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/%(id)s/agility/start', 'method_kind': 'POST'}

    @download
    def updateNodeType(self,
                       platform_id,
                       newtype_type=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /platform/{id}/newtype/{type} ]

        @param platform_id: platform_id
        @type platform_id: str
        @param newtype_type: newtype_type
        @type newtype_type: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/%(id)s/newtype/%(type)s"
        path_params = {"id": platform_id,
                       "type": newtype_type}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNodeType.context = {'query_params': [], 'method_name': 'updateNodeType', 'method_docs': '[ HTTP: PUT /platform/{id}/newtype/{type} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'newtype_type'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'platform_id'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'newtype_type'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/%(id)s/newtype/%(type)s', 'method_kind': 'PUT'}

    @download
    def stopAgilityOnAllNodes(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /platform/agility/stopall ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/agility/stopall"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopAgilityOnAllNodes.context = {'query_params': [], 'method_name': 'stopAgilityOnAllNodes', 'method_docs': '[ HTTP: POST /platform/agility/stopall ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/agility/stopall', 'method_kind': 'POST'}

    @download
    def getNodeByIP(self,
                    address_ip=None,
                    **kwargs):
        """
        [ HTTP: GET /platform/address/{ip} ]

        @param address_ip: address_ip
        @type address_ip: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "platform/address/%(ip)s"
        path_params = {"ip": address_ip}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNodeByIP.context = {'query_params': [], 'method_name': 'getNodeByIP', 'method_docs': '[ HTTP: GET /platform/address/{ip} ]', 'result': 'result', 'method_params': [{'name': 'ip', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'address_ip'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'ip', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'address_ip'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'platform/address/%(ip)s', 'method_kind': 'GET'}

class sdn(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createNetworkProvider(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /sdn ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetworkProvider.context = {'query_params': [], 'method_name': 'createNetworkProvider', 'method_docs': '[ HTTP: POST /sdn ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'sdn', 'method_kind': 'POST'}

    @download
    def searchSdnRouters(self,
                         sdn_id,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /sdn/{id}/router/search ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/router/search"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchSdnRouters.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchSdnRouters', 'method_docs': '[ HTTP: GET /sdn/{id}/router/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/router/search', 'method_kind': 'GET'}

    @download
    def searchNetworkProviders(self,
                               containerId=None,
                               fields=None,
                               filterGroup=None,
                               limit=None,
                               offset=None,
                               orderBy=None,
                               qterm=None,
                               usage=None,
                               **kwargs):
        """
        [ HTTP: GET /sdn/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchNetworkProviders.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchNetworkProviders', 'method_docs': '[ HTTP: GET /sdn/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/search', 'method_kind': 'GET'}

    @download
    def createFloatingIP(self,
                         sdn_id,
                         fields=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /sdn/{id}/floatingip ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/floatingip"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createFloatingIP.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createFloatingIP', 'method_docs': '[ HTTP: POST /sdn/{id}/floatingip ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'sdn/%(id)s/floatingip', 'method_kind': 'POST'}

    @download
    def getNetworkProvidersXML(self,
                               fields=None,
                               **kwargs):
        """
        [ HTTP: GET /sdn ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkProvidersXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkProvidersXML', 'method_docs': '[ HTTP: GET /sdn ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn', 'method_kind': 'GET'}

    @download
    def deleteNetworkProvider(self,
                              sdn_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /sdn/{id} ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetworkProvider.context = {'query_params': [], 'method_name': 'deleteNetworkProvider', 'method_docs': '[ HTTP: DELETE /sdn/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getNetworkProvider(self,
                           sdn_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /sdn/{id} ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkProvider.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkProvider', 'method_docs': '[ HTTP: GET /sdn/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s', 'method_kind': 'GET'}

    @download
    def updateNetworkProvider(self,
                              sdn_id=None,
                              fields=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /sdn/{id} ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNetworkProvider.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateNetworkProvider', 'method_docs': '[ HTTP: PUT /sdn/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'sdn/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchSdnNetworks(self,
                          sdn_id,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /sdn/{id}/network/search ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/network/search"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchSdnNetworks.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchSdnNetworks', 'method_docs': '[ HTTP: GET /sdn/{id}/network/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/network/search', 'method_kind': 'GET'}

    @download
    def getFloatingIPs(self,
                       sdn_id,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /sdn/{id}/floatingip ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/floatingip"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getFloatingIPs.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getFloatingIPs', 'method_docs': '[ HTTP: GET /sdn/{id}/floatingip ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/floatingip', 'method_kind': 'GET'}

    @download
    def createRouter(self,
                     sdn_id,
                     fields=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /sdn/{id}/router ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/router"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRouter.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createRouter', 'method_docs': '[ HTTP: POST /sdn/{id}/router ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'sdn/%(id)s/router', 'method_kind': 'POST'}

    @download
    def sync(self,
             sdn_id,
             data=None,
             **kwargs):
        """
        [ HTTP: POST /sdn/{id}/sync ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/sync"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    sync.context = {'query_params': [], 'method_name': 'sync', 'method_docs': '[ HTTP: POST /sdn/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/sync', 'method_kind': 'POST'}

    @download
    def getNetworks(self,
                    sdn_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /sdn/{id}/network ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/network"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworks.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworks', 'method_docs': '[ HTTP: GET /sdn/{id}/network ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/network', 'method_kind': 'GET'}

    @download
    def createNetwork(self,
                      sdn_id,
                      fields=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /sdn/{id}/network ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/network"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetwork.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createNetwork', 'method_docs': '[ HTTP: POST /sdn/{id}/network ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'sdn/%(id)s/network', 'method_kind': 'POST'}

    @download
    def getRouters(self,
                   sdn_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /sdn/{id}/router ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/router"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRouters.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRouters', 'method_docs': '[ HTTP: GET /sdn/{id}/router ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/router', 'method_kind': 'GET'}

    @download
    def searchSdnFloatingIPs(self,
                             sdn_id,
                             fields=None,
                             filterGroup=None,
                             limit=None,
                             offset=None,
                             orderBy=None,
                             usage=None,
                             **kwargs):
        """
        [ HTTP: GET /sdn/{id}/floatingip/search ]

        @param sdn_id: sdn_id
        @type sdn_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "sdn/%(id)s/floatingip/search"
        path_params = {"id": sdn_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchSdnFloatingIPs.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchSdnFloatingIPs', 'method_docs': '[ HTTP: GET /sdn/{id}/floatingip/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'sdn_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'sdn/%(id)s/floatingip/search', 'method_kind': 'GET'}

class propertygroup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getPropertyDefinitionGroup(self,
                                   propertygroup_id=None,
                                   **kwargs):
        """
        [ HTTP: GET /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyDefinitionGroup.context = {'query_params': [], 'method_name': 'getPropertyDefinitionGroup', 'method_docs': '[ HTTP: GET /propertygroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertygroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertygroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertygroup/%(id)s', 'method_kind': 'GET'}

    @download
    def getPropertyDefinitionGroupsXML(self,
                                       fields=None,
                                       **kwargs):
        """
        [ HTTP: GET /propertygroup ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyDefinitionGroupsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPropertyDefinitionGroupsXML', 'method_docs': '[ HTTP: GET /propertygroup ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertygroup', 'method_kind': 'GET'}

    @download
    def updatePropertyDefinitionGroup(self,
                                      propertygroup_id=None,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: PUT /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePropertyDefinitionGroup.context = {'query_params': [], 'method_name': 'updatePropertyDefinitionGroup', 'method_docs': '[ HTTP: PUT /propertygroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertygroup_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertygroup_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'propertygroup/%(id)s', 'method_kind': 'PUT'}

    @download
    def createPropertyDefinitionGroupXML(self,
                                         data=None,
                                         **kwargs):
        """
        [ HTTP: POST /propertygroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPropertyDefinitionGroupXML.context = {'query_params': [], 'method_name': 'createPropertyDefinitionGroupXML', 'method_docs': '[ HTTP: POST /propertygroup ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'propertygroup', 'method_kind': 'POST'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /propertygroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /propertygroup/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'propertygroup/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     propertygroup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /propertygroup/{id}/export ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s/export"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /propertygroup/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'propertygroup_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'propertygroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertygroup/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /propertygroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /propertygroup/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'propertygroup/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /propertygroup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /propertygroup/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertygroup/export', 'method_kind': 'GET'}

    @download
    def deletePropertyDefinitionGroup(self,
                                      propertygroup_id=None,
                                      **kwargs):
        """
        [ HTTP: DELETE /propertygroup/{id} ]

        @param propertygroup_id: propertygroup_id
        @type propertygroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertygroup/%(id)s"
        path_params = {"id": propertygroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePropertyDefinitionGroup.context = {'query_params': [], 'method_name': 'deletePropertyDefinitionGroup', 'method_docs': '[ HTTP: DELETE /propertygroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertygroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertygroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertygroup/%(id)s', 'method_kind': 'DELETE'}

class assettype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createAssetTypeXML(self,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /assettype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAssetTypeXML.context = {'query_params': [], 'method_name': 'createAssetTypeXML', 'method_docs': '[ HTTP: POST /assettype ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'assettype', 'method_kind': 'POST'}

    @download
    def getAssetTypeSubset(self,
                           sub_id=None,
                           leafOnly=None,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           qterm=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /assettype/sub/{id} ]

        @param sub_id: sub_id
        @type sub_id: str
        @param leafOnly: leafOnly
        @type leafOnly: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/sub/%(id)s"
        path_params = {"id": sub_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"leafOnly": leafOnly,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetTypeSubset.context = {'query_params': [{'name': 'leafOnly', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'leafOnly'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'getAssetTypeSubset', 'method_docs': '[ HTTP: GET /assettype/sub/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sub_id'}, {'name': 'leafOnly', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'leafOnly'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sub_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype/sub/%(id)s', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /assettype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /assettype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /assettype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /assettype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'assettype/import', 'method_kind': 'PUT'}

    @download
    def getAssetType(self,
                     assettype_id=None,
                     beanFields=None,
                     entityType=None,
                     **kwargs):
        """
        [ HTTP: GET /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param beanFields: beanFields
        @type beanFields: str
        @param entityType: entityType
        @type entityType: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"beanFields": beanFields,
                        "entityType": entityType}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetType.context = {'query_params': [{'name': 'beanFields', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'beanFields'}, {'name': 'entityType', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'entityType'}], 'method_name': 'getAssetType', 'method_docs': '[ HTTP: GET /assettype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assettype_id'}, {'name': 'beanFields', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'beanFields'}, {'name': 'entityType', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'entityType'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assettype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype/%(id)s', 'method_kind': 'GET'}

    @download
    def getPermissionTypes(self,
                           assettype_id,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /assettype/{id}/permissiontype ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/permissiontype"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPermissionTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPermissionTypes', 'method_docs': '[ HTTP: GET /assettype/{id}/permissiontype ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'assettype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'assettype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype/%(id)s/permissiontype', 'method_kind': 'GET'}

    @download
    def deleteAssetType(self,
                        assettype_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAssetType.context = {'query_params': [], 'method_name': 'deleteAssetType', 'method_docs': '[ HTTP: DELETE /assettype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assettype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assettype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype/%(id)s', 'method_kind': 'DELETE'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /assettype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /assettype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'assettype/import', 'method_kind': 'PUT'}

    @download
    def addPermissionType(self,
                          assettype_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /assettype/{id}/permissiontype ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/permissiontype"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addPermissionType.context = {'query_params': [], 'method_name': 'addPermissionType', 'method_docs': '[ HTTP: POST /assettype/{id}/permissiontype ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'assettype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'assettype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'assettype/%(id)s/permissiontype', 'method_kind': 'POST'}

    @download
    def updateAssetType(self,
                        assettype_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /assettype/{id} ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAssetType.context = {'query_params': [], 'method_name': 'updateAssetType', 'method_docs': '[ HTTP: PUT /assettype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assettype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assettype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'assettype/%(id)s', 'method_kind': 'PUT'}

    @download
    def getAssetTypesXML(self,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /assettype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetTypesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAssetTypesXML', 'method_docs': '[ HTTP: GET /assettype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     assettype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /assettype/{id}/export ]

        @param assettype_id: assettype_id
        @type assettype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "assettype/%(id)s/export"
        path_params = {"id": assettype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /assettype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'assettype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'assettype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'assettype/%(id)s/export', 'method_kind': 'GET'}

class project(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getScripts(self,
                   project_id,
                   fields=None,
                   version=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id}/script ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/script"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScripts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}], 'method_name': 'getScripts', 'method_docs': '[ HTTP: GET /project/{id}/script ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/script', 'method_kind': 'GET'}

    @download
    def createTopology(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/topology ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/topology"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTopology.context = {'query_params': [], 'method_name': 'createTopology', 'method_docs': '[ HTTP: POST /project/{id}/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/topology', 'method_kind': 'POST'}

    @download
    def createEnvironment(self,
                          project_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /project/{id}/environment ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/environment"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createEnvironment.context = {'query_params': [], 'method_name': 'createEnvironment', 'method_docs': '[ HTTP: POST /project/{id}/environment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/environment', 'method_kind': 'POST'}

    @download
    def createPackage(self,
                      project_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /project/{id}/package ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/package"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPackage.context = {'query_params': [], 'method_name': 'createPackage', 'method_docs': '[ HTTP: POST /project/{id}/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/package', 'method_kind': 'POST'}

    @download
    def getSecurity(self,
                    project_id,
                    security_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/security/{security_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSecurity', 'method_docs': '[ HTTP: GET /project/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s', 'method_kind': 'GET'}

    @download
    def deleteSecurityRights(self,
                             project_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'method_name': 'deleteSecurityRights', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'method_kind': 'DELETE'}

    @download
    def addSecurity(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/security ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'method_name': 'addSecurity', 'method_docs': '[ HTTP: POST /project/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/security', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     project_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/export ]

        @param project_id: project_id
        @type project_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/export"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /project/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/export', 'method_kind': 'GET'}

    @download
    def addSecurityUser(self,
                        project_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/user ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/user"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'method_name': 'addSecurityUser', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/user', 'method_kind': 'POST'}

    @download
    def getProjects(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /project ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjects.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProjects', 'method_docs': '[ HTTP: GET /project ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project', 'method_kind': 'GET'}

    @download
    def getSolutions(self,
                     project_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/solution ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/solution"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSolutions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSolutions', 'method_docs': '[ HTTP: GET /project/{id}/solution ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/solution', 'method_kind': 'GET'}

    @download
    def getAlias(self,
                 project_id,
                 alias_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAlias', 'method_docs': '[ HTTP: GET /project/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'method_kind': 'GET'}

    @download
    def getVariablesByName(self,
                           project_id,
                           variable_vname=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /project/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"project_id": project_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesByName.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariablesByName', 'method_docs': '[ HTTP: GET /project/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'GET'}

    @download
    def startProject(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/start ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/start"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startProject.context = {'query_params': [], 'method_name': 'startProject', 'method_docs': '[ HTTP: POST /project/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/start', 'method_kind': 'POST'}

    @download
    def createScript(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/script ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/script"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScript.context = {'query_params': [], 'method_name': 'createScript', 'method_docs': '[ HTTP: POST /project/{id}/script ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/script', 'method_kind': 'POST'}

    @download
    def attachPolicy(self,
                     project_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /project/{id}/policy/{policyid} ]

        @param project_id: project_id
        @type project_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy/%(policyid)s"
        path_params = {"id": project_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /project/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def addSecurityAccessRight(self,
                               project_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'method_name': 'addSecurityAccessRight', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'method_kind': 'POST'}

    @download
    def updateAlias(self,
                    project_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'method_name': 'updateAlias', 'method_docs': '[ HTTP: PUT /project/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'method_kind': 'PUT'}

    @download
    def addSecurityRights(self,
                          project_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/rights ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'method_name': 'addSecurityRights', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/rights ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/rights', 'method_kind': 'POST'}

    @download
    def createMultiVariable(self,
                            project_id,
                            variable_vname=None,
                            fields=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /project/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"project_id": project_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMultiVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createMultiVariable', 'method_docs': '[ HTTP: POST /project/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getVariables(self,
                     project_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/variable ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariables', 'method_docs': '[ HTTP: GET /project/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def getProject(self,
                   project_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProject.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProject', 'method_docs': '[ HTTP: GET /project/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s', 'method_kind': 'GET'}

    @download
    def getTemplates(self,
                     project_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /project/{id}/template ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/template"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplates.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTemplates', 'method_docs': '[ HTTP: GET /project/{id}/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/template', 'method_kind': 'GET'}

    @download
    def searchPolicyAssignments(self,
                                project_id,
                                containerId=None,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /project/{id}/policyassignment/search ]

        @param project_id: project_id
        @type project_id: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policyassignment/search"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /project/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       create=None,
                       update=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /project/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/import', 'method_kind': 'PUT'}

    @download
    def getProjectsStats(self,
                         **kwargs):
        """
        [ HTTP: GET /project/stats ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/stats"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjectsStats.context = {'query_params': [], 'method_name': 'getProjectsStats', 'method_docs': '[ HTTP: GET /project/stats ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/stats', 'method_kind': 'GET'}

    @download
    def getPolicies(self,
                    project_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/policy ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /project/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def importIDAction_2(self,
                         project_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         files=None,
                         **kwargs):
        """
        [ HTTP: PUT /project/{id}/import ]

        @param project_id: project_id
        @type project_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/import"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_2', 'method_docs': '[ HTTP: PUT /project/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'project/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def createVariable(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/variable ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /project/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def stopProject(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/stop ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/stop"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopProject.context = {'query_params': [], 'method_name': 'stopProject', 'method_docs': '[ HTTP: POST /project/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def getTopologies(self,
                      project_id,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /project/{id}/topology ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/topology"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTopologies', 'method_docs': '[ HTTP: GET /project/{id}/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/topology', 'method_kind': 'GET'}

    @download
    def createTemplate(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/template ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/template"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createTemplate.context = {'query_params': [], 'method_name': 'createTemplate', 'method_docs': '[ HTTP: POST /project/{id}/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/template', 'method_kind': 'POST'}

    @download
    def decryptVariable(self,
                        project_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /project/{id}/variable/{variable_id}/decrypt ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'method_name': 'decryptVariable', 'method_docs': '[ HTTP: GET /project/{id}/variable/{variable_id}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/variable/%(variable_id)s/decrypt', 'method_kind': 'GET'}

    @download
    def getBlueprints(self,
                      project_id,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /project/{project_id}/blueprint ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/blueprint"
        path_params = {"project_id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getBlueprints.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getBlueprints', 'method_docs': '[ HTTP: GET /project/{project_id}/blueprint ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(project_id)s/blueprint', 'method_kind': 'GET'}

    @download
    def getPackages(self,
                    project_id,
                    fields=None,
                    version=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{id}/package ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/package"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}], 'method_name': 'getPackages', 'method_docs': '[ HTTP: GET /project/{id}/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/package', 'method_kind': 'GET'}

    @download
    def createProject_1(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project/projecttemplate ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/projecttemplate"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProject_1.context = {'query_params': [], 'method_name': 'createProject_1', 'method_docs': '[ HTTP: POST /project/projecttemplate ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/projecttemplate', 'method_kind': 'POST'}

    @download
    def getEnvironments(self,
                        project_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /project/{id}/environment ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/environment"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEnvironments', 'method_docs': '[ HTTP: GET /project/{id}/environment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/environment', 'method_kind': 'GET'}

    @download
    def deleteVariable(self,
                       project_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /project/{project_id}/variable/{variable_id: [0-9]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /project/{project_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def releaseProject(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/release ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/release"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseProject.context = {'query_params': [], 'method_name': 'releaseProject', 'method_docs': '[ HTTP: POST /project/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/release', 'method_kind': 'POST'}

    @download
    def createProject_2(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProject_2.context = {'query_params': [], 'method_name': 'createProject_2', 'method_docs': '[ HTTP: POST /project ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project', 'method_kind': 'POST'}

    @download
    def importIDAction_1(self,
                         project_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /project/{id}/import ]

        @param project_id: project_id
        @type project_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/import"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_1', 'method_docs': '[ HTTP: PUT /project/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getVariable(self,
                    project_id,
                    variable_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /project/{project_id}/variable/{variable_id: [0-9]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariable', 'method_docs': '[ HTTP: GET /project/{project_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def createAlias(self,
                    project_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /project/{id}/alias ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'method_name': 'createAlias', 'method_docs': '[ HTTP: POST /project/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/alias', 'method_kind': 'POST'}

    @download
    def createBlueprint(self,
                        project_id,
                        fields=None,
                        force=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /project/{id}/blueprint ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param force: force
        @type force: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/blueprint"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "force": force}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createBlueprint.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'force', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'force'}], 'method_name': 'createBlueprint', 'method_docs': '[ HTTP: POST /project/{id}/blueprint ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'force', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'force'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/blueprint', 'method_kind': 'POST'}

    @download
    def addSecurityUserGroup(self,
                             project_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /project/{id}/security/{security_id}/usergroup ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'method_name': 'addSecurityUserGroup', 'method_docs': '[ HTTP: POST /project/{id}/security/{security_id}/usergroup ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/usergroup', 'method_kind': 'POST'}

    @download
    def importAction_2(self,
                       create=None,
                       update=None,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /project/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'project/import', 'method_kind': 'PUT'}

    @download
    def restartProject(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/restart ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/restart"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    restartProject.context = {'query_params': [], 'method_name': 'restartProject', 'method_docs': '[ HTTP: POST /project/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def getAliases(self,
                   project_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /project/{id}/alias ]

        @param project_id: project_id
        @type project_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAliases', 'method_docs': '[ HTTP: GET /project/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/alias', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /project/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /project/export ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/export', 'method_kind': 'GET'}

    @download
    def removePolicy(self,
                     project_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /project/{id}/policy/{policyid} ]

        @param project_id: project_id
        @type project_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/policy/%(policyid)s"
        path_params = {"id": project_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /project/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurityUserGroup(self,
                                project_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'method_name': 'deleteSecurityUserGroup', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurity(self,
                       project_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'method_name': 'deleteSecurity', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteAlias(self,
                    project_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /project/{id}/alias/{alias_id} ]

        @param project_id: project_id
        @type project_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/alias/%(alias_id)s"
        path_params = {"id": project_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'method_name': 'deleteAlias', 'method_docs': '[ HTTP: DELETE /project/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/alias/%(alias_id)s', 'method_kind': 'DELETE'}

    @download
    def searchProjects(self,
                       containerId=None,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       qterm=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /project/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProjects.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchProjects', 'method_docs': '[ HTTP: GET /project/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/search', 'method_kind': 'GET'}

    @download
    def updateProject(self,
                      project_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateProject.context = {'query_params': [], 'method_name': 'updateProject', 'method_docs': '[ HTTP: PUT /project/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s', 'method_kind': 'PUT'}

    @download
    def createSolution(self,
                       project_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /project/{id}/solution ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/solution"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createSolution.context = {'query_params': [], 'method_name': 'createSolution', 'method_docs': '[ HTTP: POST /project/{id}/solution ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/solution', 'method_kind': 'POST'}

    @download
    def deleteProject(self,
                      project_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /project/{id} ]

        @param project_id: project_id
        @type project_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteProject.context = {'query_params': [], 'method_name': 'deleteProject', 'method_docs': '[ HTTP: DELETE /project/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'project_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurityUser(self,
                           project_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/user/{user_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'method_name': 'deleteSecurityUser', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/user/{user_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/user/%(user_id)s', 'method_kind': 'DELETE'}

    @download
    def cloneProject(self,
                     project_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /project/{id}/clone ]

        @param project_id: project_id
        @type project_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/clone"
        path_params = {"id": project_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneProject.context = {'query_params': [], 'method_name': 'cloneProject', 'method_docs': '[ HTTP: POST /project/{id}/clone ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'project/%(id)s/clone', 'method_kind': 'POST'}

    @download
    def deleteSecurityAccessRight(self,
                                  project_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param project_id: project_id
        @type project_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": project_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'method_name': 'deleteSecurityAccessRight', 'method_docs': '[ HTTP: DELETE /project/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'project/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'method_kind': 'DELETE'}

    @download
    def updateVariable(self,
                       project_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /project/{project_id}/variable/{variable_id: [0-9]+} ]

        @param project_id: project_id
        @type project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "project/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /project/{project_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'project/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'PUT'}

class paas(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchPlatformServices(self,
                               fields=None,
                               filterGroup=None,
                               limit=None,
                               offset=None,
                               orderBy=None,
                               usage=None,
                               **kwargs):
        """
        [ HTTP: GET /paas/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPlatformServices.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchPlatformServices', 'method_docs': '[ HTTP: GET /paas/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paas/search', 'method_kind': 'GET'}

    @download
    def updatePlatformService(self,
                              paas_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /paas/{id} ]

        @param paas_id: paas_id
        @type paas_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s"
        path_params = {"id": paas_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePlatformService.context = {'query_params': [], 'method_name': 'updatePlatformService', 'method_docs': '[ HTTP: PUT /paas/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paas_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paas_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'paas/%(id)s', 'method_kind': 'PUT'}

    @download
    def getServiceTypes(self,
                        paas_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /paas/{id}/servicetype ]

        @param paas_id: paas_id
        @type paas_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s/servicetype"
        path_params = {"id": paas_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getServiceTypes', 'method_docs': '[ HTTP: GET /paas/{id}/servicetype ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'paas_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'paas_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paas/%(id)s/servicetype', 'method_kind': 'GET'}

    @download
    def getArtifactTypes(self,
                         paas_id,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /paas/{id}/artifacttype ]

        @param paas_id: paas_id
        @type paas_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s/artifacttype"
        path_params = {"id": paas_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifactTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifactTypes', 'method_docs': '[ HTTP: GET /paas/{id}/artifacttype ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'paas_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'paas_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paas/%(id)s/artifacttype', 'method_kind': 'GET'}

    @download
    def createPlatformService(self,
                              id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /paas ]

        @param id: id
        @type id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas"
        path_params = {"id": id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPlatformService.context = {'query_params': [], 'method_name': 'createPlatformService', 'method_docs': '[ HTTP: POST /paas ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'paas', 'method_kind': 'POST'}

    @download
    def getPlatformServices(self,
                            id,
                            fields=None,
                            **kwargs):
        """
        [ HTTP: GET /paas ]

        @param id: id
        @type id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas"
        path_params = {"id": id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPlatformServices.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPlatformServices', 'method_docs': '[ HTTP: GET /paas ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paas', 'method_kind': 'GET'}

    @download
    def getPlatformService(self,
                           paas_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /paas/{id} ]

        @param paas_id: paas_id
        @type paas_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s"
        path_params = {"id": paas_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPlatformService.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPlatformService', 'method_docs': '[ HTTP: GET /paas/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paas_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paas_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paas/%(id)s', 'method_kind': 'GET'}

    @download
    def deletePlatformService(self,
                              paas_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /paas/{id} ]

        @param paas_id: paas_id
        @type paas_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paas/%(id)s"
        path_params = {"id": paas_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePlatformService.context = {'query_params': [], 'method_name': 'deletePlatformService', 'method_docs': '[ HTTP: DELETE /paas/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paas_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paas_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paas/%(id)s', 'method_kind': 'DELETE'}

class floatingip(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchFloatingIPs(self,
                          containerId=None,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          qterm=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /floatingip/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "floatingip/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchFloatingIPs.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchFloatingIPs', 'method_docs': '[ HTTP: GET /floatingip/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'floatingip/search', 'method_kind': 'GET'}

    @download
    def updateFloatingIP(self,
                         floatingip_id=None,
                         fields=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /floatingip/{id} ]

        @param floatingip_id: floatingip_id
        @type floatingip_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "floatingip/%(id)s"
        path_params = {"id": floatingip_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateFloatingIP.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateFloatingIP', 'method_docs': '[ HTTP: PUT /floatingip/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'floatingip_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'floatingip_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'floatingip/%(id)s', 'method_kind': 'PUT'}

    @download
    def getFloatingIP(self,
                      floatingip_id=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /floatingip/{id} ]

        @param floatingip_id: floatingip_id
        @type floatingip_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "floatingip/%(id)s"
        path_params = {"id": floatingip_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getFloatingIP.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getFloatingIP', 'method_docs': '[ HTTP: GET /floatingip/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'floatingip_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'floatingip_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'floatingip/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteFloatingIP(self,
                         floatingip_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /floatingip/{id} ]

        @param floatingip_id: floatingip_id
        @type floatingip_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "floatingip/%(id)s"
        path_params = {"id": floatingip_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteFloatingIP.context = {'query_params': [], 'method_name': 'deleteFloatingIP', 'method_docs': '[ HTTP: DELETE /floatingip/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'floatingip_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'floatingip_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'floatingip/%(id)s', 'method_kind': 'DELETE'}

    @download
    def syncFloatingIP(self,
                       floatingip_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /floatingip/{id}/sync ]

        @param floatingip_id: floatingip_id
        @type floatingip_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "floatingip/%(id)s/sync"
        path_params = {"id": floatingip_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncFloatingIP.context = {'query_params': [], 'method_name': 'syncFloatingIP', 'method_docs': '[ HTTP: POST /floatingip/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'floatingip_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'floatingip_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'floatingip/%(id)s/sync', 'method_kind': 'POST'}

    @download
    def getFloatingIPsXML(self,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /floatingip ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "floatingip"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getFloatingIPsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getFloatingIPsXML', 'method_docs': '[ HTTP: GET /floatingip ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'floatingip', 'method_kind': 'GET'}

class image(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getImage(self,
                 image_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /image/{id} ]

        @param image_id: image_id
        @type image_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s"
        path_params = {"id": image_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getImage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getImage', 'method_docs': '[ HTTP: GET /image/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'image_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'image_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'image/%(id)s', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     image_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /image/{id}/export ]

        @param image_id: image_id
        @type image_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s/export"
        path_params = {"id": image_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /image/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'image_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'image_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'image/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /image/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /image/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'image/export', 'method_kind': 'GET'}

    @download
    def getImagesXML(self,
                     **kwargs):
        """
        [ HTTP: GET /image ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getImagesXML.context = {'query_params': [], 'method_name': 'getImagesXML', 'method_docs': '[ HTTP: GET /image ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'image', 'method_kind': 'GET'}

    @download
    def searchImages(self,
                     fields=None,
                     filterGroup=None,
                     limit=None,
                     offset=None,
                     orderBy=None,
                     usage=None,
                     **kwargs):
        """
        [ HTTP: GET /image/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchImages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchImages', 'method_docs': '[ HTTP: GET /image/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'image/search', 'method_kind': 'GET'}

    @download
    def deleteImage(self,
                    image_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /image/{id} ]

        @param image_id: image_id
        @type image_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s"
        path_params = {"id": image_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteImage.context = {'query_params': [], 'method_name': 'deleteImage', 'method_docs': '[ HTTP: DELETE /image/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'image_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'image_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'image/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updateImage(self,
                    image_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /image/{id} ]

        @param image_id: image_id
        @type image_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "image/%(id)s"
        path_params = {"id": image_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateImage.context = {'query_params': [], 'method_name': 'updateImage', 'method_docs': '[ HTTP: PUT /image/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'image_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'image_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'image/%(id)s', 'method_kind': 'PUT'}

class location(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getLocationMetrics(self,
                           location_id,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /location/{id}/usage ]

        @param location_id: location_id
        @type location_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s/usage"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocationMetrics.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getLocationMetrics', 'method_docs': '[ HTTP: GET /location/{id}/usage ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'location_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'location_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'location/%(id)s/usage', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     location_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /location/{id}/export ]

        @param location_id: location_id
        @type location_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s/export"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /location/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'location_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'location_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'location/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /location/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /location/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'location/export', 'method_kind': 'GET'}

    @download
    def getLocation(self,
                    location_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /location/{id} ]

        @param location_id: location_id
        @type location_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocation.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getLocation', 'method_docs': '[ HTTP: GET /location/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'location_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'location_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'location/%(id)s', 'method_kind': 'GET'}

    @download
    def getLocationsXML(self,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /location ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocationsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getLocationsXML', 'method_docs': '[ HTTP: GET /location ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'location', 'method_kind': 'GET'}

    @download
    def searchLocations(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /location/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchLocations.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchLocations', 'method_docs': '[ HTTP: GET /location/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'location/search', 'method_kind': 'GET'}

    @download
    def updateLocation(self,
                       location_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /location/{id} ]

        @param location_id: location_id
        @type location_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "location/%(id)s"
        path_params = {"id": location_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateLocation.context = {'query_params': [], 'method_name': 'updateLocation', 'method_docs': '[ HTTP: PUT /location/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'location_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'location_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'location/%(id)s', 'method_kind': 'PUT'}

class search(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchAssets(self,
                     fields=None,
                     filterGroup=None,
                     limit=None,
                     offset=None,
                     orderBy=None,
                     usage=None,
                     **kwargs):
        """
        [ HTTP: GET /search/asset ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search/asset"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchAssets.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchAssets', 'method_docs': '[ HTTP: GET /search/asset ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'search/asset', 'method_kind': 'GET'}

    @download
    def search(self,
               fields=None,
               filterGroup=None,
               limit=None,
               offset=None,
               orderBy=None,
               usage=None,
               **kwargs):
        """
        [ HTTP: GET /search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    search.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'search', 'method_docs': '[ HTTP: GET /search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'search', 'method_kind': 'GET'}

    @download
    def getSearchFields(self,
                        field_type=None,
                        **kwargs):
        """
        [ HTTP: GET /search/field/{type} ]

        @param field_type: field_type
        @type field_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "search/field/%(type)s"
        path_params = {"type": field_type}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSearchFields.context = {'query_params': [], 'method_name': 'getSearchFields', 'method_docs': '[ HTTP: GET /search/field/{type} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'field_type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'field_type'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'search/field/%(type)s', 'method_kind': 'GET'}

class customcontainer(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchContainers(self,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /customcontainer/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchContainers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchContainers', 'method_docs': '[ HTTP: GET /customcontainer/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/search', 'method_kind': 'GET'}

    @download
    def addSecurity(self,
                    customcontainer_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'method_name': 'addSecurity', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security', 'method_kind': 'POST'}

    @download
    def importIDAction_1(self,
                         customcontainer_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/import ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/import"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_1.context = {'query_params': [], 'method_name': 'importIDAction_1', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def updateCustomItems(self,
                          customcontainer_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/customitems ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customitems"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCustomItems.context = {'query_params': [], 'method_name': 'updateCustomItems', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/customitems ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/customitems', 'method_kind': 'PUT'}

    @download
    def getCustomItems(self,
                       customcontainer_id,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/customitems ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customitems"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCustomItems.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCustomItems', 'method_docs': '[ HTTP: GET /customcontainer/{id}/customitems ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/customitems', 'method_kind': 'GET'}

    @download
    def deleteSecurityRights(self,
                             customcontainer_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'method_name': 'deleteSecurityRights', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'method_kind': 'DELETE'}

    @download
    def importIDAction_2(self,
                         customcontainer_id,
                         data=None,
                         files=None,
                         **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/import ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/import"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_2.context = {'query_params': [], 'method_name': 'importIDAction_2', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getCustomContainer(self,
                           customcontainer_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCustomContainer.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCustomContainer', 'method_docs': '[ HTTP: GET /customcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'customcontainer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteCustomContainer(self,
                              customcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCustomContainer.context = {'query_params': [], 'method_name': 'deleteCustomContainer', 'method_docs': '[ HTTP: DELETE /customcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'customcontainer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getCustomContainers(self,
                            fields=None,
                            **kwargs):
        """
        [ HTTP: GET /customcontainer ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCustomContainers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCustomContainers', 'method_docs': '[ HTTP: GET /customcontainer ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     customcontainer_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/export ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/export"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /customcontainer/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/export', 'method_kind': 'GET'}

    @download
    def addSecurityUser(self,
                        customcontainer_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/user ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/user"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'method_name': 'addSecurityUser', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/user', 'method_kind': 'POST'}

    @download
    def getSecurity(self,
                    customcontainer_id,
                    security_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/security/{security_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSecurity', 'method_docs': '[ HTTP: GET /customcontainer/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s', 'method_kind': 'GET'}

    @download
    def updateCustomContainer(self,
                              customcontainer_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCustomContainer.context = {'query_params': [], 'method_name': 'updateCustomContainer', 'method_docs': '[ HTTP: PUT /customcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'customcontainer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s', 'method_kind': 'PUT'}

    @download
    def addSecurityUserGroup(self,
                             customcontainer_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/usergroup ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'method_name': 'addSecurityUserGroup', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/usergroup ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/usergroup', 'method_kind': 'POST'}

    @download
    def addSecurityAccessRight(self,
                               customcontainer_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'method_name': 'addSecurityAccessRight', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'method_kind': 'POST'}

    @download
    def attachPolicy(self,
                     customcontainer_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /customcontainer/{id}/policy/{policyid} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy/%(policyid)s"
        path_params = {"id": customcontainer_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /customcontainer/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /customcontainer/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /customcontainer/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /customcontainer/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /customcontainer/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/import', 'method_kind': 'PUT'}

    @download
    def removePolicy(self,
                     customcontainer_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/policy/{policyid} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy/%(policyid)s"
        path_params = {"id": customcontainer_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurityUserGroup(self,
                                customcontainer_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'method_name': 'deleteSecurityUserGroup', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurity(self,
                       customcontainer_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'method_name': 'deleteSecurity', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s', 'method_kind': 'DELETE'}

    @download
    def addSecurityRights(self,
                          customcontainer_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /customcontainer/{id}/security/{security_id}/rights ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'method_name': 'addSecurityRights', 'method_docs': '[ HTTP: POST /customcontainer/{id}/security/{security_id}/rights ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights', 'method_kind': 'POST'}

    @download
    def searchPolicyAssignments(self,
                                customcontainer_id,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                usage=None,
                                **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/policyassignment/search ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policyassignment/search"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /customcontainer/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def getPolicies(self,
                    customcontainer_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/policy ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/policy"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /customcontainer/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /customcontainer/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /customcontainer/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'customcontainer/import', 'method_kind': 'PUT'}

    @download
    def getChildCustomContainers(self,
                                 customcontainer_id,
                                 fields=None,
                                 **kwargs):
        """
        [ HTTP: GET /customcontainer/{id}/customcontainer ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/customcontainer"
        path_params = {"id": customcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildCustomContainers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getChildCustomContainers', 'method_docs': '[ HTTP: GET /customcontainer/{id}/customcontainer ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/customcontainer', 'method_kind': 'GET'}

    @download
    def deleteSecurityUser(self,
                           customcontainer_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/user/{user_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'method_name': 'deleteSecurityUser', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/user/{user_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/user/%(user_id)s', 'method_kind': 'DELETE'}

    @download
    def createCustomContainer(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /customcontainer ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCustomContainer.context = {'query_params': [], 'method_name': 'createCustomContainer', 'method_docs': '[ HTTP: POST /customcontainer ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'customcontainer', 'method_kind': 'POST'}

    @download
    def deleteSecurityAccessRight(self,
                                  customcontainer_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param customcontainer_id: customcontainer_id
        @type customcontainer_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": customcontainer_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'method_name': 'deleteSecurityAccessRight', 'method_docs': '[ HTTP: DELETE /customcontainer/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'customcontainer_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'customcontainer/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'method_kind': 'DELETE'}

class mgmtscript(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getMgmtScript(self,
                      mgmtscript_id=None,
                      **kwargs):
        """
        [ HTTP: GET /mgmtscript/{id} ]

        @param mgmtscript_id: mgmtscript_id
        @type mgmtscript_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "mgmtscript/%(id)s"
        path_params = {"id": mgmtscript_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMgmtScript.context = {'query_params': [], 'method_name': 'getMgmtScript', 'method_docs': '[ HTTP: GET /mgmtscript/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'mgmtscript_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'mgmtscript_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'mgmtscript/%(id)s', 'method_kind': 'GET'}

    @download
    def searchMgmtScripts(self,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          qterm=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /mgmtscript/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "mgmtscript/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchMgmtScripts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchMgmtScripts', 'method_docs': '[ HTTP: GET /mgmtscript/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'mgmtscript/search', 'method_kind': 'GET'}

    @download
    def getMgmtScriptsXML(self,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /mgmtscript ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "mgmtscript"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMgmtScriptsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getMgmtScriptsXML', 'method_docs': '[ HTTP: GET /mgmtscript ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'mgmtscript', 'method_kind': 'GET'}

class propertydefinition(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getType(self,
                propertydefinition_id=None,
                **kwargs):
        """
        [ HTTP: GET /propertydefinition/{id} ]

        @param propertydefinition_id: propertydefinition_id
        @type propertydefinition_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertydefinition/%(id)s"
        path_params = {"id": propertydefinition_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getType.context = {'query_params': [], 'method_name': 'getType', 'method_docs': '[ HTTP: GET /propertydefinition/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertydefinition_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertydefinition_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertydefinition/%(id)s', 'method_kind': 'GET'}

class credential(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getCredential2_1(self,
                         credential_id,
                         decrypt_field=None,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /credential/{id}/decrypt/{field} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param decrypt_field: decrypt_field
        @type decrypt_field: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/decrypt/%(field)s"
        path_params = {"id": credential_id,
                       "field": decrypt_field}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCredential2_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCredential2_1', 'method_docs': '[ HTTP: GET /credential/{id}/decrypt/{field} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'credential_id'}, {'name': 'field', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'decrypt_field'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'credential_id'}, {'name': 'field', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'decrypt_field'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'credential/%(id)s/decrypt/%(field)s', 'method_kind': 'GET'}

    @download
    def getCredential(self,
                      credential_id=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /credential/{id} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s"
        path_params = {"id": credential_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCredential.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCredential', 'method_docs': '[ HTTP: GET /credential/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'credential_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'credential_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'credential/%(id)s', 'method_kind': 'GET'}

    @download
    def updateCredential(self,
                         credential_id,
                         encrypt_fieldname=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /credential/{id}/encrypt/{fieldname} ]

        @param credential_id: credential_id
        @type credential_id: str
        @param encrypt_fieldname: encrypt_fieldname
        @type encrypt_fieldname: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/encrypt/%(fieldname)s"
        path_params = {"id": credential_id,
                       "fieldname": encrypt_fieldname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'text/plain'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCredential.context = {'query_params': [], 'method_name': 'updateCredential', 'method_docs': '[ HTTP: PUT /credential/{id}/encrypt/{fieldname} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'credential_id'}, {'name': 'fieldname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'encrypt_fieldname'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'credential_id'}, {'name': 'fieldname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'encrypt_fieldname'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'text/plain'}, 'form_params': [], 'method_path': 'credential/%(id)s/encrypt/%(fieldname)s', 'method_kind': 'PUT'}

    @download
    def searchCredentials(self,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /credential/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCredentials.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCredentials', 'method_docs': '[ HTTP: GET /credential/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'credential/search', 'method_kind': 'GET'}

    @download
    def getCredential2_2(self,
                         credential_id,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /credential/{id}/decrypt ]

        @param credential_id: credential_id
        @type credential_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "credential/%(id)s/decrypt"
        path_params = {"id": credential_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCredential2_2.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCredential2_2', 'method_docs': '[ HTTP: GET /credential/{id}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'credential_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'credential_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'credential/%(id)s/decrypt', 'method_kind': 'GET'}

class user(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchUsers(self,
                    fields=None,
                    filterGroup=None,
                    limit=None,
                    offset=None,
                    orderBy=None,
                    usage=None,
                    **kwargs):
        """
        [ HTTP: GET /user/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchUsers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchUsers', 'method_docs': '[ HTTP: GET /user/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/search', 'method_kind': 'GET'}

    @download
    def updateUser(self,
                   user_id=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateUser.context = {'query_params': [], 'method_name': 'updateUser', 'method_docs': '[ HTTP: PUT /user/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'user/%(id)s', 'method_kind': 'PUT'}

    @download
    def getUser(self,
                user_id=None,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUser.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getUser', 'method_docs': '[ HTTP: GET /user/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/%(id)s', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /user/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /user/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/export', 'method_kind': 'GET'}

    @download
    def createToken(self,
                    authtoken_username=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /user/authtoken/{username} ]

        @param authtoken_username: authtoken_username
        @type authtoken_username: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/authtoken/%(username)s"
        path_params = {"username": authtoken_username}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createToken.context = {'query_params': [], 'method_name': 'createToken', 'method_docs': '[ HTTP: POST /user/authtoken/{username} ]', 'result': 'result', 'method_params': [{'name': 'username', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'authtoken_username'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'username', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'authtoken_username'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/authtoken/%(username)s', 'method_kind': 'POST'}

    @download
    def deleteUser(self,
                   user_id=None,
                   **kwargs):
        """
        [ HTTP: DELETE /user/{id} ]

        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteUser.context = {'query_params': [], 'method_name': 'deleteUser', 'method_docs': '[ HTTP: DELETE /user/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/%(id)s', 'method_kind': 'DELETE'}

    @download
    def deleteToken(self,
                    authtoken_token=None,
                    **kwargs):
        """
        [ HTTP: DELETE /user/authtoken/{token} ]

        @param authtoken_token: authtoken_token
        @type authtoken_token: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/authtoken/%(token)s"
        path_params = {"token": authtoken_token}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteToken.context = {'query_params': [], 'method_name': 'deleteToken', 'method_docs': '[ HTTP: DELETE /user/authtoken/{token} ]', 'result': 'result', 'method_params': [{'name': 'token', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'authtoken_token'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'token', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'authtoken_token'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/authtoken/%(token)s', 'method_kind': 'DELETE'}

    @download
    def importAction_1(self,
                       create=None,
                       update=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /user/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /user/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'user/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     user_id,
                     **kwargs):
        """
        [ HTTP: GET /user/{id}/export ]

        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/%(id)s/export"
        path_params = {"id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /user/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/%(id)s/export', 'method_kind': 'GET'}

    @download
    def addUser(self,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /user ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addUser.context = {'query_params': [], 'method_name': 'addUser', 'method_docs': '[ HTTP: POST /user ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'user', 'method_kind': 'POST'}

    @download
    def getUsersXML(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /user ]

        @param self: self
        @type self: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"self": self,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUsersXML.context = {'query_params': [{'name': 'self', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'self'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getUsersXML', 'method_docs': '[ HTTP: GET /user ]', 'result': 'result', 'method_params': [{'name': 'self', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'self'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       create=None,
                       update=None,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /user/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /user/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'user/import', 'method_kind': 'PUT'}

class backup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createDatabaseBackup(self,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /backup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "backup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDatabaseBackup.context = {'query_params': [], 'method_name': 'createDatabaseBackup', 'method_docs': '[ HTTP: POST /backup ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'backup', 'method_kind': 'POST'}

class resources(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getCategoriesXML(self,
                         **kwargs):
        """
        [ HTTP: GET /resources ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "resources"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCategoriesXML.context = {'query_params': [], 'method_name': 'getCategoriesXML', 'method_docs': '[ HTTP: GET /resources ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'resources', 'method_kind': 'GET'}

class configuration_artifacttype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def importArtifactType(self,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /configuration/artifacttype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importArtifactType.context = {'query_params': [], 'method_name': 'importArtifactType', 'method_docs': '[ HTTP: PUT /configuration/artifacttype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifacttype/import', 'method_kind': 'PUT'}

    @download
    def exportAllArtifactTypes(self,
                               **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllArtifactTypes.context = {'query_params': [], 'method_name': 'exportAllArtifactTypes', 'method_docs': '[ HTTP: GET /configuration/artifacttype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifacttype/export', 'method_kind': 'GET'}

    @download
    def getArtifactType(self,
                        artifacttype_id=None,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifactType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifactType', 'method_docs': '[ HTTP: GET /configuration/artifacttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifacttype/%(id)s', 'method_kind': 'GET'}

    @download
    def importArtifactTypes(self,
                            data=None,
                            files=None,
                            **kwargs):
        """
        [ HTTP: PUT /configuration/artifacttype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importArtifactTypes.context = {'query_params': [], 'method_name': 'importArtifactTypes', 'method_docs': '[ HTTP: PUT /configuration/artifacttype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'configuration/artifacttype/import', 'method_kind': 'PUT'}

    @download
    def exportArtifactType(self,
                           artifacttype_id,
                           recursive=None,
                           **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype/{id}/export ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype/%(id)s/export"
        path_params = {"id": artifacttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportArtifactType.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportArtifactType', 'method_docs': '[ HTTP: GET /configuration/artifacttype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifacttype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifacttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifacttype/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getArtifactTypes(self,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /configuration/artifacttype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifacttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifactTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifactTypes', 'method_docs': '[ HTTP: GET /configuration/artifacttype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifacttype', 'method_kind': 'GET'}

class auth(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateAuthenticationOrder(self,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /auth/saveproviders ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/saveproviders"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAuthenticationOrder.context = {'query_params': [], 'method_name': 'updateAuthenticationOrder', 'method_docs': '[ HTTP: POST /auth/saveproviders ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'auth/saveproviders', 'method_kind': 'POST'}

    @download
    def searchAuthentication(self,
                             fields=None,
                             filterGroup=None,
                             limit=None,
                             offset=None,
                             orderBy=None,
                             usage=None,
                             **kwargs):
        """
        [ HTTP: GET /auth/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchAuthentication.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchAuthentication', 'method_docs': '[ HTTP: GET /auth/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'auth/search', 'method_kind': 'GET'}

    @download
    def deleteAuthentication(self,
                             auth_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /auth/{id} ]

        @param auth_id: auth_id
        @type auth_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/%(id)s"
        path_params = {"id": auth_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAuthentication.context = {'query_params': [], 'method_name': 'deleteAuthentication', 'method_docs': '[ HTTP: DELETE /auth/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'auth_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'auth_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'auth/%(id)s', 'method_kind': 'DELETE'}

    @download
    def createAuthentication(self,
                             id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /auth ]

        @param id: id
        @type id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth"
        path_params = {"id": id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAuthentication.context = {'query_params': [], 'method_name': 'createAuthentication', 'method_docs': '[ HTTP: POST /auth ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'auth', 'method_kind': 'POST'}

    @download
    def updateAuthentication(self,
                             auth_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /auth/{id} ]

        @param auth_id: auth_id
        @type auth_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/%(id)s"
        path_params = {"id": auth_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAuthentication.context = {'query_params': [], 'method_name': 'updateAuthentication', 'method_docs': '[ HTTP: PUT /auth/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'auth_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'auth_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'auth/%(id)s', 'method_kind': 'PUT'}

    @download
    def getAuthentications(self,
                           id,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /auth ]

        @param id: id
        @type id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth"
        path_params = {"id": id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAuthentications.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAuthentications', 'method_docs': '[ HTTP: GET /auth ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'auth', 'method_kind': 'GET'}

    @download
    def getAuthentication(self,
                          auth_id=None,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /auth/{id} ]

        @param auth_id: auth_id
        @type auth_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "auth/%(id)s"
        path_params = {"id": auth_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAuthentication.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAuthentication', 'method_docs': '[ HTTP: GET /auth/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'auth_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'auth_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'auth/%(id)s', 'method_kind': 'GET'}

class user_task(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def approveUserTask(self,
                        task_id,
                        comment=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /user/task/{id}/approve ]

        @param task_id: task_id
        @type task_id: str
        @param comment: comment
        @type comment: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/task/%(id)s/approve"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"comment": comment}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approveUserTask.context = {'query_params': [{'name': 'comment', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'comment'}], 'method_name': 'approveUserTask', 'method_docs': '[ HTTP: POST /user/task/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'comment', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'comment'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/task/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def getUserTask(self,
                    task_id=None,
                    **kwargs):
        """
        [ HTTP: GET /user/task/{id} ]

        @param task_id: task_id
        @type task_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/task/%(id)s"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUserTask.context = {'query_params': [], 'method_name': 'getUserTask', 'method_docs': '[ HTTP: GET /user/task/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'task_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/task/%(id)s', 'method_kind': 'GET'}

    @download
    def getUserTasks(self,
                     **kwargs):
        """
        [ HTTP: GET /user/task ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/task"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUserTasks.context = {'query_params': [], 'method_name': 'getUserTasks', 'method_docs': '[ HTTP: GET /user/task ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/task', 'method_kind': 'GET'}

    @download
    def rejectUserTask(self,
                       task_id,
                       comment=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /user/task/{id}/reject ]

        @param task_id: task_id
        @type task_id: str
        @param comment: comment
        @type comment: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "user/task/%(id)s/reject"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"comment": comment}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejectUserTask.context = {'query_params': [{'name': 'comment', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'comment'}], 'method_name': 'rejectUserTask', 'method_docs': '[ HTTP: POST /user/task/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'comment', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'comment'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'user/task/%(id)s/reject', 'method_kind': 'POST'}

class ldapgroup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getMappings(self,
                    **kwargs):
        """
        [ HTTP: GET /ldapgroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMappings.context = {'query_params': [], 'method_name': 'getMappings', 'method_docs': '[ HTTP: GET /ldapgroup ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'ldapgroup', 'method_kind': 'GET'}

    @download
    def getMapping(self,
                   ldapgroup_id=None,
                   **kwargs):
        """
        [ HTTP: GET /ldapgroup/{id} ]

        @param ldapgroup_id: ldapgroup_id
        @type ldapgroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(id)s"
        path_params = {"id": ldapgroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMapping.context = {'query_params': [], 'method_name': 'getMapping', 'method_docs': '[ HTTP: GET /ldapgroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'ldapgroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'ldapgroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'ldapgroup/%(id)s', 'method_kind': 'GET'}

    @download
    def createMapping_1(self,
                        ldapgroup_ldapGpName,
                        agilityGpName=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /ldapgroup/{ldapGpName}/{agilityGpName} ]

        @param ldapgroup_ldapGpName: ldapgroup_ldapGpName
        @type ldapgroup_ldapGpName: str
        @param agilityGpName: agilityGpName
        @type agilityGpName: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(ldapGpName)s/%(agilityGpName)s"
        path_params = {"ldapGpName": ldapgroup_ldapGpName,
                       "agilityGpName": agilityGpName}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMapping_1.context = {'query_params': [], 'method_name': 'createMapping_1', 'method_docs': '[ HTTP: POST /ldapgroup/{ldapGpName}/{agilityGpName} ]', 'result': 'result', 'method_params': [{'name': 'ldapGpName', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'ldapgroup_ldapGpName'}, {'name': 'agilityGpName', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'agilityGpName'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'ldapGpName', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'ldapgroup_ldapGpName'}, {'name': 'agilityGpName', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'agilityGpName'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'ldapgroup/%(ldapGpName)s/%(agilityGpName)s', 'method_kind': 'POST'}

    @download
    def updateMapping(self,
                      ldapgroup_id,
                      newAgilityGpName=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /ldapgroup/{id}/{newAgilityGpName} ]

        @param ldapgroup_id: ldapgroup_id
        @type ldapgroup_id: str
        @param newAgilityGpName: newAgilityGpName
        @type newAgilityGpName: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(id)s/%(newAgilityGpName)s"
        path_params = {"id": ldapgroup_id,
                       "newAgilityGpName": newAgilityGpName}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateMapping.context = {'query_params': [], 'method_name': 'updateMapping', 'method_docs': '[ HTTP: PUT /ldapgroup/{id}/{newAgilityGpName} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'ldapgroup_id'}, {'name': 'newAgilityGpName', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'newAgilityGpName'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'ldapgroup_id'}, {'name': 'newAgilityGpName', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'newAgilityGpName'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'ldapgroup/%(id)s/%(newAgilityGpName)s', 'method_kind': 'PUT'}

    @download
    def deleteMapping(self,
                      ldapgroup_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /ldapgroup/{id} ]

        @param ldapgroup_id: ldapgroup_id
        @type ldapgroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/%(id)s"
        path_params = {"id": ldapgroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteMapping.context = {'query_params': [], 'method_name': 'deleteMapping', 'method_docs': '[ HTTP: DELETE /ldapgroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'ldapgroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'ldapgroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'ldapgroup/%(id)s', 'method_kind': 'DELETE'}

    @download
    def setMappings(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /ldapgroup/set ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup/set"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setMappings.context = {'query_params': [], 'method_name': 'setMappings', 'method_docs': '[ HTTP: POST /ldapgroup/set ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'ldapgroup/set', 'method_kind': 'POST'}

    @download
    def createMapping_2(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /ldapgroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "ldapgroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMapping_2.context = {'query_params': [], 'method_name': 'createMapping_2', 'method_docs': '[ HTTP: POST /ldapgroup ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'ldapgroup', 'method_kind': 'POST'}

class solution(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteSolution(self,
                       solution_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /solution/{id} ]

        @param solution_id: solution_id
        @type solution_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSolution.context = {'query_params': [], 'method_name': 'deleteSolution', 'method_docs': '[ HTTP: DELETE /solution/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solution_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/%(id)s', 'method_kind': 'DELETE'}

    @download
    def createArtifact(self,
                       solution_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /solution/{id}/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/artifact"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createArtifact.context = {'query_params': [], 'method_name': 'createArtifact', 'method_docs': '[ HTTP: POST /solution/{id}/artifact ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s/artifact', 'method_kind': 'POST'}

    @download
    def createDeployment(self,
                         solution_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /solution/{id}/deployment ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/deployment"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDeployment.context = {'query_params': [], 'method_name': 'createDeployment', 'method_docs': '[ HTTP: POST /solution/{id}/deployment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s/deployment', 'method_kind': 'POST'}

    @download
    def createArtifactAnyOrder(self,
                               solution_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /solution/{id}/anyorder/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/anyorder/artifact"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createArtifactAnyOrder.context = {'query_params': [], 'method_name': 'createArtifactAnyOrder', 'method_docs': '[ HTTP: POST /solution/{id}/anyorder/artifact ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s/anyorder/artifact', 'method_kind': 'POST'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /solution/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /solution/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/export', 'method_kind': 'GET'}

    @download
    def getSolutions(self,
                     includeEnvironments=None,
                     orderDeployments=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /solution ]

        @param includeEnvironments: includeEnvironments
        @type includeEnvironments: str
        @param orderDeployments: orderDeployments
        @type orderDeployments: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"includeEnvironments": includeEnvironments,
                        "orderDeployments": orderDeployments,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSolutions.context = {'query_params': [{'name': 'includeEnvironments', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeEnvironments'}, {'name': 'orderDeployments', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderDeployments'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSolutions', 'method_docs': '[ HTTP: GET /solution ]', 'result': 'result', 'method_params': [{'name': 'includeEnvironments', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeEnvironments'}, {'name': 'orderDeployments', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderDeployments'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution', 'method_kind': 'GET'}

    @download
    def getDeployments(self,
                       solution_id,
                       ready=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /solution/{id}/deployment ]

        @param solution_id: solution_id
        @type solution_id: str
        @param ready: ready
        @type ready: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/deployment"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"ready": ready,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployments.context = {'query_params': [{'name': 'ready', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ready'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployments', 'method_docs': '[ HTTP: GET /solution/{id}/deployment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'ready', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ready'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/%(id)s/deployment', 'method_kind': 'GET'}

    @download
    def getArtifacts(self,
                     solution_id,
                     version=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /solution/{id}/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param version: version
        @type version: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/artifact"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"version": version,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifacts.context = {'query_params': [{'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifacts', 'method_docs': '[ HTTP: GET /solution/{id}/artifact ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/%(id)s/artifact', 'method_kind': 'GET'}

    @download
    def updateSolution(self,
                       solution_id=None,
                       fields=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /solution/{id} ]

        @param solution_id: solution_id
        @type solution_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateSolution.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateSolution', 'method_docs': '[ HTTP: PUT /solution/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solution_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchSolutions(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /solution/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchSolutions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchSolutions', 'method_docs': '[ HTTP: GET /solution/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/search', 'method_kind': 'GET'}

    @download
    def createArtifactFixedOrder(self,
                                 solution_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /solution/{id}/fixedorder/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/fixedorder/artifact"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createArtifactFixedOrder.context = {'query_params': [], 'method_name': 'createArtifactFixedOrder', 'method_docs': '[ HTTP: POST /solution/{id}/fixedorder/artifact ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s/fixedorder/artifact', 'method_kind': 'POST'}

    @download
    def searchArtifacts(self,
                        solution_id,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /solution/{id}/artifact/search ]

        @param solution_id: solution_id
        @type solution_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/artifact/search"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchArtifacts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchArtifacts', 'method_docs': '[ HTTP: GET /solution/{id}/artifact/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/%(id)s/artifact/search', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     solution_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /solution/{id}/export ]

        @param solution_id: solution_id
        @type solution_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/export"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /solution/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/%(id)s/export', 'method_kind': 'GET'}

    @download
    def updateArtifactOrder(self,
                            solution_id,
                            fields=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /solution/{id}/saveorder/artifact ]

        @param solution_id: solution_id
        @type solution_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/saveorder/artifact"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateArtifactOrder.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateArtifactOrder', 'method_docs': '[ HTTP: PUT /solution/{id}/saveorder/artifact ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s/saveorder/artifact', 'method_kind': 'PUT'}

    @download
    def createDeploymentVersionedArtifacts(self,
                                           solution_id,
                                           data=None,
                                           **kwargs):
        """
        [ HTTP: POST /solution/{id}/deployment/version ]

        @param solution_id: solution_id
        @type solution_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s/deployment/version"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDeploymentVersionedArtifacts.context = {'query_params': [], 'method_name': 'createDeploymentVersionedArtifacts', 'method_docs': '[ HTTP: POST /solution/{id}/deployment/version ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'solution/%(id)s/deployment/version', 'method_kind': 'POST'}

    @download
    def getSolution(self,
                    solution_id=None,
                    orderDeployments=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /solution/{id} ]

        @param solution_id: solution_id
        @type solution_id: str
        @param orderDeployments: orderDeployments
        @type orderDeployments: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "solution/%(id)s"
        path_params = {"id": solution_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"orderDeployments": orderDeployments,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSolution.context = {'query_params': [{'name': 'orderDeployments', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderDeployments'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSolution', 'method_docs': '[ HTTP: GET /solution/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solution_id'}, {'name': 'orderDeployments', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderDeployments'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'solution_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'solution/%(id)s', 'method_kind': 'GET'}

class template(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def releaseTemplate(self,
                        template_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /template/{id}/release ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/release"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseTemplate.context = {'query_params': [], 'method_name': 'releaseTemplate', 'method_docs': '[ HTTP: POST /template/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/release', 'method_kind': 'POST'}

    @download
    def getscaleDownPolicy(self,
                           template_id,
                           **kwargs):
        """
        [ HTTP: GET /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getscaleDownPolicy.context = {'query_params': [], 'method_name': 'getscaleDownPolicy', 'method_docs': '[ HTTP: GET /template/{id}/scaleDown ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/scaleDown', 'method_kind': 'GET'}

    @download
    def deleteConfigurationResource(self,
                                    template_id,
                                    configurationresource_crid=None,
                                    **kwargs):
        """
        [ HTTP: DELETE /template/{id}/configurationresource/{crid} ]

        @param template_id: template_id
        @type template_id: str
        @param configurationresource_crid: configurationresource_crid
        @type configurationresource_crid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/configurationresource/%(crid)s"
        path_params = {"id": template_id,
                       "crid": configurationresource_crid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteConfigurationResource.context = {'query_params': [], 'method_name': 'deleteConfigurationResource', 'method_docs': '[ HTTP: DELETE /template/{id}/configurationresource/{crid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'crid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'configurationresource_crid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'crid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'configurationresource_crid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/configurationresource/%(crid)s', 'method_kind': 'DELETE'}

    @download
    def updateAlias_2(self,
                      template_id,
                      alias_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /template/{id}/alias/{alias_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/alias/%(alias_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias_2.context = {'query_params': [], 'method_name': 'updateAlias_2', 'method_docs': '[ HTTP: POST /template/{id}/alias/{alias_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/alias/%(alias_id: [0-9]+)s', 'method_kind': 'POST'}

    @download
    def getContainerDeploymentPlan(self,
                                   deploymentplan_containerId=None,
                                   policyIds=None,
                                   logLevel=None,
                                   **kwargs):
        """
        [ HTTP: GET /template/deploymentplan/{containerId} ]

        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/deploymentplan/%(containerId)s"
        path_params = {"containerId": deploymentplan_containerId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainerDeploymentPlan.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'getContainerDeploymentPlan', 'method_docs': '[ HTTP: GET /template/deploymentplan/{containerId} ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploymentplan_containerId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deploymentplan_containerId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/deploymentplan/%(containerId)s', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     template_id,
                     recursive=None,
                     exportOpts=None,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/export ]

        @param template_id: template_id
        @type template_id: str
        @param recursive: recursive
        @type recursive: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/export"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive,
                        "exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /template/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/export', 'method_kind': 'GET'}

    @download
    def deletescaleDownPolicy(self,
                              template_id,
                              **kwargs):
        """
        [ HTTP: DELETE /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletescaleDownPolicy.context = {'query_params': [], 'method_name': 'deletescaleDownPolicy', 'method_docs': '[ HTTP: DELETE /template/{id}/scaleDown ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/scaleDown', 'method_kind': 'DELETE'}

    @download
    def deleteScaleUpPolicy(self,
                            template_id,
                            **kwargs):
        """
        [ HTTP: DELETE /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteScaleUpPolicy.context = {'query_params': [], 'method_name': 'deleteScaleUpPolicy', 'method_docs': '[ HTTP: DELETE /template/{id}/scaleUp ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/scaleUp', 'method_kind': 'DELETE'}

    @download
    def deleteVolume(self,
                     template_id,
                     volume_volid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /template/{id}/volume/{volid} ]

        @param template_id: template_id
        @type template_id: str
        @param volume_volid: volume_volid
        @type volume_volid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume/%(volid)s"
        path_params = {"id": template_id,
                       "volid": volume_volid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVolume.context = {'query_params': [], 'method_name': 'deleteVolume', 'method_docs': '[ HTTP: DELETE /template/{id}/volume/{volid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'volid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volume_volid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'volid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volume_volid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/volume/%(volid)s', 'method_kind': 'DELETE'}

    @download
    def updateScaleUpPolicy(self,
                            template_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: PUT /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateScaleUpPolicy.context = {'query_params': [], 'method_name': 'updateScaleUpPolicy', 'method_docs': '[ HTTP: PUT /template/{id}/scaleUp ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'template/%(id)s/scaleUp', 'method_kind': 'PUT'}

    @download
    def rebootTemplate(self,
                       template_id,
                       reconfigure=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /template/{id}/restart ]

        @param template_id: template_id
        @type template_id: str
        @param reconfigure: reconfigure
        @type reconfigure: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/restart"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"reconfigure": reconfigure}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootTemplate.context = {'query_params': [{'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}], 'method_name': 'rebootTemplate', 'method_docs': '[ HTTP: POST /template/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def createMultiVariable(self,
                            template_templ_id,
                            variable_vname=None,
                            fields=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /template/{templ_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param template_templ_id: template_templ_id
        @type template_templ_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(templ_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"templ_id": template_templ_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMultiVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createMultiVariable', 'method_docs': '[ HTTP: POST /template/{templ_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'templ_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_templ_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'templ_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_templ_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(templ_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getVariables(self,
                     template_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/variable ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariables', 'method_docs': '[ HTTP: GET /template/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def hotswapInstances(self,
                         template_id,
                         **kwargs):
        """
        [ HTTP: GET /template/{id}/hotswap ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/hotswap"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    hotswapInstances.context = {'query_params': [], 'method_name': 'hotswapInstances', 'method_docs': '[ HTTP: GET /template/{id}/hotswap ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/hotswap', 'method_kind': 'GET'}

    @download
    def getTemplates(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /template ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplates.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTemplates', 'method_docs': '[ HTTP: GET /template ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template', 'method_kind': 'GET'}

    @download
    def getDeploymentPlan_2(self,
                            deploymentplan_containerId,
                            stackId=None,
                            policyIds=None,
                            logLevel=None,
                            **kwargs):
        """
        [ HTTP: GET /template/deploymentplan/{containerId}/{stackId} ]

        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param stackId: stackId
        @type stackId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/deploymentplan/%(containerId)s/%(stackId)s"
        path_params = {"containerId": deploymentplan_containerId,
                       "stackId": stackId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeploymentPlan_2.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'getDeploymentPlan_2', 'method_docs': '[ HTTP: GET /template/deploymentplan/{containerId}/{stackId} ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'deploymentplan_containerId'}, {'name': 'stackId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stackId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'deploymentplan_containerId'}, {'name': 'stackId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stackId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/deploymentplan/%(containerId)s/%(stackId)s', 'method_kind': 'GET'}

    @download
    def searchPolicyAssignments(self,
                                template_id,
                                containerId=None,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /template/{id}/policyassignment/search ]

        @param template_id: template_id
        @type template_id: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policyassignment/search"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /template/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def getVolumes(self,
                   template_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /template/{id}/volume ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolumes', 'method_docs': '[ HTTP: GET /template/{id}/volume ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/volume', 'method_kind': 'GET'}

    @download
    def removePackage(self,
                      template_id,
                      packageid=None,
                      **kwargs):
        """
        [ HTTP: DELETE /template/{id}/package/{packageid} ]

        @param template_id: template_id
        @type template_id: str
        @param packageid: packageid
        @type packageid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package/%(packageid)s"
        path_params = {"id": template_id,
                       "packageid": packageid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePackage.context = {'query_params': [], 'method_name': 'removePackage', 'method_docs': '[ HTTP: DELETE /template/{id}/package/{packageid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'packageid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'packageid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'packageid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'packageid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/package/%(packageid)s', 'method_kind': 'DELETE'}

    @download
    def createscaleDownPolicy(self,
                              template_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createscaleDownPolicy.context = {'query_params': [], 'method_name': 'createscaleDownPolicy', 'method_docs': '[ HTTP: POST /template/{id}/scaleDown ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'template/%(id)s/scaleDown', 'method_kind': 'POST'}

    @download
    def stopTemplate(self,
                     template_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /template/{id}/stop ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/stop"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopTemplate.context = {'query_params': [], 'method_name': 'stopTemplate', 'method_docs': '[ HTTP: POST /template/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def updateTemplate(self,
                       template_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateTemplate.context = {'query_params': [], 'method_name': 'updateTemplate', 'method_docs': '[ HTTP: PUT /template/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'template/%(id)s', 'method_kind': 'PUT'}

    @download
    def getVariableByName(self,
                          template_templ_id,
                          variable_vname=None,
                          **kwargs):
        """
        [ HTTP: GET /template/{templ_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param template_templ_id: template_templ_id
        @type template_templ_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(templ_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"templ_id": template_templ_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableByName.context = {'query_params': [], 'method_name': 'getVariableByName', 'method_docs': '[ HTTP: GET /template/{templ_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'templ_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_templ_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'templ_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_templ_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(templ_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'GET'}

    @download
    def updateAlias_1(self,
                      template_id,
                      alias_name=None,
                      fields=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /template/{id}/alias/{name: [a-zA-Z0-9_\-]+} ]

        @param template_id: template_id
        @type template_id: str
        @param alias_name: alias_name
        @type alias_name: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/alias/%(name: [a-zA-Z0-9_\-]+)s"
        path_params = {"id": template_id,
                       "name": alias_name}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateAlias_1', 'method_docs': '[ HTTP: POST /template/{id}/alias/{name: [a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'name', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'alias_name'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'name', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'alias_name'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/alias/%(name: [a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getPackages(self,
                    template_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/package ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPackages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPackages', 'method_docs': '[ HTTP: GET /template/{id}/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/package', 'method_kind': 'GET'}

    @download
    def getPolicies(self,
                    template_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/policy ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /template/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def addPackage(self,
                   template_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /template/{id}/package ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addPackage.context = {'query_params': [], 'method_name': 'addPackage', 'method_docs': '[ HTTP: POST /template/{id}/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'template/%(id)s/package', 'method_kind': 'POST'}

    @download
    def decryptVariable(self,
                        template_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+}/decrypt ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s/decrypt"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'method_name': 'decryptVariable', 'method_docs': '[ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s/decrypt', 'method_kind': 'GET'}

    @download
    def getTemplate(self,
                    template_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplate.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTemplate', 'method_docs': '[ HTTP: GET /template/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s', 'method_kind': 'GET'}

    @download
    def searchTemplates(self,
                        containerId=None,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        qterm=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /template/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTemplates.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchTemplates', 'method_docs': '[ HTTP: GET /template/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/search', 'method_kind': 'GET'}

    @download
    def deleteTemplate(self,
                       template_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /template/{id} ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteTemplate.context = {'query_params': [], 'method_name': 'deleteTemplate', 'method_docs': '[ HTTP: DELETE /template/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'template_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s', 'method_kind': 'DELETE'}

    @download
    def startTemplate(self,
                      template_id,
                      reconfigure=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /template/{id}/start ]

        @param template_id: template_id
        @type template_id: str
        @param reconfigure: reconfigure
        @type reconfigure: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/start"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"reconfigure": reconfigure}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startTemplate.context = {'query_params': [{'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}], 'method_name': 'startTemplate', 'method_docs': '[ HTTP: POST /template/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/start', 'method_kind': 'POST'}

    @download
    def getVariable(self,
                    template_id,
                    variable_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariable', 'method_docs': '[ HTTP: GET /template/{id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def attachPolicy(self,
                     template_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /template/{id}/policy/{policyid} ]

        @param template_id: template_id
        @type template_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy/%(policyid)s"
        path_params = {"id": template_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /template/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def getInstances(self,
                     template_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /template/{id}/compute ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/compute"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getInstances', 'method_docs': '[ HTTP: GET /template/{id}/compute ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/compute', 'method_kind': 'GET'}

    @download
    def waitForInstances(self,
                         template_id,
                         fields=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /template/{id}/compute/wait ]

        @param template_id: template_id
        @type template_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/compute/wait"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    waitForInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'waitForInstances', 'method_docs': '[ HTTP: POST /template/{id}/compute/wait ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/compute/wait', 'method_kind': 'POST'}

    @download
    def deleteVariable(self,
                       template_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /template/{id}/variable/{variable_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /template/{id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def getDeploymentPlan_1(self,
                            templateId,
                            deploymentplan_containerId,
                            stackId=None,
                            policyIds=None,
                            logLevel=None,
                            **kwargs):
        """
        [ HTTP: GET /template/{templateId}/deploymentplan/{containerId}/{stackId} ]

        @param templateId: templateId
        @type templateId: str
        @param deploymentplan_containerId: deploymentplan_containerId
        @type deploymentplan_containerId: str
        @param stackId: stackId
        @type stackId: str
        @param policyIds: policyIds
        @type policyIds: str
        @param logLevel: logLevel
        @type logLevel: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(templateId)s/deploymentplan/%(containerId)s/%(stackId)s"
        path_params = {"templateId": templateId,
                       "containerId": deploymentplan_containerId,
                       "stackId": stackId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"policyIds": policyIds,
                        "logLevel": logLevel}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeploymentPlan_1.context = {'query_params': [{'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}], 'method_name': 'getDeploymentPlan_1', 'method_docs': '[ HTTP: GET /template/{templateId}/deploymentplan/{containerId}/{stackId} ]', 'result': 'result', 'method_params': [{'name': 'templateId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'templateId'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'deploymentplan_containerId'}, {'name': 'stackId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stackId'}, {'name': 'policyIds', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'policyIds'}, {'name': 'logLevel', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'logLevel'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'templateId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'templateId'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'deploymentplan_containerId'}, {'name': 'stackId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'stackId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(templateId)s/deploymentplan/%(containerId)s/%(stackId)s', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /template/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /template/export ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/export', 'method_kind': 'GET'}

    @download
    def removePolicy(self,
                     template_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /template/{id}/policy/{policyid} ]

        @param template_id: template_id
        @type template_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/policy/%(policyid)s"
        path_params = {"id": template_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /template/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def addVolume(self,
                  template_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /template/{id}/volume ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/volume"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addVolume.context = {'query_params': [], 'method_name': 'addVolume', 'method_docs': '[ HTTP: POST /template/{id}/volume ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'template/%(id)s/volume', 'method_kind': 'POST'}

    @download
    def createScaleUpPolicy(self,
                            template_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createScaleUpPolicy.context = {'query_params': [], 'method_name': 'createScaleUpPolicy', 'method_docs': '[ HTTP: POST /template/{id}/scaleUp ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'template/%(id)s/scaleUp', 'method_kind': 'POST'}

    @download
    def getScaleUpPolicy(self,
                         template_id,
                         **kwargs):
        """
        [ HTTP: GET /template/{id}/scaleUp ]

        @param template_id: template_id
        @type template_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleUp"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScaleUpPolicy.context = {'query_params': [], 'method_name': 'getScaleUpPolicy', 'method_docs': '[ HTTP: GET /template/{id}/scaleUp ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/scaleUp', 'method_kind': 'GET'}

    @download
    def attachPackage(self,
                      template_id,
                      package_pkgid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /template/{id}/package/{pkgid} ]

        @param template_id: template_id
        @type template_id: str
        @param package_pkgid: package_pkgid
        @type package_pkgid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/package/%(pkgid)s"
        path_params = {"id": template_id,
                       "pkgid": package_pkgid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPackage.context = {'query_params': [], 'method_name': 'attachPackage', 'method_docs': '[ HTTP: PUT /template/{id}/package/{pkgid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'pkgid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_pkgid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'pkgid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'package_pkgid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'template/%(id)s/package/%(pkgid)s', 'method_kind': 'PUT'}

    @download
    def createVariable(self,
                       template_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /template/{id}/variable ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /template/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'template/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def updatescaleDownPolicy(self,
                              template_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /template/{id}/scaleDown ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/scaleDown"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatescaleDownPolicy.context = {'query_params': [], 'method_name': 'updatescaleDownPolicy', 'method_docs': '[ HTTP: PUT /template/{id}/scaleDown ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'template/%(id)s/scaleDown', 'method_kind': 'PUT'}

    @download
    def addConfigurationResource(self,
                                 template_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /template/{id}/configurationresource ]

        @param template_id: template_id
        @type template_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/configurationresource"
        path_params = {"id": template_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addConfigurationResource.context = {'query_params': [], 'method_name': 'addConfigurationResource', 'method_docs': '[ HTTP: POST /template/{id}/configurationresource ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'template/%(id)s/configurationresource', 'method_kind': 'POST'}

    @download
    def updateVariable(self,
                       template_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /template/{id}/variable/{variable_id: [0-9]+} ]

        @param template_id: template_id
        @type template_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "template/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": template_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /template/{id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'template_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'template/%(id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'PUT'}

class repository(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getRepositories_1(self,
                          repository_usage=None,
                          **kwargs):
        """
        [ HTTP: GET /repository/{usage: (templates)|(instances)|(storage)|(attachments)|(backups)} ]

        @param repository_usage: repository_usage
        @type repository_usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(usage: (templates)|(instances)|(storage)|(attachments)|(backups))s"
        path_params = {"usage": repository_usage}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositories_1.context = {'query_params': [], 'method_name': 'getRepositories_1', 'method_docs': '[ HTTP: GET /repository/{usage: (templates)|(instances)|(storage)|(attachments)|(backups)} ]', 'result': 'result', 'method_params': [{'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'repository_usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'repository_usage'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(usage: (templates)|(instances)|(storage)|(attachments)|(backups))s', 'method_kind': 'GET'}

    @download
    def updateRepository(self,
                         repository_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRepository.context = {'query_params': [], 'method_name': 'updateRepository', 'method_docs': '[ HTTP: PUT /repository/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'repository/%(id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /repository/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /repository/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /repository/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'repository/import', 'method_kind': 'PUT'}

    @download
    def deleteObject(self,
                     repository_id,
                     path=None,
                     **kwargs):
        """
        [ HTTP: DELETE /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteObject.context = {'query_params': [], 'method_name': 'deleteObject', 'method_docs': '[ HTTP: DELETE /repository/{id}/{path:.*} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id)s/%(path:.*)s', 'method_kind': 'DELETE'}

    @download
    def getListing(self,
                   repository_id,
                   path=None,
                   **kwargs):
        """
        [ HTTP: GET /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getListing.context = {'query_params': [], 'method_name': 'getListing', 'method_docs': '[ HTTP: GET /repository/{id}/{path:.*} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id)s/%(path:.*)s', 'method_kind': 'GET'}

    @download
    def putObject(self,
                  repository_id,
                  path=None,
                  Content_Length=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: PUT /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param Content_Length: Content_Length
        @type Content_Length: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"Content_Length": Content_Length}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/octet-stream'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    putObject.context = {'query_params': [{'name': 'Content_Length', 'defaultValue': None, 'kind': 'xs:long', 'required': False, 'alias': 'Content_Length'}], 'method_name': 'putObject', 'method_docs': '[ HTTP: PUT /repository/{id}/{path:.*} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}, {'name': 'Content_Length', 'defaultValue': None, 'kind': 'xs:long', 'required': False, 'alias': 'Content_Length'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/octet-stream'}, 'form_params': [], 'method_path': 'repository/%(id)s/%(path:.*)s', 'method_kind': 'PUT'}

    @download
    def getRepositories_2(self,
                          fields=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /repository ]

        @param fields: fields
        @type fields: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositories_2.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'getRepositories_2', 'method_docs': '[ HTTP: GET /repository ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository', 'method_kind': 'GET'}

    @download
    def updateRepositoryUsage(self,
                              repository_id=None,
                              usage=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param usage: usage
        @type usage: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRepositoryUsage.context = {'query_params': [{'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'updateRepositoryUsage', 'method_docs': '[ HTTP: PUT /repository/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def deleteRepository(self,
                         repository_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteRepository.context = {'query_params': [], 'method_name': 'deleteRepository', 'method_docs': '[ HTTP: DELETE /repository/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /repository/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'repository/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     repository_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /repository/{id}/export ]

        @param repository_id: repository_id
        @type repository_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/export"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /repository/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getRepository(self,
                      repository_id=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /repository/{id: [0-9]+} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id: [0-9]+)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepository.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRepository', 'method_docs': '[ HTTP: GET /repository/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def getObject(self,
                  repository_id,
                  path=None,
                  **kwargs):
        """
        [ HTTP: GET /repository/{id}/{path:.*} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param path: path
        @type path: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "repository/%(id)s/%(path:.*)s"
        path_params = {"id": repository_id,
                       "path": path}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getObject.context = {'query_params': [], 'method_name': 'getObject', 'method_docs': '[ HTTP: GET /repository/{id}/{path:.*} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'path', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'path'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'repository/%(id)s/%(path:.*)s', 'method_kind': 'GET'}

class storeproduct(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createProduct(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /storeproduct ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProduct.context = {'query_params': [], 'method_name': 'createProduct', 'method_docs': '[ HTTP: POST /storeproduct ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storeproduct', 'method_kind': 'POST'}

    @download
    def getProducts(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /storeproduct ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProducts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProducts', 'method_docs': '[ HTTP: GET /storeproduct ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproduct', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     storeproduct_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storeproduct/{id}/export ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s/export"
        path_params = {"id": storeproduct_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /storeproduct/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeproduct_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeproduct_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproduct/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storeproduct/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /storeproduct/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproduct/export', 'method_kind': 'GET'}

    @download
    def deleteProduct(self,
                      storeproduct_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /storeproduct/{id} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s"
        path_params = {"id": storeproduct_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteProduct.context = {'query_params': [], 'method_name': 'deleteProduct', 'method_docs': '[ HTTP: DELETE /storeproduct/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproduct_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproduct_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproduct/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updateProduct(self,
                      storeproduct_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /storeproduct/{id} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s"
        path_params = {"id": storeproduct_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateProduct.context = {'query_params': [], 'method_name': 'updateProduct', 'method_docs': '[ HTTP: PUT /storeproduct/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproduct_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproduct_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storeproduct/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchProducts(self,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /storeproduct/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProducts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchProducts', 'method_docs': '[ HTTP: GET /storeproduct/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproduct/search', 'method_kind': 'GET'}

    @download
    def getProduct(self,
                   storeproduct_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /storeproduct/{id} ]

        @param storeproduct_id: storeproduct_id
        @type storeproduct_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproduct/%(id)s"
        path_params = {"id": storeproduct_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProduct.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProduct', 'method_docs': '[ HTTP: GET /storeproduct/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproduct_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproduct_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproduct/%(id)s', 'method_kind': 'GET'}

class connection(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getConnection(self,
                      connection_id=None,
                      **kwargs):
        """
        [ HTTP: GET /connection/{id} ]

        @param connection_id: connection_id
        @type connection_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/%(id)s"
        path_params = {"id": connection_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getConnection.context = {'query_params': [], 'method_name': 'getConnection', 'method_docs': '[ HTTP: GET /connection/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'connection_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'connection_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'connection/%(id)s', 'method_kind': 'GET'}

    @download
    def createConnection(self,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /connection ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createConnection.context = {'query_params': [], 'method_name': 'createConnection', 'method_docs': '[ HTTP: POST /connection ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'connection', 'method_kind': 'POST'}

    @download
    def deleteConnection(self,
                         connection_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /connection/{id} ]

        @param connection_id: connection_id
        @type connection_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/%(id)s"
        path_params = {"id": connection_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteConnection.context = {'query_params': [], 'method_name': 'deleteConnection', 'method_docs': '[ HTTP: DELETE /connection/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'connection_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'connection_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'connection/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getConnectionsXML(self,
                          **kwargs):
        """
        [ HTTP: GET /connection ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getConnectionsXML.context = {'query_params': [], 'method_name': 'getConnectionsXML', 'method_docs': '[ HTTP: GET /connection ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'connection', 'method_kind': 'GET'}

    @download
    def searchConnections(self,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /connection/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchConnections.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchConnections', 'method_docs': '[ HTTP: GET /connection/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'connection/search', 'method_kind': 'GET'}

    @download
    def updateConnection(self,
                         connection_id=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /connection/{id} ]

        @param connection_id: connection_id
        @type connection_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "connection/%(id)s"
        path_params = {"id": connection_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateConnection.context = {'query_params': [], 'method_name': 'updateConnection', 'method_docs': '[ HTTP: PUT /connection/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'connection_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'connection_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'connection/%(id)s', 'method_kind': 'PUT'}

class runtime(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getRuntime(self,
                   runtime_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /runtime/{id} ]

        @param runtime_id: runtime_id
        @type runtime_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/%(id)s"
        path_params = {"id": runtime_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRuntime.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRuntime', 'method_docs': '[ HTTP: GET /runtime/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'runtime_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'runtime_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'runtime/%(id)s', 'method_kind': 'GET'}

    @download
    def getRuntimes(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /runtime ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRuntimes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRuntimes', 'method_docs': '[ HTTP: GET /runtime ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'runtime', 'method_kind': 'GET'}

    @download
    def deleteRuntime(self,
                      runtime_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /runtime/{id} ]

        @param runtime_id: runtime_id
        @type runtime_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/%(id)s"
        path_params = {"id": runtime_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteRuntime.context = {'query_params': [], 'method_name': 'deleteRuntime', 'method_docs': '[ HTTP: DELETE /runtime/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'runtime_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'runtime_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'runtime/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updateRuntime(self,
                      runtime_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /runtime/{id} ]

        @param runtime_id: runtime_id
        @type runtime_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/%(id)s"
        path_params = {"id": runtime_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRuntime.context = {'query_params': [], 'method_name': 'updateRuntime', 'method_docs': '[ HTTP: PUT /runtime/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'runtime_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'runtime_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'runtime/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchRuntimes(self,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /runtime/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "runtime/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchRuntimes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchRuntimes', 'method_docs': '[ HTTP: GET /runtime/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'runtime/search', 'method_kind': 'GET'}

class volume(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteVolume(self,
                     volume_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /volume/{id} ]

        @param volume_id: volume_id
        @type volume_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume/%(id)s"
        path_params = {"id": volume_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVolume.context = {'query_params': [], 'method_name': 'deleteVolume', 'method_docs': '[ HTTP: DELETE /volume/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volume_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volume_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volume/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getVolumesXML(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /volume ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolumesXML', 'method_docs': '[ HTTP: GET /volume ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volume', 'method_kind': 'GET'}

    @download
    def getVolume(self,
                  volume_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /volume/{id} ]

        @param volume_id: volume_id
        @type volume_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volume/%(id)s"
        path_params = {"id": volume_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolume.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolume', 'method_docs': '[ HTTP: GET /volume/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volume_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volume_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volume/%(id)s', 'method_kind': 'GET'}

class storerelease(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getRelease(self,
                   storerelease_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /storerelease/{id} ]

        @param storerelease_id: storerelease_id
        @type storerelease_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storerelease/%(id)s"
        path_params = {"id": storerelease_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRelease.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRelease', 'method_docs': '[ HTTP: GET /storerelease/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storerelease_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storerelease_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storerelease/%(id)s', 'method_kind': 'GET'}

    @download
    def searchReleases(self,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /storerelease/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storerelease/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchReleases.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchReleases', 'method_docs': '[ HTTP: GET /storerelease/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storerelease/search', 'method_kind': 'GET'}

    @download
    def getReleases(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /storerelease ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storerelease"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getReleases.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getReleases', 'method_docs': '[ HTTP: GET /storerelease ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storerelease', 'method_kind': 'GET'}

class cloud(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getLocations(self,
                     cloud_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /cloud/{id}/location ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getLocations.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getLocations', 'method_docs': '[ HTTP: GET /cloud/{id}/location ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/location', 'method_kind': 'GET'}

    @download
    def getCloud(self,
                 cloud_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloud.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCloud', 'method_docs': '[ HTTP: GET /cloud/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteCloud(self,
                    cloud_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCloud.context = {'query_params': [], 'method_name': 'deleteCloud', 'method_docs': '[ HTTP: DELETE /cloud/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloud_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s', 'method_kind': 'DELETE'}

    @download
    def deleteLocation(self,
                       cloud_id,
                       location_locid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/location/{locid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param location_locid: location_locid
        @type location_locid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location/%(locid)s"
        path_params = {"id": cloud_id,
                       "locid": location_locid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteLocation.context = {'query_params': [], 'method_name': 'deleteLocation', 'method_docs': '[ HTTP: DELETE /cloud/{id}/location/{locid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'locid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'location_locid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'locid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'location_locid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/location/%(locid)s', 'method_kind': 'DELETE'}

    @download
    def getNetworks(self,
                    cloud_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /cloud/{id}/network ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/network"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworks.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworks', 'method_docs': '[ HTTP: GET /cloud/{id}/network ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/network', 'method_kind': 'GET'}

    @download
    def searchCloudVolumes(self,
                           cloud_id,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/volume/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/volume/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudVolumes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudVolumes', 'method_docs': '[ HTTP: GET /cloud/{id}/volume/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/volume/search', 'method_kind': 'GET'}

    @download
    def syncCloud(self,
                  cloud_id,
                  excludes=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /cloud/{id}/resync ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param excludes: excludes
        @type excludes: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/resync"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"excludes": excludes}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncCloud.context = {'query_params': [{'name': 'excludes', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'excludes'}], 'method_name': 'syncCloud', 'method_docs': '[ HTTP: POST /cloud/{id}/resync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'excludes', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'excludes'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/resync', 'method_kind': 'POST'}

    @download
    def createNetworkSubscription(self,
                                  cloud_id,
                                  sdnId=None,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /cloud/{id}/sdn/{sdnId} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param sdnId: sdnId
        @type sdnId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/sdn/%(sdnId)s"
        path_params = {"id": cloud_id,
                       "sdnId": sdnId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetworkSubscription.context = {'query_params': [], 'method_name': 'createNetworkSubscription', 'method_docs': '[ HTTP: POST /cloud/{id}/sdn/{sdnId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'sdnId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdnId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'sdnId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdnId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/sdn/%(sdnId)s', 'method_kind': 'POST'}

    @download
    def createNetworkService(self,
                             cloud_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /cloud/{id}/networkservice ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetworkService.context = {'query_params': [], 'method_name': 'createNetworkService', 'method_docs': '[ HTTP: POST /cloud/{id}/networkservice ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'cloud/%(id)s/networkservice', 'method_kind': 'POST'}

    @download
    def getCloudKeysXML(self,
                        cloud_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudKeysXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCloudKeysXML', 'method_docs': '[ HTTP: GET /cloud/{id}/key ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/key', 'method_kind': 'GET'}

    @download
    def createRepository(self,
                         cloud_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /cloud/{id}/repository ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/repository"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRepository.context = {'query_params': [], 'method_name': 'createRepository', 'method_docs': '[ HTTP: POST /cloud/{id}/repository ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'cloud/%(id)s/repository', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     cloud_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /cloud/{id}/export ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/export"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /cloud/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/export', 'method_kind': 'GET'}

    @download
    def createLocation(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/location ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createLocation.context = {'query_params': [], 'method_name': 'createLocation', 'method_docs': '[ HTTP: POST /cloud/{id}/location ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloud/%(id)s/location', 'method_kind': 'POST'}

    @download
    def getNetworkServices(self,
                           cloud_id,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/networkservice ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServices.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkServices', 'method_docs': '[ HTTP: GET /cloud/{id}/networkservice ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/networkservice', 'method_kind': 'GET'}

    @download
    def searchClouds(self,
                     fields=None,
                     filterGroup=None,
                     limit=None,
                     offset=None,
                     orderBy=None,
                     usage=None,
                     **kwargs):
        """
        [ HTTP: GET /cloud/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchClouds.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchClouds', 'method_docs': '[ HTTP: GET /cloud/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/search', 'method_kind': 'GET'}

    @download
    def getCloudKey(self,
                    cloud_id,
                    keyid=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key/{keyid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param keyid: keyid
        @type keyid: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/%(keyid)s"
        path_params = {"id": cloud_id,
                       "keyid": keyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudKey.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCloudKey', 'method_docs': '[ HTTP: GET /cloud/{id}/key/{keyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'keyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'keyid'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'keyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'keyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/key/%(keyid)s', 'method_kind': 'GET'}

    @download
    def searchCloudLocations(self,
                             cloud_id,
                             fields=None,
                             filterGroup=None,
                             limit=None,
                             offset=None,
                             orderBy=None,
                             usage=None,
                             **kwargs):
        """
        [ HTTP: GET /cloud/{id}/location/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/location/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudLocations.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudLocations', 'method_docs': '[ HTTP: GET /cloud/{id}/location/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/location/search', 'method_kind': 'GET'}

    @download
    def createCloudXML(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCloudXML.context = {'query_params': [], 'method_name': 'createCloudXML', 'method_docs': '[ HTTP: POST /cloud ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloud', 'method_kind': 'POST'}

    @download
    def searchCloudNetworks(self,
                            cloud_id,
                            fields=None,
                            filterGroup=None,
                            limit=None,
                            offset=None,
                            orderBy=None,
                            usage=None,
                            **kwargs):
        """
        [ HTTP: GET /cloud/{id}/network/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/network/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudNetworks.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudNetworks', 'method_docs': '[ HTTP: GET /cloud/{id}/network/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/network/search', 'method_kind': 'GET'}

    @download
    def deleteVariable(self,
                       cloud_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /cloud/{id}/variable/{variable_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'method_kind': 'DELETE'}

    @download
    def getEffectiveModels(self,
                           cloud_id,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/model/effective ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/model/effective"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveModels.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEffectiveModels', 'method_docs': '[ HTTP: GET /cloud/{id}/model/effective ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/model/effective', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /cloud/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /cloud/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/export', 'method_kind': 'GET'}

    @download
    def deleteNetworkSubscription(self,
                                  cloud_id,
                                  sdn_subId=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/sdn/{subId} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param sdn_subId: sdn_subId
        @type sdn_subId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/sdn/%(subId)s"
        path_params = {"id": cloud_id,
                       "subId": sdn_subId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetworkSubscription.context = {'query_params': [], 'method_name': 'deleteNetworkSubscription', 'method_docs': '[ HTTP: DELETE /cloud/{id}/sdn/{subId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'subId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_subId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'subId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'sdn_subId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/sdn/%(subId)s', 'method_kind': 'DELETE'}

    @download
    def deleteCloudKey(self,
                       cloud_id,
                       keyid=None,
                       **kwargs):
        """
        [ HTTP: DELETE /cloud/{id}/key/{keyid} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param keyid: keyid
        @type keyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/%(keyid)s"
        path_params = {"id": cloud_id,
                       "keyid": keyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCloudKey.context = {'query_params': [], 'method_name': 'deleteCloudKey', 'method_docs': '[ HTTP: DELETE /cloud/{id}/key/{keyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'keyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'keyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'keyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'keyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/key/%(keyid)s', 'method_kind': 'DELETE'}

    @download
    def updateCloud(self,
                    cloud_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /cloud/{id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCloud.context = {'query_params': [], 'method_name': 'updateCloud', 'method_docs': '[ HTTP: PUT /cloud/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloud_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloud/%(id)s', 'method_kind': 'PUT'}

    @download
    def getRepositories(self,
                        cloud_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/repository ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/repository"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositories.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRepositories', 'method_docs': '[ HTTP: GET /cloud/{id}/repository ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/repository', 'method_kind': 'GET'}

    @download
    def searchCloudKeysXML(self,
                           cloud_id,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /cloud/{id}/key/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudKeysXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudKeysXML', 'method_docs': '[ HTTP: GET /cloud/{id}/key/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/key/search', 'method_kind': 'GET'}

    @download
    def searchCloudImagesXML(self,
                             cloud_id,
                             fields=None,
                             filterGroup=None,
                             limit=None,
                             offset=None,
                             orderBy=None,
                             usage=None,
                             **kwargs):
        """
        [ HTTP: GET /cloud/{id}/image/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/image/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudImagesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudImagesXML', 'method_docs': '[ HTTP: GET /cloud/{id}/image/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/image/search', 'method_kind': 'GET'}

    @download
    def searchCloudNetworkServices(self,
                                   cloud_id,
                                   fields=None,
                                   filterGroup=None,
                                   limit=None,
                                   offset=None,
                                   orderBy=None,
                                   usage=None,
                                   **kwargs):
        """
        [ HTTP: GET /cloud/{id}/networkservice/search ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/networkservice/search"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudNetworkServices.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudNetworkServices', 'method_docs': '[ HTTP: GET /cloud/{id}/networkservice/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/networkservice/search', 'method_kind': 'GET'}

    @download
    def createCloudKey(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/key ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/key"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCloudKey.context = {'query_params': [], 'method_name': 'createCloudKey', 'method_docs': '[ HTTP: POST /cloud/{id}/key ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloud/%(id)s/key', 'method_kind': 'POST'}

    @download
    def getVariableXML(self,
                       cloud_id,
                       variable_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariableXML', 'method_docs': '[ HTTP: GET /cloud/{id}/variable/{variable_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'method_kind': 'GET'}

    @download
    def createVariable(self,
                       cloud_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /cloud/{id}/variable ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /cloud/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloud/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def getCloudsXML(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /cloud ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCloudsXML', 'method_docs': '[ HTTP: GET /cloud ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud', 'method_kind': 'GET'}

    @download
    def decryptVariable(self,
                        cloud_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable/{variable_id}/decrypt ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'method_name': 'decryptVariable', 'method_docs': '[ HTTP: GET /cloud/{id}/variable/{variable_id}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s/decrypt', 'method_kind': 'GET'}

    @download
    def getVariablesXML(self,
                        cloud_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /cloud/{id}/variable ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable"
        path_params = {"id": cloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariablesXML', 'method_docs': '[ HTTP: GET /cloud/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloud/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def updateVariable(self,
                       cloud_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /cloud/{id}/variable/{variable_id} ]

        @param cloud_id: cloud_id
        @type cloud_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloud/%(id)s/variable/%(variable_id)s"
        path_params = {"id": cloud_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /cloud/{id}/variable/{variable_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloud_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloud/%(id)s/variable/%(variable_id)s', 'method_kind': 'PUT'}

class projecttemplate(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteSecurity(self,
                       projecttemplate_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/security/{security_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'method_name': 'deleteSecurity', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteAlias(self,
                    projecttemplate_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/alias/{alias_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/alias/%(alias_id)s"
        path_params = {"id": projecttemplate_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'method_name': 'deleteAlias', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/alias/%(alias_id)s', 'method_kind': 'DELETE'}

    @download
    def getVariable(self,
                    projecttemplate_project_id,
                    variable_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /projecttemplate/{project_id}/variable/{variable_id: [0-9]+} ]

        @param projecttemplate_project_id: projecttemplate_project_id
        @type projecttemplate_project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": projecttemplate_project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariable', 'method_docs': '[ HTTP: GET /projecttemplate/{project_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def deleteSecurityRights(self,
                             projecttemplate_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/rights/{rights_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'method_name': 'deleteSecurityRights', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/rights/{rights_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'method_kind': 'DELETE'}

    @download
    def importIDAction_2(self,
                         projecttemplate_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id}/import ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/import"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_2', 'method_docs': '[ HTTP: PUT /projecttemplate/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     projecttemplate_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/export ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/export"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/export', 'method_kind': 'GET'}

    @download
    def addSecurityUser(self,
                        projecttemplate_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/security/{security_id}/user ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/user"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'method_name': 'addSecurityUser', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/security/{security_id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/user', 'method_kind': 'POST'}

    @download
    def unsetProjectTemplateReady(self,
                                  projecttemplate_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id}/unsetready ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/unsetready"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    unsetProjectTemplateReady.context = {'query_params': [], 'method_name': 'unsetProjectTemplateReady', 'method_docs': '[ HTTP: PUT /projecttemplate/{id}/unsetready ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/unsetready', 'method_kind': 'PUT'}

    @download
    def getVariablesByName(self,
                           projecttemplate_project_id,
                           variable_vname=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /projecttemplate/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param projecttemplate_project_id: projecttemplate_project_id
        @type projecttemplate_project_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"project_id": projecttemplate_project_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariablesByName.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariablesByName', 'method_docs': '[ HTTP: GET /projecttemplate/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'GET'}

    @download
    def getAlias(self,
                 projecttemplate_id,
                 alias_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/alias/{alias_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/alias/%(alias_id)s"
        path_params = {"id": projecttemplate_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAlias', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/alias/%(alias_id)s', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /projecttemplate/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /projecttemplate/export ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/export', 'method_kind': 'GET'}

    @download
    def attachPolicy(self,
                     projecttemplate_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id}/policy/{policyid} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/policy/%(policyid)s"
        path_params = {"id": projecttemplate_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /projecttemplate/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def addSecurityAccessRight(self,
                               projecttemplate_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'method_name': 'addSecurityAccessRight', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'method_kind': 'POST'}

    @download
    def updateAlias(self,
                    projecttemplate_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id}/alias/{alias_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/alias/%(alias_id)s"
        path_params = {"id": projecttemplate_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'method_name': 'updateAlias', 'method_docs': '[ HTTP: PUT /projecttemplate/{id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/alias/%(alias_id)s', 'method_kind': 'PUT'}

    @download
    def createMultiVariable(self,
                            projecttemplate_project_id,
                            variable_vname=None,
                            fields=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /projecttemplate/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param projecttemplate_project_id: projecttemplate_project_id
        @type projecttemplate_project_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"project_id": projecttemplate_project_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMultiVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createMultiVariable', 'method_docs': '[ HTTP: POST /projecttemplate/{project_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(project_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getVariables(self,
                     projecttemplate_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/variable ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/variable"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariables', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def deleteProjectTemplate(self,
                              projecttemplate_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteProjectTemplate.context = {'query_params': [], 'method_name': 'deleteProjectTemplate', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projecttemplate_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchPolicyAssignments(self,
                                projecttemplate_id,
                                containerId=None,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/policyassignment/search ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/policyassignment/search"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       create=None,
                       update=None,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /projecttemplate/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /projecttemplate/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'projecttemplate/import', 'method_kind': 'PUT'}

    @download
    def decryptVariable(self,
                        projecttemplate_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/variable/{variable_id}/decrypt ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": projecttemplate_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'method_name': 'decryptVariable', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/variable/{variable_id}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/variable/%(variable_id)s/decrypt', 'method_kind': 'GET'}

    @download
    def addSecurity(self,
                    projecttemplate_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/security ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'method_name': 'addSecurity', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security', 'method_kind': 'POST'}

    @download
    def updateProjectTemplate(self,
                              projecttemplate_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateProjectTemplate.context = {'query_params': [], 'method_name': 'updateProjectTemplate', 'method_docs': '[ HTTP: PUT /projecttemplate/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s', 'method_kind': 'PUT'}

    @download
    def getProjectTemplate(self,
                           projecttemplate_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjectTemplate.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProjectTemplate', 'method_docs': '[ HTTP: GET /projecttemplate/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projecttemplate_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s', 'method_kind': 'GET'}

    @download
    def getPolicies(self,
                    projecttemplate_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/policy ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/policy"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def createAlias(self,
                    projecttemplate_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/alias ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/alias"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'method_name': 'createAlias', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/alias', 'method_kind': 'POST'}

    @download
    def setProjectTemplateReady(self,
                                projecttemplate_id,
                                data=None,
                                **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id}/setready ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/setready"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setProjectTemplateReady.context = {'query_params': [], 'method_name': 'setProjectTemplateReady', 'method_docs': '[ HTTP: PUT /projecttemplate/{id}/setready ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/setready', 'method_kind': 'PUT'}

    @download
    def searchProjectTemplates(self,
                               containerId=None,
                               _select=None,
                               filterGroup=None,
                               _top=None,
                               _skip=None,
                               _orderby=None,
                               _metadata=None,
                               qterm=None,
                               usage=None,
                               readyForUse=None,
                               **kwargs):
        """
        [ HTTP: GET /projecttemplate ]

        @param containerId: containerId
        @type containerId: str
        @param _select: _select
        @type _select: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param _top: _top
        @type _top: str
        @param _skip: _skip
        @type _skip: str
        @param _orderby: _orderby
        @type _orderby: str
        @param _metadata: _metadata
        @type _metadata: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param readyForUse: readyForUse
        @type readyForUse: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "_select": _select,
                        "filterGroup": filterGroup,
                        "_top": _top,
                        "_skip": _skip,
                        "_orderby": _orderby,
                        "_metadata": _metadata,
                        "qterm": qterm,
                        "usage": usage,
                        "readyForUse": readyForUse}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProjectTemplates.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': '_select', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_select'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': '_top', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_top'}, {'name': '_skip', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_skip'}, {'name': '_orderby', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_orderby'}, {'name': '_metadata', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_metadata'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'readyForUse', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'readyForUse'}], 'method_name': 'searchProjectTemplates', 'method_docs': '[ HTTP: GET /projecttemplate ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': '_select', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_select'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': '_top', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_top'}, {'name': '_skip', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': '_skip'}, {'name': '_orderby', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_orderby'}, {'name': '_metadata', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': '_metadata'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'readyForUse', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'readyForUse'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate', 'method_kind': 'GET'}

    @download
    def createProjectTemplate(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /projecttemplate ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProjectTemplate.context = {'query_params': [], 'method_name': 'createProjectTemplate', 'method_docs': '[ HTTP: POST /projecttemplate ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate', 'method_kind': 'POST'}

    @download
    def importIDAction_1(self,
                         projecttemplate_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         files=None,
                         **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{id}/import ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/import"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_1', 'method_docs': '[ HTTP: PUT /projecttemplate/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getSecurity(self,
                    projecttemplate_id,
                    security_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/security/{security_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSecurity', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s', 'method_kind': 'GET'}

    @download
    def addSecurityUserGroup(self,
                             projecttemplate_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/security/{security_id}/usergroup ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'method_name': 'addSecurityUserGroup', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/security/{security_id}/usergroup ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/usergroup', 'method_kind': 'POST'}

    @download
    def getEnvironments(self,
                        projecttemplate_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/environment ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/environment"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEnvironments', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/environment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/environment', 'method_kind': 'GET'}

    @download
    def deleteVariable(self,
                       projecttemplate_project_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{project_id}/variable/{variable_id: [0-9]+} ]

        @param projecttemplate_project_id: projecttemplate_project_id
        @type projecttemplate_project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": projecttemplate_project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /projecttemplate/{project_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def getAliases(self,
                   projecttemplate_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /projecttemplate/{id}/alias ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/alias"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAliases', 'method_docs': '[ HTTP: GET /projecttemplate/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/alias', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       create=None,
                       update=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /projecttemplate/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /projecttemplate/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/import', 'method_kind': 'PUT'}

    @download
    def removePolicy(self,
                     projecttemplate_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/policy/{policyid} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/policy/%(policyid)s"
        path_params = {"id": projecttemplate_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurityUserGroup(self,
                                projecttemplate_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'method_name': 'deleteSecurityUserGroup', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'method_kind': 'DELETE'}

    @download
    def cloneProjectTemplate(self,
                             projecttemplate_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/clone ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/clone"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneProjectTemplate.context = {'query_params': [], 'method_name': 'cloneProjectTemplate', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/clone ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/clone', 'method_kind': 'POST'}

    @download
    def createEnvironment(self,
                          projecttemplate_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/environment ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/environment"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createEnvironment.context = {'query_params': [], 'method_name': 'createEnvironment', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/environment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/environment', 'method_kind': 'POST'}

    @download
    def addSecurityRights(self,
                          projecttemplate_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/security/{security_id}/rights ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'method_name': 'addSecurityRights', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/security/{security_id}/rights ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/rights', 'method_kind': 'POST'}

    @download
    def createVariable(self,
                       projecttemplate_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /projecttemplate/{id}/variable ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/variable"
        path_params = {"id": projecttemplate_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /projecttemplate/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def deleteSecurityUser(self,
                           projecttemplate_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/user/{user_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'method_name': 'deleteSecurityUser', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/user/{user_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/user/%(user_id)s', 'method_kind': 'DELETE'}

    @download
    def updateVariable(self,
                       projecttemplate_project_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /projecttemplate/{project_id}/variable/{variable_id: [0-9]+} ]

        @param projecttemplate_project_id: projecttemplate_project_id
        @type projecttemplate_project_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(project_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"project_id": projecttemplate_project_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /projecttemplate/{project_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'project_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_project_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'projecttemplate/%(project_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def deleteSecurityAccessRight(self,
                                  projecttemplate_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param projecttemplate_id: projecttemplate_id
        @type projecttemplate_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projecttemplate/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": projecttemplate_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'method_name': 'deleteSecurityAccessRight', 'method_docs': '[ HTTP: DELETE /projecttemplate/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projecttemplate_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projecttemplate/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'method_kind': 'DELETE'}

class address(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAddress(self,
                   address_id=None,
                   **kwargs):
        """
        [ HTTP: GET /address/{id} ]

        @param address_id: address_id
        @type address_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "address/%(id)s"
        path_params = {"id": address_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAddress.context = {'query_params': [], 'method_name': 'getAddress', 'method_docs': '[ HTTP: GET /address/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'address_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'address_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'address/%(id)s', 'method_kind': 'GET'}

class nextatomicinteger(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def addAndGetAtomicIntegerValue(self,
                                    nextatomicinteger_key,
                                    delta=None,
                                    maxRetries=None,
                                    **kwargs):
        """
        [ HTTP: GET /nextatomicinteger/{key}/value ]

        @param nextatomicinteger_key: nextatomicinteger_key
        @type nextatomicinteger_key: str
        @param delta: delta
        @type delta: str
        @param maxRetries: maxRetries
        @type maxRetries: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "nextatomicinteger/%(key)s/value"
        path_params = {"key": nextatomicinteger_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"delta": delta,
                        "maxRetries": maxRetries}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addAndGetAtomicIntegerValue.context = {'query_params': [{'name': 'delta', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'delta'}, {'name': 'maxRetries', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'maxRetries'}], 'method_name': 'addAndGetAtomicIntegerValue', 'method_docs': '[ HTTP: GET /nextatomicinteger/{key}/value ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'nextatomicinteger_key'}, {'name': 'delta', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'delta'}, {'name': 'maxRetries', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'maxRetries'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'nextatomicinteger_key'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'nextatomicinteger/%(key)s/value', 'method_kind': 'GET'}

    @download
    def deleteAtomicInteger(self,
                            nextatomicinteger_key=None,
                            **kwargs):
        """
        [ HTTP: DELETE /nextatomicinteger/{key} ]

        @param nextatomicinteger_key: nextatomicinteger_key
        @type nextatomicinteger_key: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "nextatomicinteger/%(key)s"
        path_params = {"key": nextatomicinteger_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAtomicInteger.context = {'query_params': [], 'method_name': 'deleteAtomicInteger', 'method_docs': '[ HTTP: DELETE /nextatomicinteger/{key} ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'nextatomicinteger_key'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'nextatomicinteger_key'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'nextatomicinteger/%(key)s', 'method_kind': 'DELETE'}

    @download
    def createAtomicInteger(self,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /nextatomicinteger ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "nextatomicinteger"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAtomicInteger.context = {'query_params': [], 'method_name': 'createAtomicInteger', 'method_docs': '[ HTTP: POST /nextatomicinteger ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'nextatomicinteger', 'method_kind': 'POST'}

    @download
    def addAndGetAtomicInteger(self,
                               nextatomicinteger_key=None,
                               delta=None,
                               maxRetries=None,
                               **kwargs):
        """
        [ HTTP: GET /nextatomicinteger/{key} ]

        @param nextatomicinteger_key: nextatomicinteger_key
        @type nextatomicinteger_key: str
        @param delta: delta
        @type delta: str
        @param maxRetries: maxRetries
        @type maxRetries: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "nextatomicinteger/%(key)s"
        path_params = {"key": nextatomicinteger_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"delta": delta,
                        "maxRetries": maxRetries}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addAndGetAtomicInteger.context = {'query_params': [{'name': 'delta', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'delta'}, {'name': 'maxRetries', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'maxRetries'}], 'method_name': 'addAndGetAtomicInteger', 'method_docs': '[ HTTP: GET /nextatomicinteger/{key} ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'nextatomicinteger_key'}, {'name': 'delta', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'delta'}, {'name': 'maxRetries', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'maxRetries'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'nextatomicinteger_key'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'nextatomicinteger/%(key)s', 'method_kind': 'GET'}

    @download
    def getAllAtomicIntegers(self,
                             fields=None,
                             filterGroup=None,
                             limit=None,
                             offset=None,
                             orderBy=None,
                             usage=None,
                             **kwargs):
        """
        [ HTTP: GET /nextatomicinteger ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "nextatomicinteger"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllAtomicIntegers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'getAllAtomicIntegers', 'method_docs': '[ HTTP: GET /nextatomicinteger ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'nextatomicinteger', 'method_kind': 'GET'}

    @download
    def updateAtomicInteger(self,
                            nextatomicinteger_key=None,
                            **kwargs):
        """
        [ HTTP: PATCH /nextatomicinteger/{key} ]

        @param nextatomicinteger_key: nextatomicinteger_key
        @type nextatomicinteger_key: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "nextatomicinteger/%(key)s"
        path_params = {"key": nextatomicinteger_key}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("PATCH", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAtomicInteger.context = {'query_params': [], 'method_name': 'updateAtomicInteger', 'method_docs': '[ HTTP: PATCH /nextatomicinteger/{key} ]', 'result': 'result', 'method_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'nextatomicinteger_key'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'key', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'nextatomicinteger_key'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'nextatomicinteger/%(key)s', 'method_kind': 'PATCH'}

class topology(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createChildTemplate(self,
                            topology_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{id}/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplate.context = {'query_params': [], 'method_name': 'createChildTemplate', 'method_docs': '[ HTTP: POST /topology/{id}/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/template', 'method_kind': 'POST'}

    @download
    def setAccessUris(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{topology_id}/accessuris ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuris"
        path_params = {"topology_id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setAccessUris.context = {'query_params': [], 'method_name': 'setAccessUris', 'method_docs': '[ HTTP: POST /topology/{topology_id}/accessuris ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/accessuris', 'method_kind': 'POST'}

    @download
    def releaseTopology(self,
                        topology_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /topology/{id}/release ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/release"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseTopology.context = {'query_params': [], 'method_name': 'releaseTopology', 'method_docs': '[ HTTP: POST /topology/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/release', 'method_kind': 'POST'}

    @download
    def createChildTopologyAnyOrder(self,
                                    topology_id,
                                    data=None,
                                    **kwargs):
        """
        [ HTTP: POST /topology/{id}/anyorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/anyorder/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopologyAnyOrder.context = {'query_params': [], 'method_name': 'createChildTopologyAnyOrder', 'method_docs': '[ HTTP: POST /topology/{id}/anyorder/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/anyorder/topology', 'method_kind': 'POST'}

    @download
    def deleteAlias(self,
                    topology_id,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'method_name': 'deleteAlias', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'method_kind': 'DELETE'}

    @download
    def checkOut(self,
                 topology_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/checkout ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/checkout"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'method_name': 'checkOut', 'method_docs': '[ HTTP: POST /topology/{id}/checkout ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/checkout', 'method_kind': 'POST'}

    @download
    def createAlias(self,
                    topology_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /topology/{id}/alias ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/alias"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAlias.context = {'query_params': [], 'method_name': 'createAlias', 'method_docs': '[ HTTP: POST /topology/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/alias', 'method_kind': 'POST'}

    @download
    def approve(self,
                topology_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /topology/{id}/approve ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/approve"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: POST /topology/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     topology_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/export ]

        @param topology_id: topology_id
        @type topology_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/export"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /topology/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/export', 'method_kind': 'GET'}

    @download
    def searchTopologies(self,
                         containerId=None,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         qterm=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /topology/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTopologies.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchTopologies', 'method_docs': '[ HTTP: GET /topology/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/search', 'method_kind': 'GET'}

    @download
    def approval(self,
                 topology_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/approval ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/approval"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /topology/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def getAlias(self,
                 topology_id,
                 alias_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAlias', 'method_docs': '[ HTTP: GET /topology/{topology_id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'method_kind': 'GET'}

    @download
    def attachPolicy(self,
                     topology_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /topology/{id}/policy/{policyid} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/policy/%(policyid)s"
        path_params = {"id": topology_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /topology/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /topology/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /topology/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/export', 'method_kind': 'GET'}

    @download
    def createMultiVariable(self,
                            topology_top_id,
                            variable_vname=None,
                            value=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{top_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param topology_top_id: topology_top_id
        @type topology_top_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param value: value
        @type value: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(top_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"top_id": topology_top_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"value": value}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMultiVariable.context = {'query_params': [{'name': 'value', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'value'}], 'method_name': 'createMultiVariable', 'method_docs': '[ HTTP: POST /topology/{top_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'top_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_top_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'value', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'value'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'top_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_top_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(top_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getTopology(self,
                    topology_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopology.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTopology', 'method_docs': '[ HTTP: GET /topology/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s', 'method_kind': 'GET'}

    @download
    def createChildTopology(self,
                            topology_id,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /topology/{id}/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopology.context = {'query_params': [], 'method_name': 'createChildTopology', 'method_docs': '[ HTTP: POST /topology/{id}/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/topology', 'method_kind': 'POST'}

    @download
    def searchPolicyAssignments(self,
                                topology_id,
                                containerId=None,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /topology/{id}/policyassignment/search ]

        @param topology_id: topology_id
        @type topology_id: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/policyassignment/search"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /topology/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def cloneTopology(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/clone ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/clone"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cloneTopology.context = {'query_params': [], 'method_name': 'cloneTopology', 'method_docs': '[ HTTP: POST /topology/{id}/clone ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/clone', 'method_kind': 'POST'}

    @download
    def stopTopology(self,
                     topology_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /topology/{id}/stop ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/stop"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopTopology.context = {'query_params': [], 'method_name': 'stopTopology', 'method_docs': '[ HTTP: POST /topology/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def reject(self,
               topology_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /topology/{id}/reject ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/reject"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: POST /topology/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/reject', 'method_kind': 'POST'}

    @download
    def deleteVariable(self,
                       topology_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/variable/{variable_id: [0-9]+} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def getChildTemplates(self,
                          topology_id,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /topology/{id}/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildTemplates.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getChildTemplates', 'method_docs': '[ HTTP: GET /topology/{id}/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/template', 'method_kind': 'GET'}

    @download
    def createChildTemplateManual(self,
                                  topology_id,
                                  data=None,
                                  **kwargs):
        """
        [ HTTP: POST /topology/{id}/manualorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/manualorder/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplateManual.context = {'query_params': [], 'method_name': 'createChildTemplateManual', 'method_docs': '[ HTTP: POST /topology/{id}/manualorder/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/manualorder/template', 'method_kind': 'POST'}

    @download
    def createChildTopologyManualOrder(self,
                                       topology_id,
                                       data=None,
                                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/manualorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/manualorder/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopologyManualOrder.context = {'query_params': [], 'method_name': 'createChildTopologyManualOrder', 'method_docs': '[ HTTP: POST /topology/{id}/manualorder/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/manualorder/topology', 'method_kind': 'POST'}

    @download
    def getVariableByName(self,
                          topology_top_id,
                          variable_vname=None,
                          **kwargs):
        """
        [ HTTP: GET /topology/{top_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param topology_top_id: topology_top_id
        @type topology_top_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(top_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"top_id": topology_top_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableByName.context = {'query_params': [], 'method_name': 'getVariableByName', 'method_docs': '[ HTTP: GET /topology/{top_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'top_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_top_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'top_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_top_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(top_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'GET'}

    @download
    def importIDAction_2(self,
                         topology_id,
                         create=None,
                         update=None,
                         data=None,
                         files=None,
                         **kwargs):
        """
        [ HTTP: PUT /topology/{id}/import ]

        @param topology_id: topology_id
        @type topology_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/import"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importIDAction_2', 'method_docs': '[ HTTP: PUT /topology/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'topology/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def supportsVersioning(self,
                           **kwargs):
        """
        [ HTTP: GET /topology/versionable ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/versionable"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    supportsVersioning.context = {'query_params': [], 'method_name': 'supportsVersioning', 'method_docs': '[ HTTP: GET /topology/versionable ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/versionable', 'method_kind': 'GET'}

    @download
    def createChildTemplateFixed(self,
                                 topology_id,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /topology/{id}/fixedorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/fixedorder/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplateFixed.context = {'query_params': [], 'method_name': 'createChildTemplateFixed', 'method_docs': '[ HTTP: POST /topology/{id}/fixedorder/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/fixedorder/template', 'method_kind': 'POST'}

    @download
    def getTopologyStats(self,
                         topology_id,
                         **kwargs):
        """
        [ HTTP: GET /topology/{id}/stats ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/stats"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologyStats.context = {'query_params': [], 'method_name': 'getTopologyStats', 'method_docs': '[ HTTP: GET /topology/{id}/stats ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/stats', 'method_kind': 'GET'}

    @download
    def rebootTopology(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/restart ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/restart"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootTopology.context = {'query_params': [], 'method_name': 'rebootTopology', 'method_docs': '[ HTTP: POST /topology/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def getAccessUri(self,
                     topology_id,
                     accessuri_id=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/accessuri/{accessuri_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param accessuri_id: accessuri_id
        @type accessuri_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri/%(accessuri_id)s"
        path_params = {"topology_id": topology_id,
                       "accessuri_id": accessuri_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAccessUri.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAccessUri', 'method_docs': '[ HTTP: GET /topology/{topology_id}/accessuri/{accessuri_id} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'accessuri_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessuri_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'accessuri_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessuri_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/accessuri/%(accessuri_id)s', 'method_kind': 'GET'}

    @download
    def getAccessUris(self,
                      topology_id,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /topology/{id}/accessuri ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/accessuri"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAccessUris.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAccessUris', 'method_docs': '[ HTTP: GET /topology/{id}/accessuri ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/accessuri', 'method_kind': 'GET'}

    @download
    def getChildServiceInstances(self,
                                 topology_id,
                                 fields=None,
                                 **kwargs):
        """
        [ HTTP: GET /topology/{id}/serviceinstance ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/serviceinstance"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildServiceInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getChildServiceInstances', 'method_docs': '[ HTTP: GET /topology/{id}/serviceinstance ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/serviceinstance', 'method_kind': 'GET'}

    @download
    def createAccessUri(self,
                        topology_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /topology/{topology_id}/accessuri ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri"
        path_params = {"topology_id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAccessUri.context = {'query_params': [], 'method_name': 'createAccessUri', 'method_docs': '[ HTTP: POST /topology/{topology_id}/accessuri ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/accessuri', 'method_kind': 'POST'}

    @download
    def importIDAction_1(self,
                         topology_id,
                         create=None,
                         update=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /topology/{id}/import ]

        @param topology_id: topology_id
        @type topology_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/import"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importIDAction_1', 'method_docs': '[ HTTP: PUT /topology/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getVariable(self,
                    topology_id,
                    variable_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{topology_id}/variable/{variable_id: [0-9]+} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariable', 'method_docs': '[ HTTP: GET /topology/{topology_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def getPolicies(self,
                    topology_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /topology/{id}/policy ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/policy"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /topology/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def getTopologies(self,
                      fields=None,
                      version=None,
                      **kwargs):
        """
        [ HTTP: GET /topology ]

        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTopologies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}], 'method_name': 'getTopologies', 'method_docs': '[ HTTP: GET /topology ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology', 'method_kind': 'GET'}

    @download
    def startTopology(self,
                      topology_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/start ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/start"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startTopology.context = {'query_params': [], 'method_name': 'startTopology', 'method_docs': '[ HTTP: POST /topology/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/start', 'method_kind': 'POST'}

    @download
    def getAliases(self,
                   topology_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /topology/{id}/alias ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/alias"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliases.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAliases', 'method_docs': '[ HTTP: GET /topology/{id}/alias ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/alias', 'method_kind': 'GET'}

    @download
    def getDeployers(self,
                     topology_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/deployer ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/deployer"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployers', 'method_docs': '[ HTTP: GET /topology/{id}/deployer ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/deployer', 'method_kind': 'GET'}

    @download
    def updateAlias(self,
                    topology_id,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/alias/{alias_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/alias/%(alias_id)s"
        path_params = {"topology_id": topology_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'method_name': 'updateAlias', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/alias/{alias_id} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/alias/%(alias_id)s', 'method_kind': 'PUT'}

    @download
    def removePolicy(self,
                     topology_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /topology/{id}/policy/{policyid} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/policy/%(policyid)s"
        path_params = {"id": topology_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /topology/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def createChildTopologyFixedOrder(self,
                                      topology_id,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: POST /topology/{id}/fixedorder/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/fixedorder/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTopologyFixedOrder.context = {'query_params': [], 'method_name': 'createChildTopologyFixedOrder', 'method_docs': '[ HTTP: POST /topology/{id}/fixedorder/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/fixedorder/topology', 'method_kind': 'POST'}

    @download
    def updateAcessUri(self,
                       topology_id,
                       accessuri_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/accessuri/{accessuri_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param accessuri_id: accessuri_id
        @type accessuri_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri/%(accessuri_id)s"
        path_params = {"topology_id": topology_id,
                       "accessuri_id": accessuri_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAcessUri.context = {'query_params': [], 'method_name': 'updateAcessUri', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/accessuri/{accessuri_id} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'accessuri_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessuri_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'accessuri_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessuri_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/accessuri/%(accessuri_id)s', 'method_kind': 'PUT'}

    @download
    def getChildTopologies(self,
                           topology_id,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /topology/{id}/topology ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/topology"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getChildTopologies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getChildTopologies', 'method_docs': '[ HTTP: GET /topology/{id}/topology ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/topology', 'method_kind': 'GET'}

    @download
    def deleteAccessUri(self,
                        topology_id,
                        accessuri_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /topology/{topology_id}/accessuri/{accessuri_id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param accessuri_id: accessuri_id
        @type accessuri_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/accessuri/%(accessuri_id)s"
        path_params = {"topology_id": topology_id,
                       "accessuri_id": accessuri_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAccessUri.context = {'query_params': [], 'method_name': 'deleteAccessUri', 'method_docs': '[ HTTP: DELETE /topology/{topology_id}/accessuri/{accessuri_id} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'accessuri_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessuri_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'accessuri_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessuri_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/accessuri/%(accessuri_id)s', 'method_kind': 'DELETE'}

    @download
    def updateTopology(self,
                       topology_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateTopology.context = {'query_params': [], 'method_name': 'updateTopology', 'method_docs': '[ HTTP: PUT /topology/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s', 'method_kind': 'PUT'}

    @download
    def createChildTemplateAny(self,
                               topology_id,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /topology/{id}/anyorder/template ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/anyorder/template"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createChildTemplateAny.context = {'query_params': [], 'method_name': 'createChildTemplateAny', 'method_docs': '[ HTTP: POST /topology/{id}/anyorder/template ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/anyorder/template', 'method_kind': 'POST'}

    @download
    def getAllVersions(self,
                       topology_slotId,
                       fields=None,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /topology/{slotId}/version ]

        @param topology_slotId: topology_slotId
        @type topology_slotId: str
        @param fields: fields
        @type fields: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(slotId)s/version"
        path_params = {"slotId": topology_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "includeHead": includeHead}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /topology/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_slotId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(slotId)s/version', 'method_kind': 'GET'}

    @download
    def createVariable(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/variable ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /topology/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def rejection(self,
                  topology_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /topology/{id}/rejection ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/rejection"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /topology/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def createDeployer(self,
                       topology_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /topology/{id}/deployer ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/deployer"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDeployer.context = {'query_params': [], 'method_name': 'createDeployer', 'method_docs': '[ HTTP: POST /topology/{id}/deployer ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/deployer', 'method_kind': 'POST'}

    @download
    def updateVariable(self,
                       topology_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /topology/{topology_id}/variable/{variable_id: [0-9]+} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"topology_id": topology_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /topology/{topology_id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'topology_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'topology/%(topology_id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def getVariables(self,
                     topology_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /topology/{id}/variable ]

        @param topology_id: topology_id
        @type topology_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/variable"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariables', 'method_docs': '[ HTTP: GET /topology/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def checkIn(self,
                topology_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /topology/{id}/checkin ]

        @param topology_id: topology_id
        @type topology_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s/checkin"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'method_name': 'checkIn', 'method_docs': '[ HTTP: POST /topology/{id}/checkin ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'topology/%(id)s/checkin', 'method_kind': 'POST'}

    @download
    def deleteTopology(self,
                       topology_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /topology/{id} ]

        @param topology_id: topology_id
        @type topology_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "topology/%(id)s"
        path_params = {"id": topology_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteTopology.context = {'query_params': [], 'method_name': 'deleteTopology', 'method_docs': '[ HTTP: DELETE /topology/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'topology_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'topology_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'topology/%(id)s', 'method_kind': 'DELETE'}

class compute(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getVariableByName(self,
                          compute_instance_id,
                          variable_vname=None,
                          **kwargs):
        """
        [ HTTP: GET /compute/{instance_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param compute_instance_id: compute_instance_id
        @type compute_instance_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(instance_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"instance_id": compute_instance_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariableByName.context = {'query_params': [], 'method_name': 'getVariableByName', 'method_docs': '[ HTTP: GET /compute/{instance_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'instance_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_instance_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'instance_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_instance_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(instance_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'GET'}

    @download
    def updateAlias_1(self,
                      compute_id,
                      alias_name=None,
                      fields=None,
                      filterGroup=None,
                      limit=None,
                      offset=None,
                      orderBy=None,
                      usage=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/alias/{name: [a-zA-Z0-9_\-]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param alias_name: alias_name
        @type alias_name: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/alias/%(name: [a-zA-Z0-9_\-]+)s"
        path_params = {"id": compute_id,
                       "name": alias_name}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'updateAlias_1', 'method_docs': '[ HTTP: POST /compute/{id}/alias/{name: [a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'name', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'alias_name'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'name', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'alias_name'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/alias/%(name: [a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getInstance(self,
                    compute_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstance.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getInstance', 'method_docs': '[ HTTP: GET /compute/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'compute_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s', 'method_kind': 'GET'}

    @download
    def startInstance(self,
                      compute_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/start ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/start"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startInstance.context = {'query_params': [], 'method_name': 'startInstance', 'method_docs': '[ HTTP: POST /compute/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/start', 'method_kind': 'POST'}

    @download
    def buildStack(self,
                   compute_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /compute/{id}/stack ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/stack"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    buildStack.context = {'query_params': [], 'method_name': 'buildStack', 'method_docs': '[ HTTP: POST /compute/{id}/stack ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'compute/%(id)s/stack', 'method_kind': 'POST'}

    @download
    def getSnapshot(self,
                    compute_id,
                    snapshot_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSnapshot.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSnapshot', 'method_docs': '[ HTTP: GET /compute/{id}/snapshot/{snapshot_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'method_kind': 'GET'}

    @download
    def detachStorage(self,
                      compute_id,
                      detach_storageId=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/storage/detach/{storageId} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param detach_storageId: detach_storageId
        @type detach_storageId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/storage/detach/%(storageId)s"
        path_params = {"id": compute_id,
                       "storageId": detach_storageId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    detachStorage.context = {'query_params': [], 'method_name': 'detachStorage', 'method_docs': '[ HTTP: POST /compute/{id}/storage/detach/{storageId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'storageId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'detach_storageId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'storageId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'detach_storageId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/storage/detach/%(storageId)s', 'method_kind': 'POST'}

    @download
    def rebootInstance(self,
                       compute_id,
                       reconfigure=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /compute/{id}/restart ]

        @param compute_id: compute_id
        @type compute_id: str
        @param reconfigure: reconfigure
        @type reconfigure: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/restart"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"reconfigure": reconfigure}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootInstance.context = {'query_params': [{'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}], 'method_name': 'rebootInstance', 'method_docs': '[ HTTP: POST /compute/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def checkAccess(self,
                    ip=None,
                    port=None,
                    auth=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/access ]

        @param ip: ip
        @type ip: str
        @param port: port
        @type port: str
        @param auth: auth
        @type auth: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/access"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"ip": ip,
                        "port": port,
                        "auth": auth}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkAccess.context = {'query_params': [{'name': 'ip', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ip'}, {'name': 'port', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port'}, {'name': 'auth', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'auth'}], 'method_name': 'checkAccess', 'method_docs': '[ HTTP: GET /compute/access ]', 'result': 'result', 'method_params': [{'name': 'ip', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'ip'}, {'name': 'port', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port'}, {'name': 'auth', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'auth'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/access', 'method_kind': 'GET'}

    @download
    def acknowledgeDegrade(self,
                           compute_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /compute/{id}/ack ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/ack"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    acknowledgeDegrade.context = {'query_params': [], 'method_name': 'acknowledgeDegrade', 'method_docs': '[ HTTP: PUT /compute/{id}/ack ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/ack', 'method_kind': 'PUT'}

    @download
    def testExtendVolume(self,
                         compute_id,
                         **kwargs):
        """
        [ HTTP: GET /compute/{id}/storage/testExtend ]

        @param compute_id: compute_id
        @type compute_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/storage/testExtend"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    testExtendVolume.context = {'query_params': [], 'method_name': 'testExtendVolume', 'method_docs': '[ HTTP: GET /compute/{id}/storage/testExtend ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/storage/testExtend', 'method_kind': 'GET'}

    @download
    def searchInstances(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        qterm=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /compute/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchInstances', 'method_docs': '[ HTTP: GET /compute/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/search', 'method_kind': 'GET'}

    @download
    def getVariable(self,
                    compute_id,
                    variable_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /compute/{id}/variable/{variable_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariable', 'method_docs': '[ HTTP: GET /compute/{id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def updateDistNodePackage(self,
                              compute_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /compute/{id}/platform/package ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/platform/package"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateDistNodePackage.context = {'query_params': [], 'method_name': 'updateDistNodePackage', 'method_docs': '[ HTTP: PUT /compute/{id}/platform/package ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'compute/%(id)s/platform/package', 'method_kind': 'PUT'}

    @download
    def detachAllStorage(self,
                         compute_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /compute/{id}/storage/detachall ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/storage/detachall"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    detachAllStorage.context = {'query_params': [], 'method_name': 'detachAllStorage', 'method_docs': '[ HTTP: POST /compute/{id}/storage/detachall ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/storage/detachall', 'method_kind': 'POST'}

    @download
    def deleteSnapshot(self,
                       compute_id,
                       snapshot_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSnapshot.context = {'query_params': [], 'method_name': 'deleteSnapshot', 'method_docs': '[ HTTP: DELETE /compute/{id}/snapshot/{snapshot_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'method_kind': 'DELETE'}

    @download
    def revertSnapshot(self,
                       compute_id,
                       snapshot_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id}/snapshot/{snapshot_id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": compute_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    revertSnapshot.context = {'query_params': [], 'method_name': 'revertSnapshot', 'method_docs': '[ HTTP: PUT /compute/{id}/snapshot/{snapshot_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/snapshot/%(snapshot_id)s', 'method_kind': 'PUT'}

    @download
    def stopInstance(self,
                     compute_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /compute/{id}/stop ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/stop"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopInstance.context = {'query_params': [], 'method_name': 'stopInstance', 'method_docs': '[ HTTP: POST /compute/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def executeScriptTask(self,
                          compute_id,
                          queue_scriptid=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /compute/{id}/queue/{scriptid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param queue_scriptid: queue_scriptid
        @type queue_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/queue/%(scriptid)s"
        path_params = {"id": compute_id,
                       "scriptid": queue_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    executeScriptTask.context = {'query_params': [], 'method_name': 'executeScriptTask', 'method_docs': '[ HTTP: POST /compute/{id}/queue/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'queue_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'queue_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/queue/%(scriptid)s', 'method_kind': 'POST'}

    @download
    def getInstancesXML(self,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /compute ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getInstancesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getInstancesXML', 'method_docs': '[ HTTP: GET /compute ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute', 'method_kind': 'GET'}

    @download
    def deleteVariable(self,
                       compute_id,
                       variable_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /compute/{id}/variable/{variable_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteVariable.context = {'query_params': [], 'method_name': 'deleteVariable', 'method_docs': '[ HTTP: DELETE /compute/{id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def extendVolume(self,
                     compute_id,
                     storageId=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /compute/{id}/storage/{storageId}/extend ]

        @param compute_id: compute_id
        @type compute_id: str
        @param storageId: storageId
        @type storageId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/storage/%(storageId)s/extend"
        path_params = {"id": compute_id,
                       "storageId": storageId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    extendVolume.context = {'query_params': [], 'method_name': 'extendVolume', 'method_docs': '[ HTTP: PUT /compute/{id}/storage/{storageId}/extend ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'storageId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storageId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'storageId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storageId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/storage/%(storageId)s/extend', 'method_kind': 'PUT'}

    @download
    def snapshotInstance(self,
                         compute_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /compute/{id}/snapshot ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/snapshot"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    snapshotInstance.context = {'query_params': [], 'method_name': 'snapshotInstance', 'method_docs': '[ HTTP: POST /compute/{id}/snapshot ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'compute/%(id)s/snapshot', 'method_kind': 'POST'}

    @download
    def releaseInstance(self,
                        compute_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /compute/{id}/release ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/release"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseInstance.context = {'query_params': [], 'method_name': 'releaseInstance', 'method_docs': '[ HTTP: POST /compute/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/release', 'method_kind': 'POST'}

    @download
    def createMultiVariable(self,
                            compute_instance_id,
                            variable_vname=None,
                            fields=None,
                            data=None,
                            **kwargs):
        """
        [ HTTP: POST /compute/{instance_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+} ]

        @param compute_instance_id: compute_instance_id
        @type compute_instance_id: str
        @param variable_vname: variable_vname
        @type variable_vname: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(instance_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\-]+)s"
        path_params = {"instance_id": compute_instance_id,
                       "vname": variable_vname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMultiVariable.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createMultiVariable', 'method_docs': '[ HTTP: POST /compute/{instance_id}/variable/{vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+} ]', 'result': 'result', 'method_params': [{'name': 'instance_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_instance_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'instance_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_instance_id'}, {'name': 'vname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'variable_vname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(instance_id)s/variable/%(vname: [a-zA-Z]|[a-zA-Z][a-zA-Z0-9_\\-]+)s', 'method_kind': 'POST'}

    @download
    def getVariables(self,
                     compute_id,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /compute/{id}/variable ]

        @param compute_id: compute_id
        @type compute_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVariables.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVariables', 'method_docs': '[ HTTP: GET /compute/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/variable', 'method_kind': 'GET'}

    @download
    def getScriptStatuses(self,
                          compute_id,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /compute/{id}/scriptstatus ]

        @param compute_id: compute_id
        @type compute_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/scriptstatus"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptStatuses.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getScriptStatuses', 'method_docs': '[ HTTP: GET /compute/{id}/scriptstatus ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/scriptstatus', 'method_kind': 'GET'}

    @download
    def updateInstance(self,
                       compute_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateInstance.context = {'query_params': [], 'method_name': 'updateInstance', 'method_docs': '[ HTTP: PUT /compute/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'compute/%(id)s', 'method_kind': 'PUT'}

    @download
    def attachStorage(self,
                      compute_id,
                      attach_storageId=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/storage/attach/{storageId} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param attach_storageId: attach_storageId
        @type attach_storageId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/storage/attach/%(storageId)s"
        path_params = {"id": compute_id,
                       "storageId": attach_storageId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachStorage.context = {'query_params': [], 'method_name': 'attachStorage', 'method_docs': '[ HTTP: POST /compute/{id}/storage/attach/{storageId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'storageId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attach_storageId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'storageId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attach_storageId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/storage/attach/%(storageId)s', 'method_kind': 'POST'}

    @download
    def getScriptStatus(self,
                        compute_id,
                        scriptstatusid=None,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /compute/{id}/scriptstatus/{scriptstatusid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param scriptstatusid: scriptstatusid
        @type scriptstatusid: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/scriptstatus/%(scriptstatusid)s"
        path_params = {"id": compute_id,
                       "scriptstatusid": scriptstatusid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getScriptStatus.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getScriptStatus', 'method_docs': '[ HTTP: GET /compute/{id}/scriptstatus/{scriptstatusid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'scriptstatusid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptstatusid'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'scriptstatusid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'scriptstatusid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/scriptstatus/%(scriptstatusid)s', 'method_kind': 'GET'}

    @download
    def snapshotAllStorage(self,
                           compute_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /compute/{id}/storage/snapshotall ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/storage/snapshotall"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    snapshotAllStorage.context = {'query_params': [], 'method_name': 'snapshotAllStorage', 'method_docs': '[ HTTP: POST /compute/{id}/storage/snapshotall ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/storage/snapshotall', 'method_kind': 'POST'}

    @download
    def hotSwap(self,
                compute_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /compute/{id}/hotswap ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/hotswap"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    hotSwap.context = {'query_params': [], 'method_name': 'hotSwap', 'method_docs': '[ HTTP: POST /compute/{id}/hotswap ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/hotswap', 'method_kind': 'POST'}

    @download
    def createVolume(self,
                     compute_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /compute/{id}/volume ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/volume"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVolume.context = {'query_params': [], 'method_name': 'createVolume', 'method_docs': '[ HTTP: POST /compute/{id}/volume ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'compute/%(id)s/volume', 'method_kind': 'POST'}

    @download
    def createVariable(self,
                       compute_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /compute/{id}/variable ]

        @param compute_id: compute_id
        @type compute_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable"
        path_params = {"id": compute_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVariable.context = {'query_params': [], 'method_name': 'createVariable', 'method_docs': '[ HTTP: POST /compute/{id}/variable ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'compute/%(id)s/variable', 'method_kind': 'POST'}

    @download
    def decryptVariable(self,
                        compute_id,
                        variable_id=None,
                        **kwargs):
        """
        [ HTTP: GET /compute/{id}/variable/{variable_id}/decrypt ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id)s/decrypt"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    decryptVariable.context = {'query_params': [], 'method_name': 'decryptVariable', 'method_docs': '[ HTTP: GET /compute/{id}/variable/{variable_id}/decrypt ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/variable/%(variable_id)s/decrypt', 'method_kind': 'GET'}

    @download
    def updateAlias_2(self,
                      compute_id,
                      alias_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/alias/{alias_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/alias/%(alias_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "alias_id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias_2.context = {'query_params': [], 'method_name': 'updateAlias_2', 'method_docs': '[ HTTP: POST /compute/{id}/alias/{alias_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'alias_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/alias/%(alias_id: [0-9]+)s', 'method_kind': 'POST'}

    @download
    def executeScript(self,
                      compute_id,
                      execute_scriptid=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /compute/{id}/execute/{scriptid} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param execute_scriptid: execute_scriptid
        @type execute_scriptid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/execute/%(scriptid)s"
        path_params = {"id": compute_id,
                       "scriptid": execute_scriptid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    executeScript.context = {'query_params': [], 'method_name': 'executeScript', 'method_docs': '[ HTTP: POST /compute/{id}/execute/{scriptid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'execute_scriptid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'scriptid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'execute_scriptid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'compute/%(id)s/execute/%(scriptid)s', 'method_kind': 'POST'}

    @download
    def updateVariable(self,
                       compute_id,
                       variable_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /compute/{id}/variable/{variable_id: [0-9]+} ]

        @param compute_id: compute_id
        @type compute_id: str
        @param variable_id: variable_id
        @type variable_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "compute/%(id)s/variable/%(variable_id: [0-9]+)s"
        path_params = {"id": compute_id,
                       "variable_id": variable_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateVariable.context = {'query_params': [], 'method_name': 'updateVariable', 'method_docs': '[ HTTP: PUT /compute/{id}/variable/{variable_id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'compute_id'}, {'name': 'variable_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'variable_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'compute/%(id)s/variable/%(variable_id: [0-9]+)s', 'method_kind': 'PUT'}

class serviceprovider(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /serviceprovider/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /serviceprovider/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /serviceprovider/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /serviceprovider/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceprovider/import', 'method_kind': 'PUT'}

    @download
    def deleteServiceProvider(self,
                              serviceprovider_id=None,
                              release=None,
                              **kwargs):
        """
        [ HTTP: DELETE /serviceprovider/{id: [0-9]+} ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param release: release
        @type release: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"release": release}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteServiceProvider.context = {'query_params': [{'name': 'release', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'release'}], 'method_name': 'deleteServiceProvider', 'method_docs': '[ HTTP: DELETE /serviceprovider/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovider_id'}, {'name': 'release', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'release'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s', 'method_kind': 'DELETE'}

    @download
    def synchronize(self,
                    serviceprovider_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /serviceprovider/{id: [0-9]+}/sync ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s/sync"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    synchronize.context = {'query_params': [], 'method_name': 'synchronize', 'method_docs': '[ HTTP: POST /serviceprovider/{id: [0-9]+}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s/sync', 'method_kind': 'POST'}

    @download
    def searchProviders(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /serviceprovider/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProviders.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchProviders', 'method_docs': '[ HTTP: GET /serviceprovider/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/search', 'method_kind': 'GET'}

    @download
    def stop(self,
             serviceprovider_id,
             data=None,
             **kwargs):
        """
        [ HTTP: POST /serviceprovider/{id: [0-9]+}/stop ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s/stop"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stop.context = {'query_params': [], 'method_name': 'stop', 'method_docs': '[ HTTP: POST /serviceprovider/{id: [0-9]+}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s/stop', 'method_kind': 'POST'}

    @download
    def testConnection(self,
                       serviceprovider_id,
                       **kwargs):
        """
        [ HTTP: GET /serviceprovider/{id: [0-9]+}/ping ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s/ping"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    testConnection.context = {'query_params': [], 'method_name': 'testConnection', 'method_docs': '[ HTTP: GET /serviceprovider/{id: [0-9]+}/ping ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s/ping', 'method_kind': 'GET'}

    @download
    def start(self,
              serviceprovider_id,
              data=None,
              **kwargs):
        """
        [ HTTP: POST /serviceprovider/{id: [0-9]+}/start ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s/start"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    start.context = {'query_params': [], 'method_name': 'start', 'method_docs': '[ HTTP: POST /serviceprovider/{id: [0-9]+}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s/start', 'method_kind': 'POST'}

    @download
    def getServiceProviders(self,
                            fields=None,
                            typeId=None,
                            **kwargs):
        """
        [ HTTP: GET /serviceprovider ]

        @param fields: fields
        @type fields: str
        @param typeId: typeId
        @type typeId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "typeId": typeId}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceProviders.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'typeId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'typeId'}], 'method_name': 'getServiceProviders', 'method_docs': '[ HTTP: GET /serviceprovider ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'typeId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'typeId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /serviceprovider/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /serviceprovider/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'serviceprovider/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     serviceprovider_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /serviceprovider/{id}/export ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id)s/export"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /serviceprovider/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getServiceProvider(self,
                           serviceprovider_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /serviceprovider/{id: [0-9]+} ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceProvider.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getServiceProvider', 'method_docs': '[ HTTP: GET /serviceprovider/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovider_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def updateServiceProvider(self,
                              serviceprovider_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /serviceprovider/{id: [0-9]+} ]

        @param serviceprovider_id: serviceprovider_id
        @type serviceprovider_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider/%(id: [0-9]+)s"
        path_params = {"id": serviceprovider_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateServiceProvider.context = {'query_params': [], 'method_name': 'updateServiceProvider', 'method_docs': '[ HTTP: PUT /serviceprovider/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovider_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceprovider_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceprovider/%(id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def createServiceProvider(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /serviceprovider ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceprovider"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createServiceProvider.context = {'query_params': [], 'method_name': 'createServiceProvider', 'method_docs': '[ HTTP: POST /serviceprovider ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceprovider', 'method_kind': 'POST'}

class variable(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def inputVariables(self,
                       fields=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /variable ]

        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "variable"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    inputVariables.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'inputVariables', 'method_docs': '[ HTTP: PUT /variable ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'variable', 'method_kind': 'PUT'}

    @download
    def UpdateEvent(self,
                    fields=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /variable/updateevent ]

        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "variable/updateevent"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    UpdateEvent.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'UpdateEvent', 'method_docs': '[ HTTP: PUT /variable/updateevent ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'variable/updateevent', 'method_kind': 'PUT'}

class globals(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def exportContainerRights(self,
                              security_id,
                              exportOpts=None,
                              **kwargs):
        """
        [ HTTP: GET /global/security/{security_id}/export ]

        @param security_id: security_id
        @type security_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/export"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportContainerRights.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportContainerRights', 'method_docs': '[ HTTP: GET /global/security/{security_id}/export ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/export', 'method_kind': 'GET'}

    @download
    def addSecurity(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /global/security ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'method_name': 'addSecurity', 'method_docs': '[ HTTP: POST /global/security ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'global/security', 'method_kind': 'POST'}

    @download
    def deleteSecurity(self,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id} ]

        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'method_name': 'deleteSecurity', 'method_docs': '[ HTTP: DELETE /global/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s', 'method_kind': 'DELETE'}

    @download
    def addSecurityAccessRight(self,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/rights/{rights_id}/accessright ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'method_name': 'addSecurityAccessRight', 'method_docs': '[ HTTP: POST /global/security/{security_id}/rights/{rights_id}/accessright ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s/accessright', 'method_kind': 'POST'}

    @download
    def deleteSecurityUserGroup(self,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/usergroup/{usergroup_id} ]

        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'method_name': 'deleteSecurityUserGroup', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/usergroup/{usergroup_id} ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/usergroup/%(usergroup_id)s', 'method_kind': 'DELETE'}

    @download
    def getSecurity(self,
                    security_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /global/security/{security_id} ]

        @param security_id: security_id
        @type security_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSecurity', 'method_docs': '[ HTTP: GET /global/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s', 'method_kind': 'GET'}

    @download
    def deleteSecurityRights(self,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/rights/{rights_id} ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'method_name': 'deleteSecurityRights', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/rights/{rights_id} ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s', 'method_kind': 'DELETE'}

    @download
    def addSecurityRights(self,
                          security_id,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/rights ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'method_name': 'addSecurityRights', 'method_docs': '[ HTTP: POST /global/security/{security_id}/rights ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/rights', 'method_kind': 'POST'}

    @download
    def addSecurityUser(self,
                        security_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/user ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/user"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'method_name': 'addSecurityUser', 'method_docs': '[ HTTP: POST /global/security/{security_id}/user ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/user', 'method_kind': 'POST'}

    @download
    def deleteSecurityUser(self,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/user/{user_id} ]

        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/user/%(user_id)s"
        path_params = {"security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'method_name': 'deleteSecurityUser', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/user/{user_id} ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/user/%(user_id)s', 'method_kind': 'DELETE'}

    @download
    def getGlobalContainer(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /global/container ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/container"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getGlobalContainer.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getGlobalContainer', 'method_docs': '[ HTTP: GET /global/container ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/container', 'method_kind': 'GET'}

    @download
    def clearStatsCache(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /global/cache/statsclear ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/cache/statsclear"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clearStatsCache.context = {'query_params': [], 'method_name': 'clearStatsCache', 'method_docs': '[ HTTP: POST /global/cache/statsclear ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/cache/statsclear', 'method_kind': 'POST'}

    @download
    def importContainerRights(self,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: PUT /global/security/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importContainerRights.context = {'query_params': [], 'method_name': 'importContainerRights', 'method_docs': '[ HTTP: PUT /global/security/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'global/security/import', 'method_kind': 'PUT'}

    @download
    def addSecurityUserGroup(self,
                             security_id,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /global/security/{security_id}/usergroup ]

        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/usergroup"
        path_params = {"security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'method_name': 'addSecurityUserGroup', 'method_docs': '[ HTTP: POST /global/security/{security_id}/usergroup ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/usergroup', 'method_kind': 'POST'}

    @download
    def deleteSecurityAccessRight(self,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /global/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "global/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'method_name': 'deleteSecurityAccessRight', 'method_docs': '[ HTTP: DELETE /global/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'result': 'result', 'method_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'global/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'method_kind': 'DELETE'}

class volumestoragesnapshot(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createVolumeStorgeFromSnapshot(self,
                                       volumestoragesnapshot_id,
                                       data=None,
                                       **kwargs):
        """
        [ HTTP: POST /volumestoragesnapshot/{id}/createvolumestorage ]

        @param volumestoragesnapshot_id: volumestoragesnapshot_id
        @type volumestoragesnapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestoragesnapshot/%(id)s/createvolumestorage"
        path_params = {"id": volumestoragesnapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createVolumeStorgeFromSnapshot.context = {'query_params': [], 'method_name': 'createVolumeStorgeFromSnapshot', 'method_docs': '[ HTTP: POST /volumestoragesnapshot/{id}/createvolumestorage ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestoragesnapshot_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestoragesnapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestoragesnapshot/%(id)s/createvolumestorage', 'method_kind': 'POST'}

    @download
    def getVolumeStorageSnapshotSnapshotXML(self,
                                            fields=None,
                                            **kwargs):
        """
        [ HTTP: GET /volumestoragesnapshot ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestoragesnapshot"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumeStorageSnapshotSnapshotXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolumeStorageSnapshotSnapshotXML', 'method_docs': '[ HTTP: GET /volumestoragesnapshot ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestoragesnapshot', 'method_kind': 'GET'}

    @download
    def getVolumeStorageSnapshot(self,
                                 volumestoragesnapshot_id=None,
                                 fields=None,
                                 **kwargs):
        """
        [ HTTP: GET /volumestoragesnapshot/{id} ]

        @param volumestoragesnapshot_id: volumestoragesnapshot_id
        @type volumestoragesnapshot_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestoragesnapshot/%(id)s"
        path_params = {"id": volumestoragesnapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumeStorageSnapshot.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolumeStorageSnapshot', 'method_docs': '[ HTTP: GET /volumestoragesnapshot/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volumestoragesnapshot_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volumestoragesnapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestoragesnapshot/%(id)s', 'method_kind': 'GET'}

class networkservice(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /networkservice/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /networkservice/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservice/export', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /networkservice/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /networkservice/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'networkservice/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     networkservice_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /networkservice/{id}/export ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id)s/export"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /networkservice/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'networkservice_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'networkservice_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservice/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /networkservice/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /networkservice/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'networkservice/import', 'method_kind': 'PUT'}

    @download
    def getNetworkServices(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /networkservice ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServices.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkServices', 'method_docs': '[ HTTP: GET /networkservice ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservice', 'method_kind': 'GET'}

    @download
    def updateNetworkService(self,
                             networkservice_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /networkservice/{id: [0-9]+} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id: [0-9]+)s"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNetworkService.context = {'query_params': [], 'method_name': 'updateNetworkService', 'method_docs': '[ HTTP: PUT /networkservice/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservice_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservice_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'networkservice/%(id: [0-9]+)s', 'method_kind': 'PUT'}

    @download
    def getNetworkServicesByType(self,
                                 networkservice_type=None,
                                 **kwargs):
        """
        [ HTTP: GET /networkservice/{type: [^0-9]\w+} ]

        @param networkservice_type: networkservice_type
        @type networkservice_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(type: [^0-9]\w+)s"
        path_params = {"type": networkservice_type}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServicesByType.context = {'query_params': [], 'method_name': 'getNetworkServicesByType', 'method_docs': '[ HTTP: GET /networkservice/{type: [^0-9]\\w+} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'networkservice_type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'networkservice_type'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservice/%(type: [^0-9]\\w+)s', 'method_kind': 'GET'}

    @download
    def getNetworkService(self,
                          networkservice_id=None,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /networkservice/{id: [0-9]+} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id: [0-9]+)s"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkService.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkService', 'method_docs': '[ HTTP: GET /networkservice/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservice_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservice_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservice/%(id: [0-9]+)s', 'method_kind': 'GET'}

    @download
    def deleteNetworkService(self,
                             networkservice_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /networkservice/{id: [0-9]+} ]

        @param networkservice_id: networkservice_id
        @type networkservice_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservice/%(id: [0-9]+)s"
        path_params = {"id": networkservice_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetworkService.context = {'query_params': [], 'method_name': 'deleteNetworkService', 'method_docs': '[ HTTP: DELETE /networkservice/{id: [0-9]+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservice_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservice_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservice/%(id: [0-9]+)s', 'method_kind': 'DELETE'}

class targetcloud(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTargetCloudsXML(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /targetcloud ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "targetcloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTargetCloudsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTargetCloudsXML', 'method_docs': '[ HTTP: GET /targetcloud ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'targetcloud', 'method_kind': 'GET'}

    @download
    def getTargetCloud(self,
                       targetcloud_id=None,
                       **kwargs):
        """
        [ HTTP: GET /targetcloud/{id} ]

        @param targetcloud_id: targetcloud_id
        @type targetcloud_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "targetcloud/%(id)s"
        path_params = {"id": targetcloud_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTargetCloud.context = {'query_params': [], 'method_name': 'getTargetCloud', 'method_docs': '[ HTTP: GET /targetcloud/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'targetcloud_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'targetcloud_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'targetcloud/%(id)s', 'method_kind': 'GET'}

class networkinterface(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getNetwork(self,
                   networkinterface_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /networkinterface/{id} ]

        @param networkinterface_id: networkinterface_id
        @type networkinterface_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkinterface/%(id)s"
        path_params = {"id": networkinterface_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetwork.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetwork', 'method_docs': '[ HTTP: GET /networkinterface/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkinterface_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkinterface_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkinterface/%(id)s', 'method_kind': 'GET'}

class router(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateRouter(self,
                     router_id=None,
                     fields=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /router/{id} ]

        @param router_id: router_id
        @type router_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/%(id)s"
        path_params = {"id": router_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRouter.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateRouter', 'method_docs': '[ HTTP: PUT /router/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'router_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'router_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'router/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchRouters(self,
                      containerId=None,
                      fields=None,
                      filterGroup=None,
                      limit=None,
                      offset=None,
                      orderBy=None,
                      qterm=None,
                      usage=None,
                      **kwargs):
        """
        [ HTTP: GET /router/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchRouters.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchRouters', 'method_docs': '[ HTTP: GET /router/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'router/search', 'method_kind': 'GET'}

    @download
    def getRoutersXML(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /router ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRoutersXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRoutersXML', 'method_docs': '[ HTTP: GET /router ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'router', 'method_kind': 'GET'}

    @download
    def syncRouter(self,
                   router_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /router/{id}/sync ]

        @param router_id: router_id
        @type router_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/%(id)s/sync"
        path_params = {"id": router_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncRouter.context = {'query_params': [], 'method_name': 'syncRouter', 'method_docs': '[ HTTP: POST /router/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'router_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'router_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'router/%(id)s/sync', 'method_kind': 'POST'}

    @download
    def addRouterInterface(self,
                           router_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /router/{id}/interface ]

        @param router_id: router_id
        @type router_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/%(id)s/interface"
        path_params = {"id": router_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addRouterInterface.context = {'query_params': [], 'method_name': 'addRouterInterface', 'method_docs': '[ HTTP: POST /router/{id}/interface ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'router_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'router_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'router/%(id)s/interface', 'method_kind': 'POST'}

    @download
    def deleteRouterInterface(self,
                              router_id,
                              interfaceId=None,
                              **kwargs):
        """
        [ HTTP: DELETE /router/{id}/interface/{interfaceId} ]

        @param router_id: router_id
        @type router_id: str
        @param interfaceId: interfaceId
        @type interfaceId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/%(id)s/interface/%(interfaceId)s"
        path_params = {"id": router_id,
                       "interfaceId": interfaceId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteRouterInterface.context = {'query_params': [], 'method_name': 'deleteRouterInterface', 'method_docs': '[ HTTP: DELETE /router/{id}/interface/{interfaceId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'router_id'}, {'name': 'interfaceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'interfaceId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'router_id'}, {'name': 'interfaceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'interfaceId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'router/%(id)s/interface/%(interfaceId)s', 'method_kind': 'DELETE'}

    @download
    def getRouter(self,
                  router_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /router/{id} ]

        @param router_id: router_id
        @type router_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/%(id)s"
        path_params = {"id": router_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRouter.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRouter', 'method_docs': '[ HTTP: GET /router/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'router_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'router_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'router/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteRouter(self,
                     router_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /router/{id} ]

        @param router_id: router_id
        @type router_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "router/%(id)s"
        path_params = {"id": router_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteRouter.context = {'query_params': [], 'method_name': 'deleteRouter', 'method_docs': '[ HTTP: DELETE /router/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'router_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'router_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'router/%(id)s', 'method_kind': 'DELETE'}

class task(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def completeTask(self,
                     task_id,
                     complete_workItemId=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /task/{id}/complete/{workItemId} ]

        @param task_id: task_id
        @type task_id: str
        @param complete_workItemId: complete_workItemId
        @type complete_workItemId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/complete/%(workItemId)s"
        path_params = {"id": task_id,
                       "workItemId": complete_workItemId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    completeTask.context = {'query_params': [], 'method_name': 'completeTask', 'method_docs': '[ HTTP: POST /task/{id}/complete/{workItemId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'workItemId', 'defaultValue': None, 'kind': 'xs:long', 'required': False, 'alias': 'complete_workItemId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'workItemId', 'defaultValue': None, 'kind': 'xs:long', 'required': False, 'alias': 'complete_workItemId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/%(id)s/complete/%(workItemId)s', 'method_kind': 'POST'}

    @download
    def getTasksXML(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /task ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTasksXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTasksXML', 'method_docs': '[ HTTP: GET /task ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task', 'method_kind': 'GET'}

    @download
    def resumeTask(self,
                   task_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /task/{id}/resume ]

        @param task_id: task_id
        @type task_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/resume"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    resumeTask.context = {'query_params': [], 'method_name': 'resumeTask', 'method_docs': '[ HTTP: POST /task/{id}/resume ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/%(id)s/resume', 'method_kind': 'POST'}

    @download
    def getTaskChildren(self,
                        task_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /task/{id}/task ]

        @param task_id: task_id
        @type task_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/task"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTaskChildren.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTaskChildren', 'method_docs': '[ HTTP: GET /task/{id}/task ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/%(id)s/task', 'method_kind': 'GET'}

    @download
    def getTask(self,
                task_id=None,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /task/{id} ]

        @param task_id: task_id
        @type task_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTask.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTask', 'method_docs': '[ HTTP: GET /task/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'task_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/%(id)s', 'method_kind': 'GET'}

    @download
    def searchTopTasks(self,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /task/search/top ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/search/top"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTopTasks.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchTopTasks', 'method_docs': '[ HTTP: GET /task/search/top ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/search/top', 'method_kind': 'GET'}

    @download
    def signalTask(self,
                   task_id,
                   signal_event=None,
                   eventValue=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /task/{id}/signal/{event} ]

        @param task_id: task_id
        @type task_id: str
        @param signal_event: signal_event
        @type signal_event: str
        @param eventValue: eventValue
        @type eventValue: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/signal/%(event)s"
        path_params = {"id": task_id,
                       "event": signal_event}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"eventValue": eventValue}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    signalTask.context = {'query_params': [{'name': 'eventValue', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'eventValue'}], 'method_name': 'signalTask', 'method_docs': '[ HTTP: POST /task/{id}/signal/{event} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'event', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'signal_event'}, {'name': 'eventValue', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'eventValue'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'event', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'signal_event'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/%(id)s/signal/%(event)s', 'method_kind': 'POST'}

    @download
    def getOptions(self,
                   Access_Control_Request_Headers=None,
                   **kwargs):
        """
        [ HTTP: OPTIONS /task ]

        @param Access_Control_Request_Headers: Access_Control_Request_Headers
        @type Access_Control_Request_Headers: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"Access_Control_Request_Headers": Access_Control_Request_Headers}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("OPTIONS", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOptions.context = {'query_params': [{'name': 'Access_Control_Request_Headers', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'Access_Control_Request_Headers'}], 'method_name': 'getOptions', 'method_docs': '[ HTTP: OPTIONS /task ]', 'result': 'result', 'method_params': [{'name': 'Access_Control_Request_Headers', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'Access_Control_Request_Headers'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task', 'method_kind': 'OPTIONS'}

    @download
    def cancelTask(self,
                   task_id,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /task/{id}/cancel ]

        @param task_id: task_id
        @type task_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "task/%(id)s/cancel"
        path_params = {"id": task_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    cancelTask.context = {'query_params': [], 'method_name': 'cancelTask', 'method_docs': '[ HTTP: POST /task/{id}/cancel ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'task_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'task/%(id)s/cancel', 'method_kind': 'POST'}

class volumestorage(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createSnapshot(self,
                       volumestorage_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /volumestorage/{id}/snapshot ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot"
        path_params = {"id": volumestorage_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createSnapshot.context = {'query_params': [], 'method_name': 'createSnapshot', 'method_docs': '[ HTTP: POST /volumestorage/{id}/snapshot ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'volumestorage/%(id)s/snapshot', 'method_kind': 'POST'}

    @download
    def getVolumeStoragesXML(self,
                             fields=None,
                             **kwargs):
        """
        [ HTTP: GET /volumestorage ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumeStoragesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolumeStoragesXML', 'method_docs': '[ HTTP: GET /volumestorage ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestorage', 'method_kind': 'GET'}

    @download
    def getVolumeStorage(self,
                         volumestorage_id=None,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /volumestorage/{id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s"
        path_params = {"id": volumestorage_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getVolumeStorage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getVolumeStorage', 'method_docs': '[ HTTP: GET /volumestorage/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volumestorage_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'volumestorage_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestorage/%(id)s', 'method_kind': 'GET'}

    @download
    def getSnapshot(self,
                    volumestorage_id,
                    snapshot_id=None,
                    **kwargs):
        """
        [ HTTP: GET /volumestorage/{id}/snapshot/{snapshot_id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": volumestorage_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSnapshot.context = {'query_params': [], 'method_name': 'getSnapshot', 'method_docs': '[ HTTP: GET /volumestorage/{id}/snapshot/{snapshot_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestorage/%(id)s/snapshot/%(snapshot_id)s', 'method_kind': 'GET'}

    @download
    def deleteSnapshot(self,
                       volumestorage_id,
                       snapshot_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /volumestorage/{id}/snapshot/{snapshot_id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": volumestorage_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSnapshot.context = {'query_params': [], 'method_name': 'deleteSnapshot', 'method_docs': '[ HTTP: DELETE /volumestorage/{id}/snapshot/{snapshot_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestorage/%(id)s/snapshot/%(snapshot_id)s', 'method_kind': 'DELETE'}

    @download
    def revertSnapshot(self,
                       volumestorage_id,
                       snapshot_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /volumestorage/{id}/snapshot/{snapshot_id} ]

        @param volumestorage_id: volumestorage_id
        @type volumestorage_id: str
        @param snapshot_id: snapshot_id
        @type snapshot_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "volumestorage/%(id)s/snapshot/%(snapshot_id)s"
        path_params = {"id": volumestorage_id,
                       "snapshot_id": snapshot_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    revertSnapshot.context = {'query_params': [], 'method_name': 'revertSnapshot', 'method_docs': '[ HTTP: PUT /volumestorage/{id}/snapshot/{snapshot_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'volumestorage_id'}, {'name': 'snapshot_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'snapshot_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'volumestorage/%(id)s/snapshot/%(snapshot_id)s', 'method_kind': 'PUT'}

class storeproducttype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchProductTypes(self,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /storeproducttype/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProductTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchProductTypes', 'method_docs': '[ HTTP: GET /storeproducttype/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproducttype/search', 'method_kind': 'GET'}

    @download
    def getProductType(self,
                       storeproducttype_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /storeproducttype/{id} ]

        @param storeproducttype_id: storeproducttype_id
        @type storeproducttype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/%(id)s"
        path_params = {"id": storeproducttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProductType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProductType', 'method_docs': '[ HTTP: GET /storeproducttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproducttype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproducttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproducttype/%(id)s', 'method_kind': 'GET'}

    @download
    def createProductType(self,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /storeproducttype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProductType.context = {'query_params': [], 'method_name': 'createProductType', 'method_docs': '[ HTTP: POST /storeproducttype ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storeproducttype', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     storeproducttype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storeproducttype/{id}/export ]

        @param storeproducttype_id: storeproducttype_id
        @type storeproducttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/%(id)s/export"
        path_params = {"id": storeproducttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /storeproducttype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeproducttype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeproducttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproducttype/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storeproducttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /storeproducttype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproducttype/export', 'method_kind': 'GET'}

    @download
    def getProductAdapterItems(self,
                               storeproducttype_ptype,
                               **kwargs):
        """
        [ HTTP: GET /storeproducttype/{ptype}/products ]

        @param storeproducttype_ptype: storeproducttype_ptype
        @type storeproducttype_ptype: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype/%(ptype)s/products"
        path_params = {"ptype": storeproducttype_ptype}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProductAdapterItems.context = {'query_params': [], 'method_name': 'getProductAdapterItems', 'method_docs': '[ HTTP: GET /storeproducttype/{ptype}/products ]', 'result': 'result', 'method_params': [{'name': 'ptype', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'storeproducttype_ptype'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'ptype', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'storeproducttype_ptype'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproducttype/%(ptype)s/products', 'method_kind': 'GET'}

    @download
    def getProductTypes(self,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /storeproducttype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproducttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProductTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProductTypes', 'method_docs': '[ HTTP: GET /storeproducttype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproducttype', 'method_kind': 'GET'}

class configuration_repository(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createRepository(self,
                         fields=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /configuration/repository ]

        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRepository.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createRepository', 'method_docs': '[ HTTP: POST /configuration/repository ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/repository', 'method_kind': 'POST'}

    @download
    def syncRepository(self,
                       repository_id,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /configuration/repository/{id}/sync ]

        @param repository_id: repository_id
        @type repository_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s/sync"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncRepository.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'syncRepository', 'method_docs': '[ HTTP: GET /configuration/repository/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository/%(id)s/sync', 'method_kind': 'GET'}

    @download
    def updateRepository(self,
                         repository_id=None,
                         fields=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /configuration/repository/{id} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateRepository.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateRepository', 'method_docs': '[ HTTP: PUT /configuration/repository/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/repository/%(id)s', 'method_kind': 'PUT'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /configuration/repository/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'configuration/repository/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     repository_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/repository/{id}/export ]

        @param repository_id: repository_id
        @type repository_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s/export"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /configuration/repository/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/repository/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /configuration/repository/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/repository/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/repository/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /configuration/repository/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository/export', 'method_kind': 'GET'}

    @download
    def searchRepositories(self,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /configuration/repository/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchRepositories.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchRepositories', 'method_docs': '[ HTTP: GET /configuration/repository/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository/search', 'method_kind': 'GET'}

    @download
    def getRepository(self,
                      repository_id=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /configuration/repository/{id} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepository.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRepository', 'method_docs': '[ HTTP: GET /configuration/repository/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteConfigurationRepository(self,
                                      repository_id=None,
                                      **kwargs):
        """
        [ HTTP: DELETE /configuration/repository/{id} ]

        @param repository_id: repository_id
        @type repository_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository/%(id)s"
        path_params = {"id": repository_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteConfigurationRepository.context = {'query_params': [], 'method_name': 'deleteConfigurationRepository', 'method_docs': '[ HTTP: DELETE /configuration/repository/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'repository_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getRepositories(self,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /configuration/repository ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/repository"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRepositories.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRepositories', 'method_docs': '[ HTTP: GET /configuration/repository ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/repository', 'method_kind': 'GET'}

class projectrole(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createProjectRole(self,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /projectrole ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProjectRole.context = {'query_params': [], 'method_name': 'createProjectRole', 'method_docs': '[ HTTP: POST /projectrole ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projectrole', 'method_kind': 'POST'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /projectrole/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /projectrole/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'projectrole/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     projectrole_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /projectrole/{id}/export ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s/export"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /projectrole/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projectrole_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'projectrole_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projectrole/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /projectrole/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /projectrole/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projectrole/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /projectrole/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /projectrole/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projectrole/export', 'method_kind': 'GET'}

    @download
    def updateProjectRole(self,
                          projectrole_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: PUT /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateProjectRole.context = {'query_params': [], 'method_name': 'updateProjectRole', 'method_docs': '[ HTTP: PUT /projectrole/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projectrole_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projectrole_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'projectrole/%(id)s', 'method_kind': 'PUT'}

    @download
    def getProjectRole(self,
                       projectrole_id=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjectRole.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProjectRole', 'method_docs': '[ HTTP: GET /projectrole/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projectrole_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projectrole_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projectrole/%(id)s', 'method_kind': 'GET'}

    @download
    def getProjectRolesXML(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /projectrole ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjectRolesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProjectRolesXML', 'method_docs': '[ HTTP: GET /projectrole ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projectrole', 'method_kind': 'GET'}

    @download
    def searchRoles(self,
                    fields=None,
                    filterGroup=None,
                    limit=None,
                    offset=None,
                    orderBy=None,
                    usage=None,
                    **kwargs):
        """
        [ HTTP: GET /projectrole/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchRoles.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchRoles', 'method_docs': '[ HTTP: GET /projectrole/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projectrole/search', 'method_kind': 'GET'}

    @download
    def deleteProjectRole(self,
                          projectrole_id=None,
                          **kwargs):
        """
        [ HTTP: DELETE /projectrole/{id} ]

        @param projectrole_id: projectrole_id
        @type projectrole_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "projectrole/%(id)s"
        path_params = {"id": projectrole_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteProjectRole.context = {'query_params': [], 'method_name': 'deleteProjectRole', 'method_docs': '[ HTTP: DELETE /projectrole/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projectrole_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'projectrole_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'projectrole/%(id)s', 'method_kind': 'DELETE'}

class usergroup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def addUser(self,
                usergroup_id,
                userid=None,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /usergroup/{id}/user/{userid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param userid: userid
        @type userid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/user/%(userid)s"
        path_params = {"id": usergroup_id,
                       "userid": userid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addUser.context = {'query_params': [], 'method_name': 'addUser', 'method_docs': '[ HTTP: PUT /usergroup/{id}/user/{userid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'userid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'userid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'userid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'userid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s/user/%(userid)s', 'method_kind': 'PUT'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /usergroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /usergroup/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'usergroup/import', 'method_kind': 'PUT'}

    @download
    def addUserGroup(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /usergroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addUserGroup.context = {'query_params': [], 'method_name': 'addUserGroup', 'method_docs': '[ HTTP: POST /usergroup ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'usergroup', 'method_kind': 'POST'}

    @download
    def getUserGroup(self,
                     usergroup_id=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUserGroup.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getUserGroup', 'method_docs': '[ HTTP: GET /usergroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s', 'method_kind': 'GET'}

    @download
    def getUserGroupsXML(self,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /usergroup ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUserGroupsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getUserGroupsXML', 'method_docs': '[ HTTP: GET /usergroup ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup', 'method_kind': 'GET'}

    @download
    def deleteUser(self,
                   usergroup_id,
                   userid=None,
                   **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id}/user/{userid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param userid: userid
        @type userid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/user/%(userid)s"
        path_params = {"id": usergroup_id,
                       "userid": userid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteUser.context = {'query_params': [], 'method_name': 'deleteUser', 'method_docs': '[ HTTP: DELETE /usergroup/{id}/user/{userid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'userid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'userid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'userid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'userid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s/user/%(userid)s', 'method_kind': 'DELETE'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /usergroup/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /usergroup/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'usergroup/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     usergroup_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /usergroup/{id}/export ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/export"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /usergroup/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s/export', 'method_kind': 'GET'}

    @download
    def addSubGroup(self,
                    usergroup_id,
                    group_subid=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /usergroup/{id}/group/{subid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param group_subid: group_subid
        @type group_subid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/group/%(subid)s"
        path_params = {"id": usergroup_id,
                       "subid": group_subid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSubGroup.context = {'query_params': [], 'method_name': 'addSubGroup', 'method_docs': '[ HTTP: PUT /usergroup/{id}/group/{subid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'subid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'group_subid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'subid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'group_subid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s/group/%(subid)s', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /usergroup/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /usergroup/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/export', 'method_kind': 'GET'}

    @download
    def updateUserGroup(self,
                        usergroup_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateUserGroup.context = {'query_params': [], 'method_name': 'updateUserGroup', 'method_docs': '[ HTTP: PUT /usergroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'usergroup/%(id)s', 'method_kind': 'PUT'}

    @download
    def delSubGroup(self,
                    usergroup_id,
                    group_subid=None,
                    **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id}/group/{subid} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param group_subid: group_subid
        @type group_subid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s/group/%(subid)s"
        path_params = {"id": usergroup_id,
                       "subid": group_subid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    delSubGroup.context = {'query_params': [], 'method_name': 'delSubGroup', 'method_docs': '[ HTTP: DELETE /usergroup/{id}/group/{subid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'subid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'group_subid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'usergroup_id'}, {'name': 'subid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'group_subid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s/group/%(subid)s', 'method_kind': 'DELETE'}

    @download
    def deleteUserGroup(self,
                        usergroup_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /usergroup/{id} ]

        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/%(id)s"
        path_params = {"id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteUserGroup.context = {'query_params': [], 'method_name': 'deleteUserGroup', 'method_docs': '[ HTTP: DELETE /usergroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchUserGroups(self,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /usergroup/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "usergroup/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchUserGroups.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchUserGroups', 'method_docs': '[ HTTP: GET /usergroup/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'usergroup/search', 'method_kind': 'GET'}

class storecatalog(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createCatalog(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /storecatalog ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createCatalog.context = {'query_params': [], 'method_name': 'createCatalog', 'method_docs': '[ HTTP: POST /storecatalog ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storecatalog', 'method_kind': 'POST'}

    @download
    def deleteCatalog(self,
                      storecatalog_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /storecatalog/{id} ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCatalog.context = {'query_params': [], 'method_name': 'deleteCatalog', 'method_docs': '[ HTTP: DELETE /storecatalog/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecatalog_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/%(id)s', 'method_kind': 'DELETE'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /storecatalog/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /storecatalog/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/export', 'method_kind': 'GET'}

    @download
    def getCatalogs(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /storecatalog ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCatalogs.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCatalogs', 'method_docs': '[ HTTP: GET /storecatalog ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog', 'method_kind': 'GET'}

    @download
    def updateCatalog(self,
                      storecatalog_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /storecatalog/{id} ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCatalog.context = {'query_params': [], 'method_name': 'updateCatalog', 'method_docs': '[ HTTP: PUT /storecatalog/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecatalog_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storecatalog/%(id)s', 'method_kind': 'PUT'}

    @download
    def getAuthorizedUsers(self,
                           storecatalog_id,
                           **kwargs):
        """
        [ HTTP: GET /storecatalog/{id}/security ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/security"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAuthorizedUsers.context = {'query_params': [], 'method_name': 'getAuthorizedUsers', 'method_docs': '[ HTTP: GET /storecatalog/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/%(id)s/security', 'method_kind': 'GET'}

    @download
    def searchCatalogs(self,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /storecatalog/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCatalogs.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCatalogs', 'method_docs': '[ HTTP: GET /storecatalog/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/search', 'method_kind': 'GET'}

    @download
    def getProductsList(self,
                        storecatalog_id,
                        **kwargs):
        """
        [ HTTP: GET /storecatalog/{id}/products ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/products"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProductsList.context = {'query_params': [], 'method_name': 'getProductsList', 'method_docs': '[ HTTP: GET /storecatalog/{id}/products ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/%(id)s/products', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     storecatalog_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /storecatalog/{id}/export ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/export"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /storecatalog/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getCatalog(self,
                   storecatalog_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /storecatalog/{id} ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCatalog.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCatalog', 'method_docs': '[ HTTP: GET /storecatalog/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecatalog_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storecatalog/%(id)s', 'method_kind': 'GET'}

    @download
    def setAuthorizedUsers(self,
                           storecatalog_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /storecatalog/{id}/security ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/security"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setAuthorizedUsers.context = {'query_params': [], 'method_name': 'setAuthorizedUsers', 'method_docs': '[ HTTP: PUT /storecatalog/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storecatalog/%(id)s/security', 'method_kind': 'PUT'}

    @download
    def setProductsList(self,
                        storecatalog_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /storecatalog/{id}/products ]

        @param storecatalog_id: storecatalog_id
        @type storecatalog_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storecatalog/%(id)s/products"
        path_params = {"id": storecatalog_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setProductsList.context = {'query_params': [], 'method_name': 'setProductsList', 'method_docs': '[ HTTP: PUT /storecatalog/{id}/products ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storecatalog_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storecatalog/%(id)s/products', 'method_kind': 'PUT'}

class networkservicetype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateNetworkServiceType(self,
                                 networkservicetype_id=None,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: PUT /networkservicetype/{id: \d+} ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id: \d+)s"
        path_params = {"id": networkservicetype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNetworkServiceType.context = {'query_params': [], 'method_name': 'updateNetworkServiceType', 'method_docs': '[ HTTP: PUT /networkservicetype/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservicetype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservicetype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'networkservicetype/%(id: \\d+)s', 'method_kind': 'PUT'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /networkservicetype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /networkservicetype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'networkservicetype/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     networkservicetype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /networkservicetype/{id}/export ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id)s/export"
        path_params = {"id": networkservicetype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /networkservicetype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'networkservicetype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'networkservicetype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservicetype/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /networkservicetype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /networkservicetype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'networkservicetype/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /networkservicetype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /networkservicetype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservicetype/export', 'method_kind': 'GET'}

    @download
    def deleteNetworkServiceType(self,
                                 networkservicetype_id=None,
                                 **kwargs):
        """
        [ HTTP: DELETE /networkservicetype/{id: \d+} ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id: \d+)s"
        path_params = {"id": networkservicetype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetworkServiceType.context = {'query_params': [], 'method_name': 'deleteNetworkServiceType', 'method_docs': '[ HTTP: DELETE /networkservicetype/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservicetype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservicetype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservicetype/%(id: \\d+)s', 'method_kind': 'DELETE'}

    @download
    def getNetworkServiceTypes(self,
                               fields=None,
                               **kwargs):
        """
        [ HTTP: GET /networkservicetype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServiceTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkServiceTypes', 'method_docs': '[ HTTP: GET /networkservicetype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservicetype', 'method_kind': 'GET'}

    @download
    def getNetworkServiceType(self,
                              networkservicetype_id=None,
                              fields=None,
                              **kwargs):
        """
        [ HTTP: GET /networkservicetype/{id: \d+} ]

        @param networkservicetype_id: networkservicetype_id
        @type networkservicetype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(id: \d+)s"
        path_params = {"id": networkservicetype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServiceType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworkServiceType', 'method_docs': '[ HTTP: GET /networkservicetype/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservicetype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'networkservicetype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservicetype/%(id: \\d+)s', 'method_kind': 'GET'}

    @download
    def createNetworkServiceType(self,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /networkservicetype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetworkServiceType.context = {'query_params': [], 'method_name': 'createNetworkServiceType', 'method_docs': '[ HTTP: POST /networkservicetype ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'networkservicetype', 'method_kind': 'POST'}

    @download
    def getNetworkServiceTypeByName(self,
                                    networkservicetype_type=None,
                                    **kwargs):
        """
        [ HTTP: GET /networkservicetype/{type: [^0-9]\w+} ]

        @param networkservicetype_type: networkservicetype_type
        @type networkservicetype_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "networkservicetype/%(type: [^0-9]\w+)s"
        path_params = {"type": networkservicetype_type}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkServiceTypeByName.context = {'query_params': [], 'method_name': 'getNetworkServiceTypeByName', 'method_docs': '[ HTTP: GET /networkservicetype/{type: [^0-9]\\w+} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'networkservicetype_type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'networkservicetype_type'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'networkservicetype/%(type: [^0-9]\\w+)s', 'method_kind': 'GET'}

class page(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updatePage(self,
                   page_id=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /page/{id} ]

        @param page_id: page_id
        @type page_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "page/%(id)s"
        path_params = {"id": page_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePage.context = {'query_params': [], 'method_name': 'updatePage', 'method_docs': '[ HTTP: PUT /page/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'page_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'page_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'page/%(id)s', 'method_kind': 'PUT'}

    @download
    def getPage(self,
                page_id=None,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /page/{id} ]

        @param page_id: page_id
        @type page_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "page/%(id)s"
        path_params = {"id": page_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPage.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPage', 'method_docs': '[ HTTP: GET /page/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'page_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'page_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'page/%(id)s', 'method_kind': 'GET'}

    @download
    def getPages(self,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /page ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "page"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPages', 'method_docs': '[ HTTP: GET /page ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'page', 'method_kind': 'GET'}

    @download
    def searchPages(self,
                    fields=None,
                    filterGroup=None,
                    limit=None,
                    offset=None,
                    orderBy=None,
                    usage=None,
                    **kwargs):
        """
        [ HTTP: GET /page/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "page/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPages.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchPages', 'method_docs': '[ HTTP: GET /page/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'page/search', 'method_kind': 'GET'}

    @download
    def deletePage(self,
                   page_id=None,
                   **kwargs):
        """
        [ HTTP: DELETE /page/{id} ]

        @param page_id: page_id
        @type page_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "page/%(id)s"
        path_params = {"id": page_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePage.context = {'query_params': [], 'method_name': 'deletePage', 'method_docs': '[ HTTP: DELETE /page/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'page_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'page_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'page/%(id)s', 'method_kind': 'DELETE'}

class authgroup(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getMappings(self,
                    **kwargs):
        """
        [ HTTP: GET /authgroup ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMappings.context = {'query_params': [], 'method_name': 'getMappings', 'method_docs': '[ HTTP: GET /authgroup ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authgroup', 'method_kind': 'GET'}

    @download
    def deleteMapping(self,
                      authgroup_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /authgroup/{id} ]

        @param authgroup_id: authgroup_id
        @type authgroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup/%(id)s"
        path_params = {"id": authgroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteMapping.context = {'query_params': [], 'method_name': 'deleteMapping', 'method_docs': '[ HTTP: DELETE /authgroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authgroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authgroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authgroup/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updateMapping(self,
                      authgroup_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /authgroup/{id} ]

        @param authgroup_id: authgroup_id
        @type authgroup_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup/%(id)s"
        path_params = {"id": authgroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateMapping.context = {'query_params': [], 'method_name': 'updateMapping', 'method_docs': '[ HTTP: PUT /authgroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authgroup_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authgroup_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'authgroup/%(id)s', 'method_kind': 'PUT'}

    @download
    def getMapping(self,
                   authgroup_id=None,
                   **kwargs):
        """
        [ HTTP: GET /authgroup/{id} ]

        @param authgroup_id: authgroup_id
        @type authgroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup/%(id)s"
        path_params = {"id": authgroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getMapping.context = {'query_params': [], 'method_name': 'getMapping', 'method_docs': '[ HTTP: GET /authgroup/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authgroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'authgroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authgroup/%(id)s', 'method_kind': 'GET'}

    @download
    def createMapping(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /authgroup ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createMapping.context = {'query_params': [], 'method_name': 'createMapping', 'method_docs': '[ HTTP: POST /authgroup ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'authgroup', 'method_kind': 'POST'}

    @download
    def setMappings(self,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /authgroup/set ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup/set"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setMappings.context = {'query_params': [], 'method_name': 'setMappings', 'method_docs': '[ HTTP: POST /authgroup/set ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'authgroup/set', 'method_kind': 'POST'}

    @download
    def getServerMapping(self,
                         server_id=None,
                         **kwargs):
        """
        [ HTTP: GET /authgroup/server/{id} ]

        @param server_id: server_id
        @type server_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "authgroup/server/%(id)s"
        path_params = {"id": server_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServerMapping.context = {'query_params': [], 'method_name': 'getServerMapping', 'method_docs': '[ HTTP: GET /authgroup/server/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'server_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'server_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'authgroup/server/%(id)s', 'method_kind': 'GET'}

class propertytype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getPropertyType(self,
                        propertytype_id=None,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPropertyType', 'method_docs': '[ HTTP: GET /propertytype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertytype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertytype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertytype/%(id)s', 'method_kind': 'GET'}

    @download
    def createPropertyTypeXML(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /propertytype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPropertyTypeXML.context = {'query_params': [], 'method_name': 'createPropertyTypeXML', 'method_docs': '[ HTTP: POST /propertytype ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'propertytype', 'method_kind': 'POST'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /propertytype/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /propertytype/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'propertytype/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     propertytype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /propertytype/{id}/export ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s/export"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /propertytype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'propertytype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'propertytype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertytype/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /propertytype/{id}/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /propertytype/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'propertytype/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /propertytype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /propertytype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertytype/export', 'method_kind': 'GET'}

    @download
    def deletePropertyType(self,
                           propertytype_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePropertyType.context = {'query_params': [], 'method_name': 'deletePropertyType', 'method_docs': '[ HTTP: DELETE /propertytype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertytype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertytype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertytype/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getPropertyTypesXML(self,
                            includeOwned=None,
                            fields=None,
                            **kwargs):
        """
        [ HTTP: GET /propertytype ]

        @param includeOwned: includeOwned
        @type includeOwned: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"includeOwned": includeOwned,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPropertyTypesXML.context = {'query_params': [{'name': 'includeOwned', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'includeOwned'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPropertyTypesXML', 'method_docs': '[ HTTP: GET /propertytype ]', 'result': 'result', 'method_params': [{'name': 'includeOwned', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'includeOwned'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'propertytype', 'method_kind': 'GET'}

    @download
    def updatePropertyType(self,
                           propertytype_id=None,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /propertytype/{id} ]

        @param propertytype_id: propertytype_id
        @type propertytype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "propertytype/%(id)s"
        path_params = {"id": propertytype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePropertyType.context = {'query_params': [], 'method_name': 'updatePropertyType', 'method_docs': '[ HTTP: PUT /propertytype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertytype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'propertytype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'propertytype/%(id)s', 'method_kind': 'PUT'}

class network(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getPorts(self,
                 network_id,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /network/{id}/port ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/port"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPorts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPorts', 'method_docs': '[ HTTP: GET /network/{id}/port ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/port', 'method_kind': 'GET'}

    @download
    def getAvailableAddresses(self,
                              network_id,
                              **kwargs):
        """
        [ HTTP: GET /network/{id}/addresses ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/addresses"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAvailableAddresses.context = {'query_params': [], 'method_name': 'getAvailableAddresses', 'method_docs': '[ HTTP: GET /network/{id}/addresses ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/addresses', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /network/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /network/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/export', 'method_kind': 'GET'}

    @download
    def searchNetworks(self,
                       cloudId=None,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /network/search ]

        @param cloudId: cloudId
        @type cloudId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"cloudId": cloudId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchNetworks.context = {'query_params': [{'name': 'cloudId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloudId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchNetworks', 'method_docs': '[ HTTP: GET /network/search ]', 'result': 'result', 'method_params': [{'name': 'cloudId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloudId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/search', 'method_kind': 'GET'}

    @download
    def createNetwork(self,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /network ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createNetwork.context = {'query_params': [], 'method_name': 'createNetwork', 'method_docs': '[ HTTP: POST /network ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'network', 'method_kind': 'POST'}

    @download
    def updateNetwork(self,
                      network_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateNetwork.context = {'query_params': [], 'method_name': 'updateNetwork', 'method_docs': '[ HTTP: PUT /network/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'network_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'network/%(id)s', 'method_kind': 'PUT'}

    @download
    def getSubnets(self,
                   network_id,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /network/{id}/subnet ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/subnet"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSubnets.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSubnets', 'method_docs': '[ HTTP: GET /network/{id}/subnet ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/subnet', 'method_kind': 'GET'}

    @download
    def syncNetwork(self,
                    network_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /network/{id}/sync ]

        @param network_id: network_id
        @type network_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/sync"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncNetwork.context = {'query_params': [], 'method_name': 'syncNetwork', 'method_docs': '[ HTTP: POST /network/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/sync', 'method_kind': 'POST'}

    @download
    def deleteNetwork(self,
                      network_id=None,
                      **kwargs):
        """
        [ HTTP: DELETE /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteNetwork.context = {'query_params': [], 'method_name': 'deleteNetwork', 'method_docs': '[ HTTP: DELETE /network/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'network_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchNetworkSubnets(self,
                             network_id,
                             fields=None,
                             filterGroup=None,
                             limit=None,
                             offset=None,
                             orderBy=None,
                             usage=None,
                             **kwargs):
        """
        [ HTTP: GET /network/{id}/subnet/search ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/subnet/search"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchNetworkSubnets.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchNetworkSubnets', 'method_docs': '[ HTTP: GET /network/{id}/subnet/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/subnet/search', 'method_kind': 'GET'}

    @download
    def createSubnet(self,
                     network_id,
                     fields=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /network/{id}/subnet ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/subnet"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createSubnet.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createSubnet', 'method_docs': '[ HTTP: POST /network/{id}/subnet ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'network/%(id)s/subnet', 'method_kind': 'POST'}

    @download
    def getNetworkUsage(self,
                        network_id,
                        **kwargs):
        """
        [ HTTP: GET /network/{id}/usage ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/usage"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkUsage.context = {'query_params': [], 'method_name': 'getNetworkUsage', 'method_docs': '[ HTTP: GET /network/{id}/usage ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/usage', 'method_kind': 'GET'}

    @download
    def getAvailableAddressesWithNetwork(self,
                                         network_id,
                                         requestId=None,
                                         **kwargs):
        """
        [ HTTP: GET /network/{id}/networkaddresses ]

        @param network_id: network_id
        @type network_id: str
        @param requestId: requestId
        @type requestId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/networkaddresses"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"requestId": requestId}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAvailableAddressesWithNetwork.context = {'query_params': [{'name': 'requestId', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'requestId'}], 'method_name': 'getAvailableAddressesWithNetwork', 'method_docs': '[ HTTP: GET /network/{id}/networkaddresses ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'requestId', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'requestId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/networkaddresses', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     network_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /network/{id}/export ]

        @param network_id: network_id
        @type network_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/export"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /network/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getNetwork(self,
                   network_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /network/{id} ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetwork.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetwork', 'method_docs': '[ HTTP: GET /network/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s', 'method_kind': 'GET'}

    @download
    def searchNetworkPorts(self,
                           network_id,
                           fields=None,
                           filterGroup=None,
                           limit=None,
                           offset=None,
                           orderBy=None,
                           usage=None,
                           **kwargs):
        """
        [ HTTP: GET /network/{id}/port/search ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/port/search"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchNetworkPorts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchNetworkPorts', 'method_docs': '[ HTTP: GET /network/{id}/port/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/port/search', 'method_kind': 'GET'}

    @download
    def getNetworksXML(self,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /network ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworksXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getNetworksXML', 'method_docs': '[ HTTP: GET /network ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network', 'method_kind': 'GET'}

    @download
    def getNetworkInterfaces(self,
                             network_id,
                             **kwargs):
        """
        [ HTTP: GET /network/{id}/interfaces ]

        @param network_id: network_id
        @type network_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/interfaces"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getNetworkInterfaces.context = {'query_params': [], 'method_name': 'getNetworkInterfaces', 'method_docs': '[ HTTP: GET /network/{id}/interfaces ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'network/%(id)s/interfaces', 'method_kind': 'GET'}

    @download
    def createAddressRange(self,
                           network_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /network/{id}/addressrange ]

        @param network_id: network_id
        @type network_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/addressrange"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAddressRange.context = {'query_params': [], 'method_name': 'createAddressRange', 'method_docs': '[ HTTP: POST /network/{id}/addressrange ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'network/%(id)s/addressrange', 'method_kind': 'POST'}

    @download
    def createPort(self,
                   network_id,
                   fields=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /network/{id}/port ]

        @param network_id: network_id
        @type network_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "network/%(id)s/port"
        path_params = {"id": network_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPort.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createPort', 'method_docs': '[ HTTP: POST /network/{id}/port ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'network_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'network/%(id)s/port', 'method_kind': 'POST'}

class model(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateResource(self,
                       model_id,
                       resourceId=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /model/{id}/resource/{resourceId} ]

        @param model_id: model_id
        @type model_id: str
        @param resourceId: resourceId
        @type resourceId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource/%(resourceId)s"
        path_params = {"id": model_id,
                       "resourceId": resourceId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateResource.context = {'query_params': [], 'method_name': 'updateResource', 'method_docs': '[ HTTP: PUT /model/{id}/resource/{resourceId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}, {'name': 'resourceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resourceId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}, {'name': 'resourceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resourceId'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'model/%(id)s/resource/%(resourceId)s', 'method_kind': 'PUT'}

    @download
    def addResource(self,
                    model_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /model/{id}/resource ]

        @param model_id: model_id
        @type model_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addResource.context = {'query_params': [], 'method_name': 'addResource', 'method_docs': '[ HTTP: POST /model/{id}/resource ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'model/%(id)s/resource', 'method_kind': 'POST'}

    @download
    def getModel(self,
                 model_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /model/{id} ]

        @param model_id: model_id
        @type model_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModel.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getModel', 'method_docs': '[ HTTP: GET /model/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'model/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteResource(self,
                       model_id,
                       resourceId=None,
                       **kwargs):
        """
        [ HTTP: DELETE /model/{id}/resource/{resourceId} ]

        @param model_id: model_id
        @type model_id: str
        @param resourceId: resourceId
        @type resourceId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/resource/%(resourceId)s"
        path_params = {"id": model_id,
                       "resourceId": resourceId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteResource.context = {'query_params': [], 'method_name': 'deleteResource', 'method_docs': '[ HTTP: DELETE /model/{id}/resource/{resourceId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}, {'name': 'resourceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resourceId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}, {'name': 'resourceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resourceId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'model/%(id)s/resource/%(resourceId)s', 'method_kind': 'DELETE'}

    @download
    def exportAction(self,
                     model_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /model/{id}/export ]

        @param model_id: model_id
        @type model_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s/export"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /model/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'model_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'model/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /model/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /model/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'model/export', 'method_kind': 'GET'}

    @download
    def updateModel(self,
                    model_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /model/{id} ]

        @param model_id: model_id
        @type model_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/%(id)s"
        path_params = {"id": model_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateModel.context = {'query_params': [], 'method_name': 'updateModel', 'method_docs': '[ HTTP: PUT /model/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'model/%(id)s', 'method_kind': 'PUT'}

    @download
    def getModelsXML(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /model ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModelsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getModelsXML', 'method_docs': '[ HTTP: GET /model ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'model', 'method_kind': 'GET'}

    @download
    def searchModels(self,
                     fields=None,
                     filterGroup=None,
                     limit=None,
                     offset=None,
                     orderBy=None,
                     usage=None,
                     **kwargs):
        """
        [ HTTP: GET /model/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "model/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchModels.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchModels', 'method_docs': '[ HTTP: GET /model/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'model/search', 'method_kind': 'GET'}

class serviceinstance(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def startInstance(self,
                      serviceinstance_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /serviceinstance/{id}/start ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/start"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    startInstance.context = {'query_params': [], 'method_name': 'startInstance', 'method_docs': '[ HTTP: POST /serviceinstance/{id}/start ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/start', 'method_kind': 'POST'}

    @download
    def createServiceInstance(self,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /serviceinstance ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createServiceInstance.context = {'query_params': [], 'method_name': 'createServiceInstance', 'method_docs': '[ HTTP: POST /serviceinstance ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceinstance', 'method_kind': 'POST'}

    @download
    def attachPolicy(self,
                     serviceinstance_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /serviceinstance/{id}/policy/{policyid} ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/policy/%(policyid)s"
        path_params = {"id": serviceinstance_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /serviceinstance/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /serviceinstance/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /serviceinstance/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /serviceinstance/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /serviceinstance/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'serviceinstance/import', 'method_kind': 'PUT'}

    @download
    def removePolicy(self,
                     serviceinstance_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /serviceinstance/{id}/policy/{policyid} ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/policy/%(policyid)s"
        path_params = {"id": serviceinstance_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /serviceinstance/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def getPolicies(self,
                    serviceinstance_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /serviceinstance/{id}/policy ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/policy"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /serviceinstance/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def searchServiceInstances(self,
                               containerId=None,
                               fields=None,
                               filterGroup=None,
                               limit=None,
                               offset=None,
                               orderBy=None,
                               qterm=None,
                               usage=None,
                               **kwargs):
        """
        [ HTTP: GET /serviceinstance/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchServiceInstances.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchServiceInstances', 'method_docs': '[ HTTP: GET /serviceinstance/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/search', 'method_kind': 'GET'}

    @download
    def acknowledgeDegrade(self,
                           serviceinstance_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: PUT /serviceinstance/{id}/ack ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/ack"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    acknowledgeDegrade.context = {'query_params': [], 'method_name': 'acknowledgeDegrade', 'method_docs': '[ HTTP: PUT /serviceinstance/{id}/ack ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/ack', 'method_kind': 'PUT'}

    @download
    def deleteServiceInstance(self,
                              serviceinstance_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /serviceinstance/{id: \d+} ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id: \d+)s"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteServiceInstance.context = {'query_params': [], 'method_name': 'deleteServiceInstance', 'method_docs': '[ HTTP: DELETE /serviceinstance/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceinstance_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id: \\d+)s', 'method_kind': 'DELETE'}

    @download
    def releaseInstance(self,
                        serviceinstance_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /serviceinstance/{id}/release ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/release"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    releaseInstance.context = {'query_params': [], 'method_name': 'releaseInstance', 'method_docs': '[ HTTP: POST /serviceinstance/{id}/release ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/release', 'method_kind': 'POST'}

    @download
    def searchPolicyAssignments(self,
                                serviceinstance_id,
                                containerId=None,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /serviceinstance/{id}/policyassignment/search ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/policyassignment/search"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /serviceinstance/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def getServiceInstances(self,
                            fields=None,
                            serviceId=None,
                            providerId=None,
                            **kwargs):
        """
        [ HTTP: GET /serviceinstance ]

        @param fields: fields
        @type fields: str
        @param serviceId: serviceId
        @type serviceId: str
        @param providerId: providerId
        @type providerId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "serviceId": serviceId,
                        "providerId": providerId}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceInstances.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'serviceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceId'}, {'name': 'providerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'providerId'}], 'method_name': 'getServiceInstances', 'method_docs': '[ HTTP: GET /serviceinstance ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'serviceId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceId'}, {'name': 'providerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'providerId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /serviceinstance/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /serviceinstance/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceinstance/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     serviceinstance_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /serviceinstance/{id}/export ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/export"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /serviceinstance/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/export', 'method_kind': 'GET'}

    @download
    def rebootInstance(self,
                       serviceinstance_id,
                       reconfigure=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /serviceinstance/{id}/restart ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param reconfigure: reconfigure
        @type reconfigure: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/restart"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"reconfigure": reconfigure}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rebootInstance.context = {'query_params': [{'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}], 'method_name': 'rebootInstance', 'method_docs': '[ HTTP: POST /serviceinstance/{id}/restart ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'reconfigure', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'reconfigure'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/restart', 'method_kind': 'POST'}

    @download
    def updateServiceInstance(self,
                              serviceinstance_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /serviceinstance/{id: \d+} ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id: \d+)s"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateServiceInstance.context = {'query_params': [], 'method_name': 'updateServiceInstance', 'method_docs': '[ HTTP: PUT /serviceinstance/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceinstance_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'serviceinstance/%(id: \\d+)s', 'method_kind': 'PUT'}

    @download
    def stopInstance(self,
                     serviceinstance_id,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /serviceinstance/{id}/stop ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id)s/stop"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    stopInstance.context = {'query_params': [], 'method_name': 'stopInstance', 'method_docs': '[ HTTP: POST /serviceinstance/{id}/stop ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id)s/stop', 'method_kind': 'POST'}

    @download
    def getServiceInstance(self,
                           serviceinstance_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /serviceinstance/{id: \d+} ]

        @param serviceinstance_id: serviceinstance_id
        @type serviceinstance_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "serviceinstance/%(id: \d+)s"
        path_params = {"id": serviceinstance_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getServiceInstance.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getServiceInstance', 'method_docs': '[ HTTP: GET /serviceinstance/{id: \\d+} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceinstance_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'serviceinstance_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'serviceinstance/%(id: \\d+)s', 'method_kind': 'GET'}

class custom(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createAssetXML(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /custom ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAssetXML.context = {'query_params': [], 'method_name': 'createAssetXML', 'method_docs': '[ HTTP: POST /custom ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'custom', 'method_kind': 'POST'}

    @download
    def getAsset(self,
                 custom_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAsset.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAsset', 'method_docs': '[ HTTP: GET /custom/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'custom_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'custom_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'custom/%(id)s', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     custom_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /custom/{id}/export ]

        @param custom_id: custom_id
        @type custom_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s/export"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /custom/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'custom_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'custom_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'custom/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /custom/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /custom/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'custom/export', 'method_kind': 'GET'}

    @download
    def deleteCustomItem(self,
                         custom_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteCustomItem.context = {'query_params': [], 'method_name': 'deleteCustomItem', 'method_docs': '[ HTTP: DELETE /custom/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'custom_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'custom_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'custom/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchCustomItems(self,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /custom/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCustomItems.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCustomItems', 'method_docs': '[ HTTP: GET /custom/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'custom/search', 'method_kind': 'GET'}

    @download
    def updateAsset(self,
                    custom_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /custom/{id} ]

        @param custom_id: custom_id
        @type custom_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom/%(id)s"
        path_params = {"id": custom_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAsset.context = {'query_params': [], 'method_name': 'updateAsset', 'method_docs': '[ HTTP: PUT /custom/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'custom_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'custom_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'custom/%(id)s', 'method_kind': 'PUT'}

    @download
    def getAssetsXML(self,
                     fields=None,
                     type=None,
                     **kwargs):
        """
        [ HTTP: GET /custom ]

        @param fields: fields
        @type fields: str
        @param type: type
        @type type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "custom"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "type": type}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAssetsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}], 'method_name': 'getAssetsXML', 'method_docs': '[ HTTP: GET /custom ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'custom', 'method_kind': 'GET'}

class permissiontype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deletePermissionType(self,
                             permissiontype_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePermissionType.context = {'query_params': [], 'method_name': 'deletePermissionType', 'method_docs': '[ HTTP: DELETE /permissiontype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'permissiontype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'permissiontype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'permissiontype/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updatePermissionType(self,
                             permissiontype_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePermissionType.context = {'query_params': [], 'method_name': 'updatePermissionType', 'method_docs': '[ HTTP: PUT /permissiontype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'permissiontype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'permissiontype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'permissiontype/%(id)s', 'method_kind': 'PUT'}

    @download
    def getPermissionType(self,
                          permissiontype_id=None,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /permissiontype/{id} ]

        @param permissiontype_id: permissiontype_id
        @type permissiontype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "permissiontype/%(id)s"
        path_params = {"id": permissiontype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPermissionType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPermissionType', 'method_docs': '[ HTTP: GET /permissiontype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'permissiontype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'permissiontype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'permissiontype/%(id)s', 'method_kind': 'GET'}

class addressrange(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteAddressRange(self,
                           addressrange_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /addressrange/{id} ]

        @param addressrange_id: addressrange_id
        @type addressrange_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "addressrange/%(id)s"
        path_params = {"id": addressrange_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAddressRange.context = {'query_params': [], 'method_name': 'deleteAddressRange', 'method_docs': '[ HTTP: DELETE /addressrange/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'addressrange_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'addressrange_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'addressrange/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getAddressRange(self,
                        addressrange_id=None,
                        **kwargs):
        """
        [ HTTP: GET /addressrange/{id} ]

        @param addressrange_id: addressrange_id
        @type addressrange_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "addressrange/%(id)s"
        path_params = {"id": addressrange_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAddressRange.context = {'query_params': [], 'method_name': 'getAddressRange', 'method_docs': '[ HTTP: GET /addressrange/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'addressrange_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'addressrange_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'addressrange/%(id)s', 'method_kind': 'GET'}

class deployer(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteDeployer(self,
                       deployer_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /deployer/{id} ]

        @param deployer_id: deployer_id
        @type deployer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/%(id)s"
        path_params = {"id": deployer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDeployer.context = {'query_params': [], 'method_name': 'deleteDeployer', 'method_docs': '[ HTTP: DELETE /deployer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'deployer/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getDeployers(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /deployer ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployers', 'method_docs': '[ HTTP: GET /deployer ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'deployer', 'method_kind': 'GET'}

    @download
    def getTemplates(self,
                     locationId=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /deployer/template/location/{locationId} ]

        @param locationId: locationId
        @type locationId: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/template/location/%(locationId)s"
        path_params = {"locationId": locationId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTemplates.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTemplates', 'method_docs': '[ HTTP: GET /deployer/template/location/{locationId} ]', 'result': 'result', 'method_params': [{'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'locationId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'locationId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'deployer/template/location/%(locationId)s', 'method_kind': 'GET'}

    @download
    def searchDeployers(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /deployer/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchDeployers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchDeployers', 'method_docs': '[ HTTP: GET /deployer/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'deployer/search', 'method_kind': 'GET'}

    @download
    def updateDeployer(self,
                       deployer_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /deployer/{id} ]

        @param deployer_id: deployer_id
        @type deployer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/%(id)s"
        path_params = {"id": deployer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateDeployer.context = {'query_params': [], 'method_name': 'updateDeployer', 'method_docs': '[ HTTP: PUT /deployer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'deployer/%(id)s', 'method_kind': 'PUT'}

    @download
    def getArtifactTypes(self,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /deployer/artifacttype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/artifacttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifactTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifactTypes', 'method_docs': '[ HTTP: GET /deployer/artifacttype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'deployer/artifacttype', 'method_kind': 'GET'}

    @download
    def getDeployer(self,
                    deployer_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /deployer/{id} ]

        @param deployer_id: deployer_id
        @type deployer_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "deployer/%(id)s"
        path_params = {"id": deployer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployer.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployer', 'method_docs': '[ HTTP: GET /deployer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'deployer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'deployer/%(id)s', 'method_kind': 'GET'}

class eula(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def acceptEULA(self,
                   data=None,
                   **kwargs):
        """
        [ HTTP: POST /eula/accept ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "eula/accept"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    acceptEULA.context = {'query_params': [], 'method_name': 'acceptEULA', 'method_docs': '[ HTTP: POST /eula/accept ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'eula/accept', 'method_kind': 'POST'}

    @download
    def getEULA(self,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /eula ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "eula"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEULA.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEULA', 'method_docs': '[ HTTP: GET /eula ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'eula', 'method_kind': 'GET'}

class artifacttype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteDeployer(self,
                       artifacttype_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDeployer.context = {'query_params': [], 'method_name': 'deleteDeployer', 'method_docs': '[ HTTP: DELETE /artifacttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifacttype/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getType_2(self,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /artifacttype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getType_2.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getType_2', 'method_docs': '[ HTTP: GET /artifacttype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifacttype', 'method_kind': 'GET'}

    @download
    def getType_1(self,
                  artifacttype_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getType_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getType_1', 'method_docs': '[ HTTP: GET /artifacttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifacttype/%(id)s', 'method_kind': 'GET'}

    @download
    def updateType(self,
                   artifacttype_id=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /artifacttype/{id} ]

        @param artifacttype_id: artifacttype_id
        @type artifacttype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifacttype/%(id)s"
        path_params = {"id": artifacttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateType.context = {'query_params': [], 'method_name': 'updateType', 'method_docs': '[ HTTP: PUT /artifacttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifacttype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'artifacttype/%(id)s', 'method_kind': 'PUT'}

class artifact(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createAttachment(self,
                         artifact_id,
                         data=None,
                         **kwargs):
        """
        [ HTTP: POST /artifact/{id}/attachment ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAttachment.context = {'query_params': [], 'method_name': 'createAttachment', 'method_docs': '[ HTTP: POST /artifact/{id}/attachment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'artifact/%(id)s/attachment', 'method_kind': 'POST'}

    @download
    def deleteAttachmentXML(self,
                            artifact_id,
                            attachment_id=None,
                            **kwargs):
        """
        [ HTTP: DELETE /artifact/{id}/attachment/{attachment_id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param attachment_id: attachment_id
        @type attachment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment/%(attachment_id)s"
        path_params = {"id": artifact_id,
                       "attachment_id": attachment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAttachmentXML.context = {'query_params': [], 'method_name': 'deleteAttachmentXML', 'method_docs': '[ HTTP: DELETE /artifact/{id}/attachment/{attachment_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'attachment_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'attachment_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'attachment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s/attachment/%(attachment_id)s', 'method_kind': 'DELETE'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /artifact/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /artifact/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/export', 'method_kind': 'GET'}

    @download
    def createAttachmentMulti(self,
                              artifact_id,
                              data=None,
                              files=None,
                              **kwargs):
        """
        [ HTTP: POST /artifact/{id}/attachment ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createAttachmentMulti.context = {'query_params': [], 'method_name': 'createAttachmentMulti', 'method_docs': '[ HTTP: POST /artifact/{id}/attachment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'form_params': [], 'method_path': 'artifact/%(id)s/attachment', 'method_kind': 'POST'}

    @download
    def publishArtifactMulti(self,
                             artifact_id,
                             data=None,
                             files=None,
                             **kwargs):
        """
        [ HTTP: POST /artifact/{id}/publish ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/publish"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'multipart/mixed'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    publishArtifactMulti.context = {'query_params': [], 'method_name': 'publishArtifactMulti', 'method_docs': '[ HTTP: POST /artifact/{id}/publish ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'multipart/mixed'}, 'form_params': [], 'method_path': 'artifact/%(id)s/publish', 'method_kind': 'POST'}

    @download
    def getArtifacts(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /artifact ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifacts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifacts', 'method_docs': '[ HTTP: GET /artifact ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact', 'method_kind': 'GET'}

    @download
    def getArtifact(self,
                    artifact_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifact.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifact', 'method_docs': '[ HTTP: GET /artifact/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s', 'method_kind': 'GET'}

    @download
    def updateArtifactConfiguration(self,
                                    artifact_id,
                                    data=None,
                                    **kwargs):
        """
        [ HTTP: PUT /artifact/{id}/config ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/config"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateArtifactConfiguration.context = {'query_params': [], 'method_name': 'updateArtifactConfiguration', 'method_docs': '[ HTTP: PUT /artifact/{id}/config ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'artifact/%(id)s/config', 'method_kind': 'PUT'}

    @download
    def deleteArtifact(self,
                       artifact_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteArtifact.context = {'query_params': [], 'method_name': 'deleteArtifact', 'method_docs': '[ HTTP: DELETE /artifact/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s', 'method_kind': 'DELETE'}

    @download
    def deleteArtifactSlot(self,
                           artifact_slotId,
                           **kwargs):
        """
        [ HTTP: DELETE /artifact/{slotId}/slot ]

        @param artifact_slotId: artifact_slotId
        @type artifact_slotId: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(slotId)s/slot"
        path_params = {"slotId": artifact_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteArtifactSlot.context = {'query_params': [], 'method_name': 'deleteArtifactSlot', 'method_docs': '[ HTTP: DELETE /artifact/{slotId}/slot ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_slotId'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(slotId)s/slot', 'method_kind': 'DELETE'}

    @download
    def searchArtifacts(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /artifact/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchArtifacts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchArtifacts', 'method_docs': '[ HTTP: GET /artifact/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/search', 'method_kind': 'GET'}

    @download
    def exportAction(self,
                     artifact_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /artifact/{id}/export ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/export"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /artifact/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getAttachments(self,
                       artifact_id,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /artifact/{id}/attachment ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/attachment"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAttachments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAttachments', 'method_docs': '[ HTTP: GET /artifact/{id}/attachment ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s/attachment', 'method_kind': 'GET'}

    @download
    def getArtifactMulti(self,
                         artifact_id=None,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifactMulti.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifactMulti', 'method_docs': '[ HTTP: GET /artifact/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s', 'method_kind': 'GET'}

    @download
    def updateArtifact(self,
                       artifact_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateArtifact.context = {'query_params': [], 'method_name': 'updateArtifact', 'method_docs': '[ HTTP: PUT /artifact/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'artifact/%(id)s', 'method_kind': 'PUT'}

    @download
    def hardDeleteArtifact(self,
                           artifact_id,
                           **kwargs):
        """
        [ HTTP: DELETE /artifact/{id}/hard ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(id)s/hard"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    hardDeleteArtifact.context = {'query_params': [], 'method_name': 'hardDeleteArtifact', 'method_docs': '[ HTTP: DELETE /artifact/{id}/hard ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(id)s/hard', 'method_kind': 'DELETE'}

    @download
    def getAllVersions(self,
                       artifact_slotId,
                       includeHead=None,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /artifact/{slotId}/version ]

        @param artifact_slotId: artifact_slotId
        @type artifact_slotId: str
        @param includeHead: includeHead
        @type includeHead: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "artifact/%(slotId)s/version"
        path_params = {"slotId": artifact_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"includeHead": includeHead,
                        "fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /artifact/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_slotId'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'artifact/%(slotId)s/version', 'method_kind': 'GET'}

class blueprint_workload(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteWorkload(self,
                       blueprint_bp_id,
                       workload_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /blueprint/{bp_id}/workload/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param workload_id: workload_id
        @type workload_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": workload_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteWorkload.context = {'query_params': [], 'method_name': 'deleteWorkload', 'method_docs': '[ HTTP: DELETE /blueprint/{bp_id}/workload/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'workload_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'workload_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/workload/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updateWorkload(self,
                       blueprint_bp_id,
                       workload_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /blueprint/{bp_id}/workload/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param workload_id: workload_id
        @type workload_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": workload_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateWorkload.context = {'query_params': [], 'method_name': 'updateWorkload', 'method_docs': '[ HTTP: PUT /blueprint/{bp_id}/workload/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'workload_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'workload_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/workload/%(id)s', 'method_kind': 'PUT'}

    @download
    def getWorkload(self,
                    blueprint_bp_id,
                    workload_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /blueprint/{bp_id}/workload/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param workload_id: workload_id
        @type workload_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": workload_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getWorkload.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getWorkload', 'method_docs': '[ HTTP: GET /blueprint/{bp_id}/workload/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'workload_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'workload_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/workload/%(id)s', 'method_kind': 'GET'}

    @download
    def createWorkload(self,
                       blueprint_bp_id,
                       data=None,
                       **kwargs):
        """
        [ HTTP: POST /blueprint/{bp_id}/workload ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/workload"
        path_params = {"bp_id": blueprint_bp_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createWorkload.context = {'query_params': [], 'method_name': 'createWorkload', 'method_docs': '[ HTTP: POST /blueprint/{bp_id}/workload ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/workload', 'method_kind': 'POST'}

class storeproductadapter(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getProductAdapter(self,
                          storeproductadapter_id=None,
                          fields=None,
                          **kwargs):
        """
        [ HTTP: GET /storeproductadapter/{id} ]

        @param storeproductadapter_id: storeproductadapter_id
        @type storeproductadapter_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproductadapter/%(id)s"
        path_params = {"id": storeproductadapter_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProductAdapter.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProductAdapter', 'method_docs': '[ HTTP: GET /storeproductadapter/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproductadapter_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeproductadapter_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproductadapter/%(id)s', 'method_kind': 'GET'}

    @download
    def searchProductAdapters(self,
                              fields=None,
                              filterGroup=None,
                              limit=None,
                              offset=None,
                              orderBy=None,
                              usage=None,
                              **kwargs):
        """
        [ HTTP: GET /storeproductadapter/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproductadapter/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchProductAdapters.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchProductAdapters', 'method_docs': '[ HTTP: GET /storeproductadapter/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproductadapter/search', 'method_kind': 'GET'}

    @download
    def getProductAdapters(self,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /storeproductadapter ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeproductadapter"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProductAdapters.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProductAdapters', 'method_docs': '[ HTTP: GET /storeproductadapter ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeproductadapter', 'method_kind': 'GET'}

class info(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getApiInfo(self,
                   **kwargs):
        """
        [ HTTP: GET /info ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "info"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getApiInfo.context = {'query_params': [], 'method_name': 'getApiInfo', 'method_docs': '[ HTTP: GET /info ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'info', 'method_kind': 'GET'}

class configuration_artifact(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def reject(self,
               artifact_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/{id}/reject ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/reject"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: PUT /configuration/artifact/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s/reject', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/artifact/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /configuration/artifact/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifact/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /configuration/artifact/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifact/import', 'method_kind': 'PUT'}

    @download
    def rejection(self,
                  artifact_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /configuration/artifact/{id}/rejection ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/rejection"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /configuration/artifact/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def getArtifacts(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/artifact ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifacts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifacts', 'method_docs': '[ HTTP: GET /configuration/artifact ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifact', 'method_kind': 'GET'}

    @download
    def getArtifact(self,
                    artifact_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /configuration/artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getArtifact.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getArtifact', 'method_docs': '[ HTTP: GET /configuration/artifact/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s', 'method_kind': 'GET'}

    @download
    def approve(self,
                artifact_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/{id}/approve ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/approve"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: PUT /configuration/artifact/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s/approve', 'method_kind': 'PUT'}

    @download
    def searchArtifacts(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /configuration/artifact/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchArtifacts.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchArtifacts', 'method_docs': '[ HTTP: GET /configuration/artifact/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifact/search', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /configuration/artifact/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'configuration/artifact/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     artifact_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/artifact/{id}/export ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/export"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /configuration/artifact/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s/export', 'method_kind': 'GET'}

    @download
    def updateArtifact(self,
                       artifact_id=None,
                       fields=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/artifact/{id} ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateArtifact.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateArtifact', 'method_docs': '[ HTTP: PUT /configuration/artifact/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s', 'method_kind': 'PUT'}

    @download
    def approval(self,
                 artifact_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /configuration/artifact/{id}/approval ]

        @param artifact_id: artifact_id
        @type artifact_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/artifact/%(id)s/approval"
        path_params = {"id": artifact_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /configuration/artifact/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'artifact_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/artifact/%(id)s/approval', 'method_kind': 'POST'}

class policy(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getEffectiveProtocol(self,
                             data=None,
                             **kwargs):
        """
        [ HTTP: PUT /policy/protocol/effective ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/protocol/effective"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveProtocol.context = {'query_params': [], 'method_name': 'getEffectiveProtocol', 'method_docs': '[ HTTP: PUT /policy/protocol/effective ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'policy/protocol/effective', 'method_kind': 'PUT'}

    @download
    def approval(self,
                 policy_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /policy/{id}/approval ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/approval"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /policy/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def getPolicies(self,
                    fields=None,
                    version=None,
                    type=None,
                    **kwargs):
        """
        [ HTTP: GET /policy ]

        @param fields: fields
        @type fields: str
        @param version: version
        @type version: str
        @param type: type
        @type type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "version": version,
                        "type": type}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /policy ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'version', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'version'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy', 'method_kind': 'GET'}

    @download
    def getPolicyMeta(self,
                      meta_type=None,
                      **kwargs):
        """
        [ HTTP: GET /policy/meta/{type} ]

        @param meta_type: meta_type
        @type meta_type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/meta/%(type)s"
        path_params = {"type": meta_type}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicyMeta.context = {'query_params': [], 'method_name': 'getPolicyMeta', 'method_docs': '[ HTTP: GET /policy/meta/{type} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'meta_type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'meta_type'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/meta/%(type)s', 'method_kind': 'GET'}

    @download
    def checkOut(self,
                 policy_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /policy/{id}/checkout ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/checkout"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkOut.context = {'query_params': [], 'method_name': 'checkOut', 'method_docs': '[ HTTP: POST /policy/{id}/checkout ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s/checkout', 'method_kind': 'POST'}

    @download
    def clearCache(self,
                   **kwargs):
        """
        [ HTTP: DELETE /policy/cache ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/cache"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clearCache.context = {'query_params': [], 'method_name': 'clearCache', 'method_docs': '[ HTTP: DELETE /policy/cache ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/cache', 'method_kind': 'DELETE'}

    @download
    def getPolicy(self,
                  policy_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicy.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPolicy', 'method_docs': '[ HTTP: GET /policy/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policy_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/%(id)s', 'method_kind': 'GET'}

    @download
    def approve(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/approve ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/approve"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: POST /policy/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s/approve', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     policy_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /policy/{id}/export ]

        @param policy_id: policy_id
        @type policy_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/export"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /policy/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/%(id)s/export', 'method_kind': 'GET'}

    @download
    def getPolicyMetas(self,
                       **kwargs):
        """
        [ HTTP: GET /policy/meta ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/meta"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicyMetas.context = {'query_params': [], 'method_name': 'getPolicyMetas', 'method_docs': '[ HTTP: GET /policy/meta ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/meta', 'method_kind': 'GET'}

    @download
    def updatePolicy(self,
                     policy_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePolicy.context = {'query_params': [], 'method_name': 'updatePolicy', 'method_docs': '[ HTTP: PUT /policy/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s', 'method_kind': 'PUT'}

    @download
    def getResourceMetrics(self,
                           type=None,
                           **kwargs):
        """
        [ HTTP: GET /policy/resource/weightInfos ]

        @param type: type
        @type type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/resource/weightInfos"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"type": type}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getResourceMetrics.context = {'query_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}], 'method_name': 'getResourceMetrics', 'method_docs': '[ HTTP: GET /policy/resource/weightInfos ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/resource/weightInfos', 'method_kind': 'GET'}

    @download
    def reject(self,
               policy_id,
               data=None,
               **kwargs):
        """
        [ HTTP: POST /policy/{id}/reject ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/reject"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: POST /policy/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s/reject', 'method_kind': 'POST'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /policy/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /policy/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/export', 'method_kind': 'GET'}

    @download
    def rejection(self,
                  policy_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /policy/{id}/rejection ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/rejection"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /policy/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def searchPolicies(self,
                       assignmentTargetType=None,
                       containerId=None,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       qterm=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /policy/search ]

        @param assignmentTargetType: assignmentTargetType
        @type assignmentTargetType: str
        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"assignmentTargetType": assignmentTargetType,
                        "containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicies.context = {'query_params': [{'name': 'assignmentTargetType', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'assignmentTargetType'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchPolicies', 'method_docs': '[ HTTP: GET /policy/search ]', 'result': 'result', 'method_params': [{'name': 'assignmentTargetType', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'assignmentTargetType'}, {'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/search', 'method_kind': 'GET'}

    @download
    def createPolicy(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /policy ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createPolicy.context = {'query_params': [], 'method_name': 'createPolicy', 'method_docs': '[ HTTP: POST /policy ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy', 'method_kind': 'POST'}

    @download
    def getAllVersions(self,
                       policy_slotId,
                       fields=None,
                       includeHead=None,
                       **kwargs):
        """
        [ HTTP: GET /policy/{slotId}/version ]

        @param policy_slotId: policy_slotId
        @type policy_slotId: str
        @param fields: fields
        @type fields: str
        @param includeHead: includeHead
        @type includeHead: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(slotId)s/version"
        path_params = {"slotId": policy_slotId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "includeHead": includeHead}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAllVersions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}], 'method_name': 'getAllVersions', 'method_docs': '[ HTTP: GET /policy/{slotId}/version ]', 'result': 'result', 'method_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_slotId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'includeHead', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'includeHead'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'slotId', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_slotId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/%(slotId)s/version', 'method_kind': 'GET'}

    @download
    def setHead(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/head ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/head"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    setHead.context = {'query_params': [], 'method_name': 'setHead', 'method_docs': '[ HTTP: POST /policy/{id}/head ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/%(id)s/head', 'method_kind': 'POST'}

    @download
    def deletePolicy(self,
                     policy_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /policy/{id} ]

        @param policy_id: policy_id
        @type policy_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePolicy.context = {'query_params': [], 'method_name': 'deletePolicy', 'method_docs': '[ HTTP: DELETE /policy/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policy_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/%(id)s', 'method_kind': 'DELETE'}

    @download
    def execution(self,
                  policy_id,
                  assetType=None,
                  assetId=None,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /policy/{id}/execution ]

        @param policy_id: policy_id
        @type policy_id: str
        @param assetType: assetType
        @type assetType: str
        @param assetId: assetId
        @type assetId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/execution"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"assetType": assetType,
                        "assetId": assetId}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    execution.context = {'query_params': [{'name': 'assetType', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'assetType'}, {'name': 'assetId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assetId'}], 'method_name': 'execution', 'method_docs': '[ HTTP: POST /policy/{id}/execution ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'assetType', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'assetType'}, {'name': 'assetId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'assetId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'policy/%(id)s/execution', 'method_kind': 'POST'}

    @download
    def checkIn(self,
                policy_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /policy/{id}/checkin ]

        @param policy_id: policy_id
        @type policy_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "policy/%(id)s/checkin"
        path_params = {"id": policy_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkIn.context = {'query_params': [], 'method_name': 'checkIn', 'method_docs': '[ HTTP: POST /policy/{id}/checkin ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'policy_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'policy/%(id)s/checkin', 'method_kind': 'POST'}

class launchitemdeployment(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def approve(self,
                launchitemdeployment_id,
                data=None,
                **kwargs):
        """
        [ HTTP: PUT /launchitemdeployment/{id}/approve ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s/approve"
        path_params = {"id": launchitemdeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approve.context = {'query_params': [], 'method_name': 'approve', 'method_docs': '[ HTTP: PUT /launchitemdeployment/{id}/approve ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitemdeployment/%(id)s/approve', 'method_kind': 'PUT'}

    @download
    def searchDeployments(self,
                          fields=None,
                          filterGroup=None,
                          limit=None,
                          offset=None,
                          orderBy=None,
                          usage=None,
                          **kwargs):
        """
        [ HTTP: GET /launchitemdeployment/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchDeployments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchDeployments', 'method_docs': '[ HTTP: GET /launchitemdeployment/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitemdeployment/search', 'method_kind': 'GET'}

    @download
    def approval(self,
                 launchitemdeployment_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /launchitemdeployment/{id}/approval ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s/approval"
        path_params = {"id": launchitemdeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    approval.context = {'query_params': [], 'method_name': 'approval', 'method_docs': '[ HTTP: POST /launchitemdeployment/{id}/approval ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitemdeployment/%(id)s/approval', 'method_kind': 'POST'}

    @download
    def rejection(self,
                  launchitemdeployment_id,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /launchitemdeployment/{id}/rejection ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s/rejection"
        path_params = {"id": launchitemdeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    rejection.context = {'query_params': [], 'method_name': 'rejection', 'method_docs': '[ HTTP: POST /launchitemdeployment/{id}/rejection ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitemdeployment/%(id)s/rejection', 'method_kind': 'POST'}

    @download
    def getDeployment(self,
                      launchitemdeployment_id=None,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /launchitemdeployment/{id} ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s"
        path_params = {"id": launchitemdeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployment.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployment', 'method_docs': '[ HTTP: GET /launchitemdeployment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitemdeployment_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitemdeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitemdeployment/%(id)s', 'method_kind': 'GET'}

    @download
    def getDeployments(self,
                       fields=None,
                       **kwargs):
        """
        [ HTTP: GET /launchitemdeployment ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployments', 'method_docs': '[ HTTP: GET /launchitemdeployment ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitemdeployment', 'method_kind': 'GET'}

    @download
    def deleteDeployment(self,
                         launchitemdeployment_id=None,
                         **kwargs):
        """
        [ HTTP: DELETE /launchitemdeployment/{id} ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s"
        path_params = {"id": launchitemdeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDeployment.context = {'query_params': [], 'method_name': 'deleteDeployment', 'method_docs': '[ HTTP: DELETE /launchitemdeployment/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitemdeployment_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'launchitemdeployment_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'launchitemdeployment/%(id)s', 'method_kind': 'DELETE'}

    @download
    def reject(self,
               launchitemdeployment_id,
               data=None,
               **kwargs):
        """
        [ HTTP: PUT /launchitemdeployment/{id}/reject ]

        @param launchitemdeployment_id: launchitemdeployment_id
        @type launchitemdeployment_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "launchitemdeployment/%(id)s/reject"
        path_params = {"id": launchitemdeployment_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    reject.context = {'query_params': [], 'method_name': 'reject', 'method_docs': '[ HTTP: PUT /launchitemdeployment/{id}/reject ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'launchitemdeployment_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'launchitemdeployment/%(id)s/reject', 'method_kind': 'PUT'}

class designdeployer(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteDeployer(self,
                       designdeployer_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /designdeployer/{id} ]

        @param designdeployer_id: designdeployer_id
        @type designdeployer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/%(id)s"
        path_params = {"id": designdeployer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDeployer.context = {'query_params': [], 'method_name': 'deleteDeployer', 'method_docs': '[ HTTP: DELETE /designdeployer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designdeployer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designdeployer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'designdeployer/%(id)s', 'method_kind': 'DELETE'}

    @download
    def updateDeployer(self,
                       designdeployer_id=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /designdeployer/{id} ]

        @param designdeployer_id: designdeployer_id
        @type designdeployer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/%(id)s"
        path_params = {"id": designdeployer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateDeployer.context = {'query_params': [], 'method_name': 'updateDeployer', 'method_docs': '[ HTTP: PUT /designdeployer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designdeployer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designdeployer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'designdeployer/%(id)s', 'method_kind': 'PUT'}

    @download
    def searchDeployers(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /designdeployer/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchDeployers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchDeployers', 'method_docs': '[ HTTP: GET /designdeployer/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'designdeployer/search', 'method_kind': 'GET'}

    @download
    def getDeployers(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /designdeployer ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployers.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployers', 'method_docs': '[ HTTP: GET /designdeployer ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'designdeployer', 'method_kind': 'GET'}

    @download
    def getDeployer(self,
                    designdeployer_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /designdeployer/{id} ]

        @param designdeployer_id: designdeployer_id
        @type designdeployer_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "designdeployer/%(id)s"
        path_params = {"id": designdeployer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDeployer.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDeployer', 'method_docs': '[ HTTP: GET /designdeployer/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designdeployer_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designdeployer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'designdeployer/%(id)s', 'method_kind': 'GET'}

class adapter(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getAdapters(self,
                    **kwargs):
        """
        [ HTTP: GET /adapter ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "adapter"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAdapters.context = {'query_params': [], 'method_name': 'getAdapters', 'method_docs': '[ HTTP: GET /adapter ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'adapter', 'method_kind': 'GET'}

class environmenttype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def createEnvironmentTypeXML(self,
                                 data=None,
                                 **kwargs):
        """
        [ HTTP: POST /environmenttype ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createEnvironmentTypeXML.context = {'query_params': [], 'method_name': 'createEnvironmentTypeXML', 'method_docs': '[ HTTP: POST /environmenttype ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environmenttype', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     environmenttype_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /environmenttype/{id}/export ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s/export"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /environmenttype/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environmenttype_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'environmenttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environmenttype/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /environmenttype/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /environmenttype/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environmenttype/export', 'method_kind': 'GET'}

    @download
    def getEnvironmentType(self,
                           environmenttype_id=None,
                           fields=None,
                           **kwargs):
        """
        [ HTTP: GET /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironmentType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEnvironmentType', 'method_docs': '[ HTTP: GET /environmenttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environmenttype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environmenttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environmenttype/%(id)s', 'method_kind': 'GET'}

    @download
    def updateEnvironmentType(self,
                              environmenttype_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateEnvironmentType.context = {'query_params': [], 'method_name': 'updateEnvironmentType', 'method_docs': '[ HTTP: PUT /environmenttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environmenttype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environmenttype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'environmenttype/%(id)s', 'method_kind': 'PUT'}

    @download
    def deleteEnvironmentType(self,
                              environmenttype_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /environmenttype/{id} ]

        @param environmenttype_id: environmenttype_id
        @type environmenttype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/%(id)s"
        path_params = {"id": environmenttype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteEnvironmentType.context = {'query_params': [], 'method_name': 'deleteEnvironmentType', 'method_docs': '[ HTTP: DELETE /environmenttype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environmenttype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'environmenttype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environmenttype/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchEnvironmentTypes(self,
                               fields=None,
                               filterGroup=None,
                               limit=None,
                               offset=None,
                               orderBy=None,
                               usage=None,
                               **kwargs):
        """
        [ HTTP: GET /environmenttype/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchEnvironmentTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchEnvironmentTypes', 'method_docs': '[ HTTP: GET /environmenttype/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environmenttype/search', 'method_kind': 'GET'}

    @download
    def getEnvironmentTypesXML(self,
                               fields=None,
                               **kwargs):
        """
        [ HTTP: GET /environmenttype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "environmenttype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEnvironmentTypesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEnvironmentTypesXML', 'method_docs': '[ HTTP: GET /environmenttype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'environmenttype', 'method_kind': 'GET'}

class domain(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getDomainsXML(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /domain ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDomainsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDomainsXML', 'method_docs': '[ HTTP: GET /domain ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain', 'method_kind': 'GET'}

    @download
    def updateDomain(self,
                     domain_id=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateDomain.context = {'query_params': [], 'method_name': 'updateDomain', 'method_docs': '[ HTTP: PUT /domain/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'domain_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'domain/%(id)s', 'method_kind': 'PUT'}

    @download
    def createRoleXML(self,
                      domain_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /domain/{id}/projectrole ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/projectrole"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createRoleXML.context = {'query_params': [], 'method_name': 'createRoleXML', 'method_docs': '[ HTTP: POST /domain/{id}/projectrole ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'domain/%(id)s/projectrole', 'method_kind': 'POST'}

    @download
    def createDomainXML(self,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /domain ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDomainXML.context = {'query_params': [], 'method_name': 'createDomainXML', 'method_docs': '[ HTTP: POST /domain ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'domain', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     domain_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /domain/{id}/export ]

        @param domain_id: domain_id
        @type domain_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/export"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /domain/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain/%(id)s/export', 'method_kind': 'GET'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /domain/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /domain/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain/export', 'method_kind': 'GET'}

    @download
    def getDomain(self,
                  domain_id=None,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDomain.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getDomain', 'method_docs': '[ HTTP: GET /domain/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'domain_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteDomain(self,
                     domain_id=None,
                     **kwargs):
        """
        [ HTTP: DELETE /domain/{id} ]

        @param domain_id: domain_id
        @type domain_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDomain.context = {'query_params': [], 'method_name': 'deleteDomain', 'method_docs': '[ HTTP: DELETE /domain/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'domain_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getRolesXML(self,
                    domain_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /domain/{id}/projectrole ]

        @param domain_id: domain_id
        @type domain_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/projectrole"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getRolesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getRolesXML', 'method_docs': '[ HTTP: GET /domain/{id}/projectrole ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain/%(id)s/projectrole', 'method_kind': 'GET'}

    @download
    def createUserXML(self,
                      domain_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /domain/{id}/user ]

        @param domain_id: domain_id
        @type domain_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/user"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createUserXML.context = {'query_params': [], 'method_name': 'createUserXML', 'method_docs': '[ HTTP: POST /domain/{id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'domain/%(id)s/user', 'method_kind': 'POST'}

    @download
    def getUsersXML(self,
                    domain_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /domain/{id}/user ]

        @param domain_id: domain_id
        @type domain_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "domain/%(id)s/user"
        path_params = {"id": domain_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getUsersXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getUsersXML', 'method_docs': '[ HTTP: GET /domain/{id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'domain_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'domain/%(id)s/user', 'method_kind': 'GET'}

class reports(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def puppetReport(self,
                     data=None,
                     **kwargs):
        """
        [ HTTP: POST /reports/puppet ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "reports/puppet"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-yaml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    puppetReport.context = {'query_params': [], 'method_name': 'puppetReport', 'method_docs': '[ HTTP: POST /reports/puppet ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/x-yaml'}, 'form_params': [], 'method_path': 'reports/puppet', 'method_kind': 'POST'}

class configuration_policy(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def evaluate(self,
                 policy_artifactTypeName,
                 instanceKey=None,
                 **kwargs):
        """
        [ HTTP: GET /configuration/policy/{artifactTypeName}/{instanceKey} ]

        @param policy_artifactTypeName: policy_artifactTypeName
        @type policy_artifactTypeName: str
        @param instanceKey: instanceKey
        @type instanceKey: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/policy/%(artifactTypeName)s/%(instanceKey)s"
        path_params = {"artifactTypeName": policy_artifactTypeName,
                       "instanceKey": instanceKey}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    evaluate.context = {'query_params': [], 'method_name': 'evaluate', 'method_docs': '[ HTTP: GET /configuration/policy/{artifactTypeName}/{instanceKey} ]', 'result': 'result', 'method_params': [{'name': 'artifactTypeName', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'policy_artifactTypeName'}, {'name': 'instanceKey', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'instanceKey'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'artifactTypeName', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'policy_artifactTypeName'}, {'name': 'instanceKey', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'instanceKey'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/policy/%(artifactTypeName)s/%(instanceKey)s', 'method_kind': 'GET'}

class configuration_resource(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getResources(self,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/resource ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getResources.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getResources', 'method_docs': '[ HTTP: GET /configuration/resource ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/resource', 'method_kind': 'GET'}

    @download
    def updateResource(self,
                       resource_id=None,
                       fields=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/resource/{id} ]

        @param resource_id: resource_id
        @type resource_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s"
        path_params = {"id": resource_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateResource.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updateResource', 'method_docs': '[ HTTP: PUT /configuration/resource/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resource_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resource_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/resource/%(id)s', 'method_kind': 'PUT'}

    @download
    def getResource(self,
                    resource_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /configuration/resource/{id} ]

        @param resource_id: resource_id
        @type resource_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s"
        path_params = {"id": resource_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getResource.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getResource', 'method_docs': '[ HTTP: GET /configuration/resource/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resource_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resource_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/resource/%(id)s', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/resource/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /configuration/resource/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'configuration/resource/import', 'method_kind': 'PUT'}

    @download
    def exportAction(self,
                     resource_id,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /configuration/resource/{id}/export ]

        @param resource_id: resource_id
        @type resource_id: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s/export"
        path_params = {"id": resource_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /configuration/resource/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'resource_id'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'resource_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/resource/%(id)s/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /configuration/resource/import ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /configuration/resource/import ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'configuration/resource/import', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        **kwargs):
        """
        [ HTTP: GET /configuration/resource/export ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /configuration/resource/export ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/resource/export', 'method_kind': 'GET'}

    @download
    def searchResources(self,
                        fields=None,
                        filterGroup=None,
                        limit=None,
                        offset=None,
                        orderBy=None,
                        usage=None,
                        **kwargs):
        """
        [ HTTP: GET /configuration/resource/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchResources.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchResources', 'method_docs': '[ HTTP: GET /configuration/resource/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/resource/search', 'method_kind': 'GET'}

    @download
    def deleteConfigurationResource(self,
                                    resource_id=None,
                                    **kwargs):
        """
        [ HTTP: DELETE /configuration/resource/{id} ]

        @param resource_id: resource_id
        @type resource_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "configuration/resource/%(id)s"
        path_params = {"id": resource_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteConfigurationResource.context = {'query_params': [], 'method_name': 'deleteConfigurationResource', 'method_docs': '[ HTTP: DELETE /configuration/resource/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resource_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'resource_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'configuration/resource/%(id)s', 'method_kind': 'DELETE'}

class alias(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def deleteAlias(self,
                    alias_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteAlias.context = {'query_params': [], 'method_name': 'deleteAlias', 'method_docs': '[ HTTP: DELETE /alias/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'alias/%(id)s', 'method_kind': 'DELETE'}

    @download
    def getAliasesXML(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /alias ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAliasesXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getAliasesXML', 'method_docs': '[ HTTP: GET /alias ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'alias', 'method_kind': 'GET'}

    @download
    def getAlias(self,
                 alias_id=None,
                 **kwargs):
        """
        [ HTTP: GET /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getAlias.context = {'query_params': [], 'method_name': 'getAlias', 'method_docs': '[ HTTP: GET /alias/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'alias/%(id)s', 'method_kind': 'GET'}

    @download
    def updateAlias(self,
                    alias_id=None,
                    data=None,
                    **kwargs):
        """
        [ HTTP: PUT /alias/{id} ]

        @param alias_id: alias_id
        @type alias_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "alias/%(id)s"
        path_params = {"id": alias_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateAlias.context = {'query_params': [], 'method_name': 'updateAlias', 'method_docs': '[ HTTP: PUT /alias/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'alias_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'alias/%(id)s', 'method_kind': 'PUT'}

class onboard(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def onboard(self,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /onboard ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    onboard.context = {'query_params': [], 'method_name': 'onboard', 'method_docs': '[ HTTP: POST /onboard ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'onboard', 'method_kind': 'POST'}

    @download
    def searchUnmanagedInstances_2(self,
                                   search_cloudId=None,
                                   fields=None,
                                   filterGroup=None,
                                   limit=None,
                                   offset=None,
                                   orderBy=None,
                                   usage=None,
                                   **kwargs):
        """
        [ HTTP: GET /onboard/search/{cloudId} ]

        @param search_cloudId: search_cloudId
        @type search_cloudId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/search/%(cloudId)s"
        path_params = {"cloudId": search_cloudId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchUnmanagedInstances_2.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchUnmanagedInstances_2', 'method_docs': '[ HTTP: GET /onboard/search/{cloudId} ]', 'result': 'result', 'method_params': [{'name': 'cloudId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'search_cloudId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'cloudId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'search_cloudId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'onboard/search/%(cloudId)s', 'method_kind': 'GET'}

    @download
    def searchUnmanagedInstances_1(self,
                                   fields=None,
                                   filterGroup=None,
                                   limit=None,
                                   offset=None,
                                   orderBy=None,
                                   usage=None,
                                   **kwargs):
        """
        [ HTTP: GET /onboard/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchUnmanagedInstances_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchUnmanagedInstances_1', 'method_docs': '[ HTTP: GET /onboard/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'onboard/search', 'method_kind': 'GET'}

    @download
    def getOnboardMeta_2(self,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /onboard/meta ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/meta"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOnboardMeta_2.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getOnboardMeta_2', 'method_docs': '[ HTTP: GET /onboard/meta ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'onboard/meta', 'method_kind': 'GET'}

    @download
    def getSearchFields(self,
                        field_id=None,
                        **kwargs):
        """
        [ HTTP: GET /onboard/search/field/{id} ]

        @param field_id: field_id
        @type field_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/search/field/%(id)s"
        path_params = {"id": field_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSearchFields.context = {'query_params': [], 'method_name': 'getSearchFields', 'method_docs': '[ HTTP: GET /onboard/search/field/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'field_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'field_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'onboard/search/field/%(id)s', 'method_kind': 'GET'}

    @download
    def getOnboardMeta_1(self,
                         meta_id=None,
                         fields=None,
                         **kwargs):
        """
        [ HTTP: GET /onboard/meta/{id} ]

        @param meta_id: meta_id
        @type meta_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/meta/%(id)s"
        path_params = {"id": meta_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getOnboardMeta_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getOnboardMeta_1', 'method_docs': '[ HTTP: GET /onboard/meta/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'meta_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'meta_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'onboard/meta/%(id)s', 'method_kind': 'GET'}

    @download
    def getClouds(self,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /onboard/cloud ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/cloud"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getClouds.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getClouds', 'method_docs': '[ HTTP: GET /onboard/cloud ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'onboard/cloud', 'method_kind': 'GET'}

    @download
    def preflight(self,
                  data=None,
                  **kwargs):
        """
        [ HTTP: POST /onboard/check ]

        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "onboard/check"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': '*/*'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    preflight.context = {'query_params': [], 'method_name': 'preflight', 'method_docs': '[ HTTP: POST /onboard/check ]', 'result': 'result', 'method_params': [{'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': '*/*'}, 'form_params': [], 'method_path': 'onboard/check', 'method_kind': 'POST'}

class port(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updatePort(self,
                   port_id=None,
                   fields=None,
                   data=None,
                   **kwargs):
        """
        [ HTTP: PUT /port/{id} ]

        @param port_id: port_id
        @type port_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "port/%(id)s"
        path_params = {"id": port_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updatePort.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'updatePort', 'method_docs': '[ HTTP: PUT /port/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'port/%(id)s', 'method_kind': 'PUT'}

    @download
    def syncPort(self,
                 port_id,
                 data=None,
                 **kwargs):
        """
        [ HTTP: POST /port/{id}/sync ]

        @param port_id: port_id
        @type port_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "port/%(id)s/sync"
        path_params = {"id": port_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    syncPort.context = {'query_params': [], 'method_name': 'syncPort', 'method_docs': '[ HTTP: POST /port/{id}/sync ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'port_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'port_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'port/%(id)s/sync', 'method_kind': 'POST'}

    @download
    def getPort(self,
                port_id=None,
                fields=None,
                **kwargs):
        """
        [ HTTP: GET /port/{id} ]

        @param port_id: port_id
        @type port_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "port/%(id)s"
        path_params = {"id": port_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPort.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPort', 'method_docs': '[ HTTP: GET /port/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'port/%(id)s', 'method_kind': 'GET'}

    @download
    def getPortsXML(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /port ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "port"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPortsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getPortsXML', 'method_docs': '[ HTTP: GET /port ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'port', 'method_kind': 'GET'}

    @download
    def deletePort(self,
                   port_id=None,
                   **kwargs):
        """
        [ HTTP: DELETE /port/{id} ]

        @param port_id: port_id
        @type port_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "port/%(id)s"
        path_params = {"id": port_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deletePort.context = {'query_params': [], 'method_name': 'deletePort', 'method_docs': '[ HTTP: DELETE /port/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'port_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'port/%(id)s', 'method_kind': 'DELETE'}

    @download
    def searchPorts(self,
                    containerId=None,
                    fields=None,
                    filterGroup=None,
                    limit=None,
                    offset=None,
                    orderBy=None,
                    qterm=None,
                    usage=None,
                    **kwargs):
        """
        [ HTTP: GET /port/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "port/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPorts.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchPorts', 'method_docs': '[ HTTP: GET /port/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'port/search', 'method_kind': 'GET'}

class tree(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getTreeProjects(self,
                        **kwargs):
        """
        [ HTTP: GET /tree/project ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "tree/project"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTreeProjects.context = {'query_params': [], 'method_name': 'getTreeProjects', 'method_docs': '[ HTTP: GET /tree/project ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'tree/project', 'method_kind': 'GET'}

    @download
    def getDesignTreeNode(self,
                          design_type,
                          id=None,
                          **kwargs):
        """
        [ HTTP: GET /tree/design/{type}/{id} ]

        @param design_type: design_type
        @type design_type: str
        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "tree/design/%(type)s/%(id)s"
        path_params = {"type": design_type,
                       "id": id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDesignTreeNode.context = {'query_params': [], 'method_name': 'getDesignTreeNode', 'method_docs': '[ HTTP: GET /tree/design/{type}/{id} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'design_type'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'design_type'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'tree/design/%(type)s/%(id)s', 'method_kind': 'GET'}

class container(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getContainers_2(self,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /container ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainers_2.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getContainers_2', 'method_docs': '[ HTTP: GET /container ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container', 'method_kind': 'GET'}

    @download
    def searchContainers(self,
                         containerId=None,
                         fields=None,
                         filterGroup=None,
                         limit=None,
                         offset=None,
                         orderBy=None,
                         qterm=None,
                         usage=None,
                         **kwargs):
        """
        [ HTTP: GET /container/search ]

        @param containerId: containerId
        @type containerId: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"containerId": containerId,
                        "fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchContainers.context = {'query_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchContainers', 'method_docs': '[ HTTP: GET /container/search ]', 'result': 'result', 'method_params': [{'name': 'containerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'containerId'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/search', 'method_kind': 'GET'}

    @download
    def addSecurity(self,
                    container_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /container/{id}/security ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurity.context = {'query_params': [], 'method_name': 'addSecurity', 'method_docs': '[ HTTP: POST /container/{id}/security ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/security', 'method_kind': 'POST'}

    @download
    def importIDAction_1(self,
                         container_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         files=None,
                         **kwargs):
        """
        [ HTTP: PUT /container/{id}/import ]

        @param container_id: container_id
        @type container_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/import"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_1', 'method_docs': '[ HTTP: PUT /container/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'container/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def getPolicies(self,
                    container_id,
                    fields=None,
                    type=None,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/policy ]

        @param container_id: container_id
        @type container_id: str
        @param fields: fields
        @type fields: str
        @param type: type
        @type type: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "type": type}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPolicies.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}], 'method_name': 'getPolicies', 'method_docs': '[ HTTP: GET /container/{id}/policy ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'type'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/policy', 'method_kind': 'GET'}

    @download
    def getContainer(self,
                     container_id=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainer.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getContainer', 'method_docs': '[ HTTP: GET /container/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'container_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s', 'method_kind': 'GET'}

    @download
    def deleteSecurityRights(self,
                             container_id,
                             security_id,
                             rights_id=None,
                             **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityRights.context = {'query_params': [], 'method_name': 'deleteSecurityRights', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s', 'method_kind': 'DELETE'}

    @download
    def importIDAction_2(self,
                         container_id,
                         create=None,
                         update=None,
                         dryRun=None,
                         data=None,
                         **kwargs):
        """
        [ HTTP: PUT /container/{id}/import ]

        @param container_id: container_id
        @type container_id: str
        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param dryRun: dryRun
        @type dryRun: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/import"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update,
                        "dryRun": dryRun}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importIDAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}], 'method_name': 'importIDAction_2', 'method_docs': '[ HTTP: PUT /container/{id}/import ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'dryRun', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'dryRun'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/import', 'method_kind': 'PUT'}

    @download
    def createConfigurationRepository(self,
                                      container_id,
                                      fields=None,
                                      data=None,
                                      **kwargs):
        """
        [ HTTP: POST /container/{id}/configuration/repository ]

        @param container_id: container_id
        @type container_id: str
        @param fields: fields
        @type fields: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/configuration/repository"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createConfigurationRepository.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'createConfigurationRepository', 'method_docs': '[ HTTP: POST /container/{id}/configuration/repository ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/configuration/repository', 'method_kind': 'POST'}

    @download
    def exportAction(self,
                     container_id,
                     exportOpts=None,
                     recursive=None,
                     **kwargs):
        """
        [ HTTP: GET /container/{id}/export ]

        @param container_id: container_id
        @type container_id: str
        @param exportOpts: exportOpts
        @type exportOpts: str
        @param recursive: recursive
        @type recursive: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/export"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts,
                        "recursive": recursive}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}], 'method_name': 'exportAction', 'method_docs': '[ HTTP: GET /container/{id}/export ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': 'recursive', 'defaultValue': None, 'kind': 'xs:boolean', 'required': False, 'alias': 'recursive'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/export', 'method_kind': 'GET'}

    @download
    def addSecurityUser(self,
                        container_id,
                        security_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/user ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/user"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUser.context = {'query_params': [], 'method_name': 'addSecurityUser', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/user ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/user', 'method_kind': 'POST'}

    @download
    def getSecurity(self,
                    container_id,
                    security_id=None,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/security/{security_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getSecurity.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getSecurity', 'method_docs': '[ HTTP: GET /container/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s', 'method_kind': 'GET'}

    @download
    def exportAll(self,
                  exportOpts=None,
                  **kwargs):
        """
        [ HTTP: GET /container/exportTree ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/exportTree"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAll.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAll', 'method_docs': '[ HTTP: GET /container/exportTree ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/exportTree', 'method_kind': 'GET'}

    @download
    def getProjects(self,
                    container_id,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /container/{id}/project ]

        @param container_id: container_id
        @type container_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/project"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getProjects.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getProjects', 'method_docs': '[ HTTP: GET /container/{id}/project ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/project', 'method_kind': 'GET'}

    @download
    def updateContainer(self,
                        container_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateContainer.context = {'query_params': [], 'method_name': 'updateContainer', 'method_docs': '[ HTTP: PUT /container/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'container_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s', 'method_kind': 'PUT'}

    @download
    def addSecurityUserGroup(self,
                             container_id,
                             security_id=None,
                             data=None,
                             **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/usergroup ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/usergroup"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityUserGroup.context = {'query_params': [], 'method_name': 'addSecurityUserGroup', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/usergroup ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/usergroup', 'method_kind': 'POST'}

    @download
    def addSecurityAccessRight(self,
                               container_id,
                               security_id,
                               rights_id=None,
                               data=None,
                               **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/rights/{rights_id}/accessright ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityAccessRight.context = {'query_params': [], 'method_name': 'addSecurityAccessRight', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/rights/{rights_id}/accessright ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'rights_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright', 'method_kind': 'POST'}

    @download
    def attachPolicy(self,
                     container_id,
                     policyid=None,
                     data=None,
                     **kwargs):
        """
        [ HTTP: PUT /container/{id}/policy/{policyid} ]

        @param container_id: container_id
        @type container_id: str
        @param policyid: policyid
        @type policyid: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy/%(policyid)s"
        path_params = {"id": container_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    attachPolicy.context = {'query_params': [], 'method_name': 'attachPolicy', 'method_docs': '[ HTTP: PUT /container/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/policy/%(policyid)s', 'method_kind': 'PUT'}

    @download
    def exportAllAction(self,
                        exportOpts=None,
                        **kwargs):
        """
        [ HTTP: GET /container/export ]

        @param exportOpts: exportOpts
        @type exportOpts: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/export"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"exportOpts": exportOpts}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    exportAllAction.context = {'query_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}], 'method_name': 'exportAllAction', 'method_docs': '[ HTTP: GET /container/export ]', 'result': 'result', 'method_params': [{'name': 'exportOpts', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'exportOpts'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/export', 'method_kind': 'GET'}

    @download
    def importAction_2(self,
                       create=None,
                       update=None,
                       data=None,
                       **kwargs):
        """
        [ HTTP: PUT /container/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_2.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_2', 'method_docs': '[ HTTP: PUT /container/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/import', 'method_kind': 'PUT'}

    @download
    def removePolicy(self,
                     container_id,
                     policyid=None,
                     **kwargs):
        """
        [ HTTP: DELETE /container/{id}/policy/{policyid} ]

        @param container_id: container_id
        @type container_id: str
        @param policyid: policyid
        @type policyid: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policy/%(policyid)s"
        path_params = {"id": container_id,
                       "policyid": policyid}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    removePolicy.context = {'query_params': [], 'method_name': 'removePolicy', 'method_docs': '[ HTTP: DELETE /container/{id}/policy/{policyid} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'policyid', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'policyid'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/policy/%(policyid)s', 'method_kind': 'DELETE'}

    @download
    def deleteContainer(self,
                        container_id=None,
                        **kwargs):
        """
        [ HTTP: DELETE /container/{id} ]

        @param container_id: container_id
        @type container_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteContainer.context = {'query_params': [], 'method_name': 'deleteContainer', 'method_docs': '[ HTTP: DELETE /container/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'container_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurityUserGroup(self,
                                container_id,
                                security_id,
                                usergroup_id=None,
                                **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/usergroup/{usergroup_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param usergroup_id: usergroup_id
        @type usergroup_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "usergroup_id": usergroup_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUserGroup.context = {'query_params': [], 'method_name': 'deleteSecurityUserGroup', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/usergroup/{usergroup_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'usergroup_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'usergroup_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/usergroup/%(usergroup_id)s', 'method_kind': 'DELETE'}

    @download
    def deleteSecurity(self,
                       container_id,
                       security_id=None,
                       **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurity.context = {'query_params': [], 'method_name': 'deleteSecurity', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s', 'method_kind': 'DELETE'}

    @download
    def createProject(self,
                      container_id,
                      data=None,
                      **kwargs):
        """
        [ HTTP: POST /container/{id}/project ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/project"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createProject.context = {'query_params': [], 'method_name': 'createProject', 'method_docs': '[ HTTP: POST /container/{id}/project ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/project', 'method_kind': 'POST'}

    @download
    def getContainers_1(self,
                        container_id,
                        fields=None,
                        **kwargs):
        """
        [ HTTP: GET /container/{id}/container ]

        @param container_id: container_id
        @type container_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/container"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getContainers_1.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getContainers_1', 'method_docs': '[ HTTP: GET /container/{id}/container ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/container', 'method_kind': 'GET'}

    @download
    def addSecurityRights(self,
                          container_id,
                          security_id=None,
                          data=None,
                          **kwargs):
        """
        [ HTTP: POST /container/{id}/security/{security_id}/rights ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights"
        path_params = {"id": container_id,
                       "security_id": security_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    addSecurityRights.context = {'query_params': [], 'method_name': 'addSecurityRights', 'method_docs': '[ HTTP: POST /container/{id}/security/{security_id}/rights ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'security_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/rights', 'method_kind': 'POST'}

    @download
    def searchPolicyAssignments(self,
                                container_id,
                                fields=None,
                                filterGroup=None,
                                limit=None,
                                offset=None,
                                orderBy=None,
                                qterm=None,
                                usage=None,
                                showLocal=None,
                                showInherited=None,
                                **kwargs):
        """
        [ HTTP: GET /container/{id}/policyassignment/search ]

        @param container_id: container_id
        @type container_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param qterm: qterm
        @type qterm: str
        @param usage: usage
        @type usage: str
        @param showLocal: showLocal
        @type showLocal: str
        @param showInherited: showInherited
        @type showInherited: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/policyassignment/search"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "qterm": qterm,
                        "usage": usage,
                        "showLocal": showLocal,
                        "showInherited": showInherited}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchPolicyAssignments.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}], 'method_name': 'searchPolicyAssignments', 'method_docs': '[ HTTP: GET /container/{id}/policyassignment/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'qterm', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'qterm'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': 'showLocal', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showLocal'}, {'name': 'showInherited', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'showInherited'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/policyassignment/search', 'method_kind': 'GET'}

    @download
    def importAction_1(self,
                       create=None,
                       update=None,
                       data=None,
                       files=None,
                       **kwargs):
        """
        [ HTTP: PUT /container/import ]

        @param create: create
        @type create: str
        @param update: update
        @type update: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @files: list of file paths, would be encoded as multipart request, e.g. attachments
        @type: list
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/import"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {"create": create,
                        "update": update}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/x-zip'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=files)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    importAction_1.context = {'query_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}], 'method_name': 'importAction_1', 'method_docs': '[ HTTP: PUT /container/import ]', 'result': 'result', 'method_params': [{'name': 'create', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'create'}, {'name': 'update', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'update'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': 'files', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'files'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [], 'hasFiles': True, 'custom_headers': {'Content-Type': 'application/x-zip'}, 'form_params': [], 'method_path': 'container/import', 'method_kind': 'PUT'}

    @download
    def deleteSecurityUser(self,
                           container_id,
                           security_id,
                           user_id=None,
                           **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/user/{user_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param user_id: user_id
        @type user_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/user/%(user_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "user_id": user_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityUser.context = {'query_params': [], 'method_name': 'deleteSecurityUser', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/user/{user_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'user_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'user_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/user/%(user_id)s', 'method_kind': 'DELETE'}

    @download
    def createContainer(self,
                        container_id,
                        data=None,
                        **kwargs):
        """
        [ HTTP: POST /container/{id}/container ]

        @param container_id: container_id
        @type container_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/container"
        path_params = {"id": container_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createContainer.context = {'query_params': [], 'method_name': 'createContainer', 'method_docs': '[ HTTP: POST /container/{id}/container ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'container/%(id)s/container', 'method_kind': 'POST'}

    @download
    def deleteSecurityAccessRight(self,
                                  container_id,
                                  security_id,
                                  rights_id,
                                  accessright_id=None,
                                  **kwargs):
        """
        [ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]

        @param container_id: container_id
        @type container_id: str
        @param security_id: security_id
        @type security_id: str
        @param rights_id: rights_id
        @type rights_id: str
        @param accessright_id: accessright_id
        @type accessright_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s"
        path_params = {"id": container_id,
                       "security_id": security_id,
                       "rights_id": rights_id,
                       "accessright_id": accessright_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteSecurityAccessRight.context = {'query_params': [], 'method_name': 'deleteSecurityAccessRight', 'method_docs': '[ HTTP: DELETE /container/{id}/security/{security_id}/rights/{rights_id}/accessright/{accessright_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'container_id'}, {'name': 'security_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'security_id'}, {'name': 'rights_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'rights_id'}, {'name': 'accessright_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'accessright_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'container/%(id)s/security/%(security_id)s/rights/%(rights_id)s/accessright/%(accessright_id)s', 'method_kind': 'DELETE'}

class cloudtype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getCloudTypes(self,
                      fields=None,
                      **kwargs):
        """
        [ HTTP: GET /cloudtype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCloudTypes', 'method_docs': '[ HTTP: GET /cloudtype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloudtype', 'method_kind': 'GET'}

    @download
    def createModel(self,
                    cloudtype_id,
                    data=None,
                    **kwargs):
        """
        [ HTTP: POST /cloudtype/{id}/model ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createModel.context = {'query_params': [], 'method_name': 'createModel', 'method_docs': '[ HTTP: POST /cloudtype/{id}/model ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloudtype/%(id)s/model', 'method_kind': 'POST'}

    @download
    def deleteModel(self,
                    cloudtype_id,
                    model_id=None,
                    **kwargs):
        """
        [ HTTP: DELETE /cloudtype/{id}/model/{model_id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param model_id: model_id
        @type model_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/%(model_id)s"
        path_params = {"id": cloudtype_id,
                       "model_id": model_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteModel.context = {'query_params': [], 'method_name': 'deleteModel', 'method_docs': '[ HTTP: DELETE /cloudtype/{id}/model/{model_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'model_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'model_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloudtype/%(id)s/model/%(model_id)s', 'method_kind': 'DELETE'}

    @download
    def getModels(self,
                  cloudtype_id,
                  fields=None,
                  **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModels.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getModels', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloudtype/%(id)s/model', 'method_kind': 'GET'}

    @download
    def updateCloudType(self,
                        cloudtype_id=None,
                        data=None,
                        **kwargs):
        """
        [ HTTP: PUT /cloudtype/{id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateCloudType.context = {'query_params': [], 'method_name': 'updateCloudType', 'method_docs': '[ HTTP: PUT /cloudtype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloudtype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloudtype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'cloudtype/%(id)s', 'method_kind': 'PUT'}

    @download
    def getModel(self,
                 cloudtype_id,
                 model_id=None,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model/{model_id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param model_id: model_id
        @type model_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/%(model_id)s"
        path_params = {"id": cloudtype_id,
                       "model_id": model_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getModel.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getModel', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model/{model_id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'model_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'model_id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'model_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloudtype/%(id)s/model/%(model_id)s', 'method_kind': 'GET'}

    @download
    def searchCloudTypeModelsXML(self,
                                 cloudtype_id,
                                 fields=None,
                                 filterGroup=None,
                                 limit=None,
                                 offset=None,
                                 orderBy=None,
                                 usage=None,
                                 **kwargs):
        """
        [ HTTP: GET /cloudtype/{id}/model/search ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s/model/search"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchCloudTypeModelsXML.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchCloudTypeModelsXML', 'method_docs': '[ HTTP: GET /cloudtype/{id}/model/search ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'cloudtype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloudtype/%(id)s/model/search', 'method_kind': 'GET'}

    @download
    def getCloudType(self,
                     cloudtype_id=None,
                     fields=None,
                     **kwargs):
        """
        [ HTTP: GET /cloudtype/{id} ]

        @param cloudtype_id: cloudtype_id
        @type cloudtype_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "cloudtype/%(id)s"
        path_params = {"id": cloudtype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getCloudType.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getCloudType', 'method_docs': '[ HTTP: GET /cloudtype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloudtype_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'cloudtype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'cloudtype/%(id)s', 'method_kind': 'GET'}

class paastype(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def searchTypes(self,
                    fields=None,
                    filterGroup=None,
                    limit=None,
                    offset=None,
                    orderBy=None,
                    usage=None,
                    **kwargs):
        """
        [ HTTP: GET /paastype/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchTypes', 'method_docs': '[ HTTP: GET /paastype/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paastype/search', 'method_kind': 'GET'}

    @download
    def getPlatformServiceType(self,
                               paastype_id=None,
                               **kwargs):
        """
        [ HTTP: GET /paastype/{id} ]

        @param paastype_id: paastype_id
        @type paastype_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype/%(id)s"
        path_params = {"id": paastype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPlatformServiceType.context = {'query_params': [], 'method_name': 'getPlatformServiceType', 'method_docs': '[ HTTP: GET /paastype/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paastype_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'paastype_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paastype/%(id)s', 'method_kind': 'GET'}

    @download
    def createArtifactType(self,
                           paastype_id,
                           data=None,
                           **kwargs):
        """
        [ HTTP: POST /paastype/{id}/artifacttype ]

        @param paastype_id: paastype_id
        @type paastype_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype/%(id)s/artifacttype"
        path_params = {"id": paastype_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createArtifactType.context = {'query_params': [], 'method_name': 'createArtifactType', 'method_docs': '[ HTTP: POST /paastype/{id}/artifacttype ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'paastype_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'paastype_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'paastype/%(id)s/artifacttype', 'method_kind': 'POST'}

    @download
    def getTypes(self,
                 fields=None,
                 **kwargs):
        """
        [ HTTP: GET /paastype ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "paastype"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getTypes.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getTypes', 'method_docs': '[ HTTP: GET /paastype ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'paastype', 'method_kind': 'GET'}

class security(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def clearCache(self,
                   **kwargs):
        """
        [ HTTP: DELETE /security/cache ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/cache"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    clearCache.context = {'query_params': [], 'method_name': 'clearCache', 'method_docs': '[ HTTP: DELETE /security/cache ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'security/cache', 'method_kind': 'DELETE'}

    @download
    def getEffectiveRights(self,
                           security_type,
                           id=None,
                           **kwargs):
        """
        [ HTTP: GET /security/{type}/{id} ]

        @param security_type: security_type
        @type security_type: str
        @param id: id
        @type id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/%(type)s/%(id)s"
        path_params = {"type": security_type,
                       "id": id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveRights.context = {'query_params': [], 'method_name': 'getEffectiveRights', 'method_docs': '[ HTTP: GET /security/{type}/{id} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'security_type'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'security_type'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'security/%(type)s/%(id)s', 'method_kind': 'GET'}

    @download
    def checkGlobalRight(self,
                         rightname=None,
                         **kwargs):
        """
        [ HTTP: GET /security/global/right/{rightname} ]

        @param rightname: rightname
        @type rightname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/global/right/%(rightname)s"
        path_params = {"rightname": rightname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkGlobalRight.context = {'query_params': [], 'method_name': 'checkGlobalRight', 'method_docs': '[ HTTP: GET /security/global/right/{rightname} ]', 'result': 'result', 'method_params': [{'name': 'rightname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'rightname'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'rightname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'rightname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'security/global/right/%(rightname)s', 'method_kind': 'GET'}

    @download
    def getPermittedTree(self,
                         tree_type,
                         action=None,
                         startContainerId=None,
                         format=None,
                         **kwargs):
        """
        [ HTTP: GET /security/tree/{type}/{action} ]

        @param tree_type: tree_type
        @type tree_type: str
        @param action: action
        @type action: str
        @param startContainerId: startContainerId
        @type startContainerId: str
        @param format: format
        @type format: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/tree/%(type)s/%(action)s"
        path_params = {"type": tree_type,
                       "action": action}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"startContainerId": startContainerId,
                        "format": format}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getPermittedTree.context = {'query_params': [{'name': 'startContainerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'startContainerId'}, {'name': 'format', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'format'}], 'method_name': 'getPermittedTree', 'method_docs': '[ HTTP: GET /security/tree/{type}/{action} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'tree_type'}, {'name': 'action', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'action'}, {'name': 'startContainerId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'startContainerId'}, {'name': 'format', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'format'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'tree_type'}, {'name': 'action', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'action'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'security/tree/%(type)s/%(action)s', 'method_kind': 'GET'}

    @download
    def getEffectiveGlobalRights(self,
                                 **kwargs):
        """
        [ HTTP: GET /security/global ]

        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/global"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEffectiveGlobalRights.context = {'query_params': [], 'method_name': 'getEffectiveGlobalRights', 'method_docs': '[ HTTP: GET /security/global ]', 'result': 'result', 'method_params': [{'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'security/global', 'method_kind': 'GET'}

    @download
    def checkRight(self,
                   security_type,
                   id,
                   rightname=None,
                   **kwargs):
        """
        [ HTTP: GET /security/{type}/{id}/right/{rightname} ]

        @param security_type: security_type
        @type security_type: str
        @param id: id
        @type id: str
        @param rightname: rightname
        @type rightname: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "security/%(type)s/%(id)s/right/%(rightname)s"
        path_params = {"type": security_type,
                       "id": id,
                       "rightname": rightname}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    checkRight.context = {'query_params': [], 'method_name': 'checkRight', 'method_docs': '[ HTTP: GET /security/{type}/{id}/right/{rightname} ]', 'result': 'result', 'method_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'security_type'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}, {'name': 'rightname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'rightname'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'type', 'defaultValue': None, 'kind': 'xs:string', 'required': True, 'alias': 'security_type'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'id'}, {'name': 'rightname', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'rightname'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'security/%(type)s/%(id)s/right/%(rightname)s', 'method_kind': 'GET'}

class blueprint_designcontainer(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def getDesignContainer(self,
                           blueprint_bp_id,
                           designcontainer_id=None,
                           **kwargs):
        """
        [ HTTP: GET /blueprint/{bp_id}/designcontainer/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": designcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getDesignContainer.context = {'query_params': [], 'method_name': 'getDesignContainer', 'method_docs': '[ HTTP: GET /blueprint/{bp_id}/designcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/designcontainer/%(id)s', 'method_kind': 'GET'}

    @download
    def createDesignContainer(self,
                              blueprint_bp_id,
                              data=None,
                              **kwargs):
        """
        [ HTTP: POST /blueprint/{bp_id}/designcontainer ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer"
        path_params = {"bp_id": blueprint_bp_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    createDesignContainer.context = {'query_params': [], 'method_name': 'createDesignContainer', 'method_docs': '[ HTTP: POST /blueprint/{bp_id}/designcontainer ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/designcontainer', 'method_kind': 'POST'}

    @download
    def updateDesignContainer(self,
                              blueprint_bp_id,
                              designcontainer_id=None,
                              data=None,
                              **kwargs):
        """
        [ HTTP: PUT /blueprint/{bp_id}/designcontainer/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": designcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateDesignContainer.context = {'query_params': [], 'method_name': 'updateDesignContainer', 'method_docs': '[ HTTP: PUT /blueprint/{bp_id}/designcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/designcontainer/%(id)s', 'method_kind': 'PUT'}

    @download
    def deleteDesignContainer(self,
                              blueprint_bp_id,
                              designcontainer_id=None,
                              **kwargs):
        """
        [ HTTP: DELETE /blueprint/{bp_id}/designcontainer/{id} ]

        @param blueprint_bp_id: blueprint_bp_id
        @type blueprint_bp_id: str
        @param designcontainer_id: designcontainer_id
        @type designcontainer_id: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "blueprint/%(bp_id)s/designcontainer/%(id)s"
        path_params = {"bp_id": blueprint_bp_id,
                       "id": designcontainer_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("DELETE", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    deleteDesignContainer.context = {'query_params': [], 'method_name': 'deleteDesignContainer', 'method_docs': '[ HTTP: DELETE /blueprint/{bp_id}/designcontainer/{id} ]', 'result': 'result', 'method_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'bp_id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'blueprint_bp_id'}, {'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'designcontainer_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'blueprint/%(bp_id)s/designcontainer/%(id)s', 'method_kind': 'DELETE'}

class storeedition(Endpoint):
    """

    """
    def __init__(self, conn):
        self._conn = conn

    @download
    def updateEdition(self,
                      storeedition_id=None,
                      data=None,
                      **kwargs):
        """
        [ HTTP: PUT /storeedition/{id} ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s"
        path_params = {"id": storeedition_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("PUT", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    updateEdition.context = {'query_params': [], 'method_name': 'updateEdition', 'method_docs': '[ HTTP: PUT /storeedition/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeedition_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeedition_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storeedition/%(id)s', 'method_kind': 'PUT'}

    @download
    def getEdition(self,
                   storeedition_id=None,
                   fields=None,
                   **kwargs):
        """
        [ HTTP: GET /storeedition/{id} ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s"
        path_params = {"id": storeedition_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEdition.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEdition', 'method_docs': '[ HTTP: GET /storeedition/{id} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeedition_id'}, {'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'storeedition_id'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeedition/%(id)s', 'method_kind': 'GET'}

    @download
    def order_2(self,
                storeedition_id,
                order_locationId=None,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /storeedition/{id}/order/{locationId} ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param order_locationId: order_locationId
        @type order_locationId: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s/order/%(locationId)s"
        path_params = {"id": storeedition_id,
                       "locationId": order_locationId}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    order_2.context = {'query_params': [], 'method_name': 'order_2', 'method_docs': '[ HTTP: POST /storeedition/{id}/order/{locationId} ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeedition_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'order_locationId'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeedition_id'}, {'name': 'locationId', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'order_locationId'}], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeedition/%(id)s/order/%(locationId)s', 'method_kind': 'POST'}

    @download
    def searchEditions(self,
                       fields=None,
                       filterGroup=None,
                       limit=None,
                       offset=None,
                       orderBy=None,
                       usage=None,
                       **kwargs):
        """
        [ HTTP: GET /storeedition/search ]

        @param fields: fields
        @type fields: str
        @param filterGroup: filterGroup
        @type filterGroup: str
        @param limit: limit
        @type limit: str
        @param offset: offset
        @type offset: str
        @param orderBy: orderBy
        @type orderBy: str
        @param usage: usage
        @type usage: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/search"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields,
                        "filterGroup": filterGroup,
                        "limit": limit,
                        "offset": offset,
                        "orderBy": orderBy,
                        "usage": usage}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    searchEditions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}], 'method_name': 'searchEditions', 'method_docs': '[ HTTP: GET /storeedition/search ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': 'filterGroup', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'filterGroup'}, {'name': 'limit', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'limit'}, {'name': 'offset', 'defaultValue': None, 'kind': 'xs:int', 'required': False, 'alias': 'offset'}, {'name': 'orderBy', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'orderBy'}, {'name': 'usage', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'usage'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeedition/search', 'method_kind': 'GET'}

    @download
    def order_1(self,
                storeedition_id,
                data=None,
                **kwargs):
        """
        [ HTTP: POST /storeedition/{id}/order ]

        @param storeedition_id: storeedition_id
        @type storeedition_id: str
        @param data: POST or PUT data, can be XML text or content of file to import
        @type data: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition/%(id)s/order"
        path_params = {"id": storeedition_id}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        if data is not None:
            data = str(data)


        query_params = kwargs
        wadl_query_params = {}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {'Content-Type': 'application/xml'}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, data)
        response = self._conn.invoke_method("POST", path, path_params,
                                         query_params, form_params, data=data, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    order_1.context = {'query_params': [], 'method_name': 'order_1', 'method_docs': '[ HTTP: POST /storeedition/{id}/order ]', 'result': 'result', 'method_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeedition_id'}, {'name': 'data', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': 'data'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': True, 'path_params': [{'name': 'id', 'defaultValue': None, 'kind': 'xs:int', 'required': True, 'alias': 'storeedition_id'}], 'hasFiles': False, 'custom_headers': {'Content-Type': 'application/xml'}, 'form_params': [], 'method_path': 'storeedition/%(id)s/order', 'method_kind': 'POST'}

    @download
    def getEditions(self,
                    fields=None,
                    **kwargs):
        """
        [ HTTP: GET /storeedition ]

        @param fields: fields
        @type fields: str
        @param **kwargs: keyword arguments param1=value1, param2=value2, will be used as the URL parameters: https://url?param1=value1&param2=value2
        @type **kwargs: keyword argument list or expanded dict, e.g. **dct
        """
        path = "storeedition"
        path_params = {}

        #convenience parameter conversion logic
        for k, v in path_params.items():
            if v is None: continue
            if hasattr(v, 'id'):
                path_params[k] = v.id
            elif not isinstance(v, str):
                path_params[k] = str(v)

        

        query_params = kwargs
        wadl_query_params = {"fields": fields}

        query_params.update(wadl_query_params)
        form_params = {}
        wadl_custom_headers = {}
        custom_headers = {}
        custom_headers.update(wadl_custom_headers)


        logger.debug('Invoking path: %s, path_params: %s, query_params: %s, form_params: %s, data: %s', path, path_params, query_params, form_params, None)
        response = self._conn.invoke_method("GET", path, path_params,
                                         query_params, form_params, data=None, custom_headers=custom_headers, files=None)
        if not str(response.getcode()).startswith('2'): #OK 200, CREATED 201, Accepted 202, Partial Information 203, No Response 204
            raise RESTException(response)

        result = response

        return result
    getEditions.context = {'query_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}], 'method_name': 'getEditions', 'method_docs': '[ HTTP: GET /storeedition ]', 'result': 'result', 'method_params': [{'name': 'fields', 'defaultValue': None, 'kind': 'xs:string', 'required': False, 'alias': 'fields'}, {'name': '**kwargs', 'defaultValue': None, 'kind': 'str', 'required': False, 'alias': '**kwargs'}], 'hasData': False, 'path_params': [], 'hasFiles': False, 'custom_headers': {}, 'form_params': [], 'method_path': 'storeedition', 'method_kind': 'GET'}
